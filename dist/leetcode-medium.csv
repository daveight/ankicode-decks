"Two Sum"	"Time : O(N) ; Space: O(N)
 
Description:
Given an array of integers, find two numbers such that they add up to 
a specific target number. 
The function twoSum should return indices of the two numbers such that 
they add up to the target, where index1 must be less than index2. 
Please note that your returned answers (both index1 and index2) are not 
zero-based. 
You may assume that each input would have exactly one solution. 
Input: numbers={2, 7, 11, 15}, target=9 
Output: index1=1, index2=2
 
{@link https://leetcode.com/problems/two-sum/ }"	"twoSum"	"### Java
```java
public class Solution {

    /**
     * Construct a map to memo expected value and its index. 
     */
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            int number = nums[i];
            if (indexMap.containsKey(number)) {
                // found the two numbers we are looking for!
                // ! required result is not zero-based indexed, but 1-based
                result[0] = 1 + indexMap.get(number);
                result[1] = 1 + i;
                break;
            } else {
                // put the number we are expecting into the map
                indexMap.put(target - number, i);
            }
        }
        return result;
    }
}
```"	"array(int)[nums];int[target];array(int)
[2, 7, 11, 13];9;[1, 2]
[13, 7, 11, 2];9;[2, 4]
[13, 11, 7, 2];9;[3, 4]
[13, 11, 7, 2];24;[1, 2]
[13, 11, 7, 2];15;[1, 4]
[4, 7, -4, 2, 2, 2, 3, -5, -3, 9, -4, 9, -7, 7, -1, 9, 9, 4, 1, -4, -2, 3, -3, -5, 4, -7, 7, 9, -4, 4, -8];-3;[6, 8]

"
"Add Two Numbers"	"Time : O(N); Space : O(1)
 
Description: 
You are given two linked lists representing two non-negative numbers. 
The digits are stored in reverse order and each of their nodes contain 
l1 single digit. Add the two numbers and return it as l1 linked list. 
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) 
Output: 7 -> 0 -> 8
 
Similar to Leetcode[067]
{@link https://leetcode.com/problems/add-two-numbers/ }"	"addTwoNumbers"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    /**
     * Construct a map to memo expected value and its index. 
     */
   public ListNode addTwoNumbers(ListNode<Integer> l1, ListNode<Integer> l2) {
        ListNode<Integer> dummy = new ListNode();
        ListNode<Integer> node = dummy;
        int carry = 0;
        while (l1 != null || l2 != null || carry != 0) {
            int n1 = l1 != null ? l1.data : 0;
            int n2 = l2 != null ? l2.data : 0;
            int sum = n1 + n2 + carry;
            node.next = new ListNode();
            node.next.data = sum % 10;
            node = node.next;
            carry = sum / 10;
            l1 = l1 != null ? l1.next : null;
            l2 = l2 != null ? l2.next : null;
        }
        return dummy.next;
    }
}
```"	"linked_list(int)[nums1];linked_list(int)[nums2];linked_list(int)
[2, 1, 4, 2, 3];[5, 1, 6, 2, 4];[7, 0, 8]
[2];[9, 1, 9, 2, 4];[1, 0, 5]
[2];[8];[0, 1]
[9, 1, 9, 2, 4];[3];[2, 0, 5]
[0];[0, 1, 2];[0, 2]
"
"Longest Substring Without Repeating Characters"	"Time : O(N) ; Space: O(1)
 
Description:
Given a string, find the length of the longest substring without repeating 
characters. For example, the longest substring without repeating letters 
for ""abcabcbb"" is ""abc"", which the length is 3. For ""bbbbb"" the longest 
substring is ""b"", with the length of 1.
 
{@link https://leetcode.com/problems/longest-substring-without-repeating-characters/ }"	"lengthOfLongestSubstring"	"### Java
```java
/**
 * Use two pointers to keep a window. Check repeating character: 1) repeat in
 * map; 2) within current window
 * 
 */
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int result = 0;
        int start = 0;  // left side of window
        // character, and index in s of its latest appearance
        Map<Character, Integer> posMap = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            // if repeated in current window
            if (posMap.containsKey(ch) && posMap.get(ch) >= start) {
                // move left side of current window to remove repeated character
                start = posMap.get(ch) + 1;
            } else {
                // window is expanding
                result = Math.max(result, i - start + 1);
            }
            posMap.put(ch, i);
        }
        return result;
    }
}
```"	"string[s];int
"""";0
""abcabcbb"";3
""bbbb"";1
""Wnb9z9dMc7E8v1RTUaZPoDNIAXRlzkqLaa97KMWLzbitaCkRpiE4J4hJWhRcGnC8H6mwasgDfZ76VKdXhvEYmYrZY4Cfmf4HoSlchYWFEb1xllGKyEEmZOLPh1V6RuM7Mxd7xK72aNrWS4MEaUmgEn7L4rW3o14Nq9l2EN4HH6uJWljI8a5irvuODHY7A7ku4PJY2anSWnfJJE1w8p12Ks3oZRxAF3atqGBlzVQ0gltOwYmeynttUmQ4QBDLDrS4zn4VRZLosOITo4JlIqPD6t4NjhHThOjJxpMp9fICkrgJeGiDAwsb8a3I7Txz5BBKV9bEfMsKNhCuY3W0ZHqY0MhBfz1CbYCzwZZdM4p65ppP9s5QJcfjadmMMi26JKz0TVVwvNA8LP5Vi1QsxId4SI19jfcUH97wmZu0pbw1zFtyJ8GAp5yjjQTzFIboC1iRzklnOJzJld9TMaxqvBNBJKIyDjWrdfLOY8FGMOcPhfJ97Dph35zfxYyUf4DIqFi94lm9J0skYqGz9JT0kiAABQZDazZcNi80dSSdveSl6h3dJjHmlK8qHIlDsqFd5FMhlEirax8WA0v3NDPT8vPhwKpxcnVeu14Gcxr3h1wAXXV0y7Xy9qqB2NQ5HQLJ7cyXAckEYHsLCPSy28xcdNJatx1KLWohOQado4WywJbGvsFR17rKmvOPABweXnFD3odrbSMD4Na4nuBBswvMmFRTUOcf7jZi4z5JnJqXz6hitaPnaEtjoSEBq82a52nvqYy7hhldBoxen2et2OMadVEHeTYLL7GLsIhTP6UizHIuzcJMljo4lFgW5AyrfUlIBPAlhwaSiJtTvcbVZynDSM6RO1PqFKWKg2MHIgNhjuzENg2oFCfW7z5KJvEL9qWqKzZNc0o3BMRjS04NCHFvhtsteQoQRgz84XZBHBJRdekCdcVVXu9c01gYRAz7oIAxN3zKZb64EFKssfQ4HW971jv3H7x5E9dAszA0HrKTONyZDGYtHWt4QLhNsIs8mo4AIN7ecFKewyvGECAnaJpDn1MTTS4yTgZnm6N6qnmfjVt6ZU51F9BxH0jVG0kovTGSjTUkmb1mRTLQE5mTlVHcEz3yBOh4WiFFJjKJdi1HBIBaDL4r45HzaBvmYJPlWIomkqKEmQ4rLAbYG7C5rFfpMu8rHvjU7hP0JVvteGtaGn7mqeKsn7CgrJX1tb8t0ldaS3iUy8SEKAo5IZHNKOfEaij3nI4oRVzeVOZsH91pMsA4jRYgEohubPW8ciXwVrFi1qEWjvB8gfalyP60n1fHyjsiLW0T5uY1JzQWHKCbLVh7QFoJFAEV0L516XmzIo556yRH1vhPnceOCjebqgsmO78AQ8Ir2d4pHFFHAGB9lESn3OtJye1Lcyq9D6X93UakA3JKVKEt6JZDLVBMp4msOefkPKSw59Uix9d9kOQm8WCepJTangdNSOKaxblZDNJ5eHvEroYacBhd9UdafEitdF3nfStF7AhkSfQVC61YWWkKTNdx96OoJGTnxuqt4oFZNFtO7aMuN3IJAkw3m3kgZFRGyd3D3wweagNL9XlYtvZwejbjpkDOZz33C0jbEWaMEaUPw6BG49XqyQoUwtriguO0yvWyaJqD4ye3o0E46huKYAsdKAq6MLWMxF6tfyPVaoqOGd0eOBHbAF89XXmDd4AIkoFPXkAOW8hln5nXnIWP6RBbfEkPPbxoToMbV"";27
"
"Longest Palindromic Substring"	"Time : O(N^2); Space : O(1)
 
Description: 
Given a string S, find the longest palindromic substring in S. You may 
assume that the maximum length of S is 1000, and there exists one 
unique longest palindromic substring.
 
{@link https://leetcode.com/problems/longest-palindromic-substring/ }"	"longestPalindrome"	"### Java
```java
public class Solution {

    /**
     * Choose center for a possible palindrome string, then span string towards
     * left and right. At the same time, update global best result.
     */
    public String longestPalindrome(String s) {
        int longest = 0; // length of up-to-now longest palindrome substring
        int left = -1;   // left index of longest P substring
        int right = -1;  // right index of longest P substring
        int upper = 2 * s.length();
        int len = s.length();
        for (int i = 0; i < upper; i++) {
            int l = 0;
            int r = 0;
            if (i % 2 == 0) {
                // use A[i / 2] as center
                l = i / 2 - 1;
                r = i / 2 + 1;
            } else {
                // use gap betwen A[(i-1)/2] and A[(i+1)/2] as center
                l = (i - 1) / 2;
                r = (i + 1) / 2;
            }
            while (l >= 0 && r < len && s.charAt(l) == s.charAt(r)) {
                l--;
                r++;
            }
            // palindrome length
            int length = r - l - 1;
            if (length > longest) {
                // update global max
                longest = length;
                left = l + 1;
                right = r - 1;
            }
        }
        return longest == 0 ? """" : s.substring(left, right + 1);
    }
}
```"	"string[s];string
""abb"";""bb""
""abdbbbbdba"";""abdbbbbdba""
""abdbabbdba"";""abdba""
"
"Container With Most Water"	"Time : O(N) ; Space: O(1)
 
Description:
 
Given n non-negative integers a1, a2, ..., an, where each represents a 
point at coordinate (i, ai). n vertical lines are drawn such that the 
two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which 
together with x-axis forms a container, such that the container contains 
the most water. 
Note: You may not slant the container.
 
{@link https://leetcode.com/problems/container-with-most-water/ }
1. head-tail pointers"	"maxArea"	"### Java
```java
/**
 * <p>
 * 1. Set left bar at the leftmost position and right bar at the rightmost
 * position.
 * <p>
 * 2. Each time, compare the height[left] with height[right] and moves the lower
 * bar towards center position because the lower bar will decides the
 * container's capacity. Only by moving the lower bar may we find a larger
 * container.
 * <p>
 * 
 * <p>
 *                    | 
 *    | -->           | 
 *    |  .....  ....  |
 *   left            right
 */
public class Solution {

    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int result = 0;
        while (left < right) {
            result = Math.max(Math.min(height[left], height[right]) * (right - left), result);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return result;
    }
}
```"	"array(int)[height];int
[];0
[ 5 ];0
[ 3, 2 ];2
[ 1, 2, 3, 4, 5 ];6
[ 2, 4, 3, 5, 1 ];8
[ 8, 4, 3, 2, 1 ];6
"
"Integer To Roman"	"Time : O(); Space : O()
 
Description: 
Given an integer, convert it to a roman numeral. 
Input is guaranteed to be within the range from 1 to 3999.
 
{@link https://leetcode.com/problems/integer-to-roman/ }"	"intToRoman"	"### Java
```java
public class Solution {

    public String intToRoman(int num) {
        int[] weights = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
        String[] tokens = { ""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"",
                ""IX"", ""V"", ""IV"", ""I"" };
        StringBuilder rs = new StringBuilder("""");
        int start = 0;
        while (num > 0) {
            for (int i = start; i < 13; i++) {
                if (num >= weights[i]) {
                    num -= weights[i];
                    rs.append(tokens[i]);
                    break;
                }
                start = i + 1; // skip those impossible check, make it faster
            }
        }
        return rs.toString();
    }
}
```"	"int[num];string
1;""I""
4;""IV""
9;""IX""
207;""CCVII""
1066;""MLXVI""
1954;""MCMLIV""
"
"Sum"	"Time : O(N^2); Space: O(N)
 
Description:
Given an array S of n integers, are there elements a, b, c in S such that 
a + b + c = 0? Find all unique triplets in the array which gives the sum 
of zero. 
Note: 
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c) 
The solution set must not contain duplicate triplets. 
For example, given array S = {-1 0 1 2 -1 -4}, 
A solution set is: (-1, 0, 1) (-1, -1, 2)
 
{@link https://leetcode.com/problems/3sum/ }"	"threeSum"	"### Java
```java
public class Solution {

    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        int n = nums.length;
        for (int i = 0; i < n; i++) {
            // skip duplicates
            if (i != 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // number will serve as the 1st number in triplet candidate
            int num = nums[i];
            int left = i + 1;
            int right = n - 1;
            int target = 0 - num;
            // try to find two numbers that sum up to target
            while (left < right) {
                int twoSum = nums[left] + nums[right];
                if (twoSum < target) {
                    left++;
                } else if (twoSum > target) {
                    right--;
                } else {
                    // found one combination
                    result.add(Arrays.asList(num, nums[left], nums[right]));
                    while (left + 1 < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    left++;
                    while (right - 1 > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    right--;
                }
            }
        }
        return result;
    }
}
```"	"array(int)[nums];list(list(int))
[-1, 0, 1, 2, -1, -4 ];[[-1, -1, 2], [-1, 0, 1]]
[-1, -6, -3, -7, -4, -4, 0, 3, -2, -10, -10, 9 ];[[-2, -1, 3], [-7, -2, 9], [-6, -3, 9], [-3, 0, 3]]
[5, -11, -7, -2, 4, 9, 4, 4, -5, 12, 12, -14, -5, 3, -3, -2, -6, 3, 3, -9, 4, -13, 6, 2, 11, 12, 10, -14, -15, 11, 0, 5, 8, 0, 10, -11, -6, -1, 0, 4, -4, -3, 5, -2, -15, 9, 11, -13, -2, -8, -7, 9, -6, 7, -11, 12, 4, 14, 6, -4, 3, -9, -14, -12, -2, 3, -8, 7, -13, 7, -12, -9, 11, 0, 4, 12, -6, -7, 14, -1, 0, 14, -6, 1, 6, -2, -9, -4, -11, 12, -1, -1, 10, -7, -6, -7, 11, 1, -15, 6, -15, -12, 12, 12, 3, 1, 9, 12, 9, 0, -11, -14, -1 ];[[-15, 1, 14], [-15, 3, 12], [-15, 4, 11], [-15, 5, 10], [-15, 6, 9], [-15, 7, 8], [-14, 0, 14], [-14, 2, 12], [-14, 3, 11], [-14, 4, 10], [-14, 5, 9], [-14, 6, 8], [-14, 7, 7], [-13, -1, 14], [-13, 1, 12], [-13, 2, 11], [-13, 3, 10], [-13, 4, 9], [-13, 5, 8], [-13, 6, 7], [-12, -2, 14], [-12, 0, 12], [-12, 1, 11], [-12, 2, 10], [-12, 3, 9], [-12, 4, 8], [-12, 5, 7], [-12, 6, 6], [-11, -3, 14], [-11, -1, 12], [-11, 0, 11], [-11, 1, 10], [-11, 2, 9], [-11, 3, 8], [-11, 4, 7], [-11, 5, 6], [-9, -5, 14], [-9, -3, 12], [-9, -2, 11], [-9, -1, 10], [-9, 0, 9], [-9, 1, 8], [-9, 2, 7], [-9, 3, 6], [-9, 4, 5], [-8, -6, 14], [-8, -4, 12], [-8, -3, 11], [-8, -2, 10], [-8, -1, 9], [-8, 0, 8], [-8, 1, 7], [-8, 2, 6], [-8, 3, 5], [-8, 4, 4], [-7, -7, 14], [-7, -5, 12], [-7, -4, 11], [-7, -3, 10], [-7, -2, 9], [-7, -1, 8], [-7, 0, 7], [-7, 1, 6], [-7, 2, 5], [-7, 3, 4], [-6, -6, 12], [-6, -5, 11], [-6, -4, 10], [-6, -3, 9], [-6, -2, 8], [-6, -1, 7], [-6, 0, 6], [-6, 1, 5], [-6, 2, 4], [-6, 3, 3], [-5, -5, 10], [-5, -4, 9], [-5, -3, 8], [-5, -2, 7], [-5, -1, 6], [-5, 0, 5], [-5, 1, 4], [-5, 2, 3], [-4, -4, 8], [-4, -3, 7], [-4, -2, 6], [-4, -1, 5], [-4, 0, 4], [-4, 1, 3], [-3, -3, 6], [-3, -2, 5], [-3, -1, 4], [-3, 0, 3], [-3, 1, 2], [-2, -2, 4], [-2, -1, 3], [-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1], [0, 0, 0]]
[7, -1, 14, -12, -8, 7, 2, -15, 8, 8, -8, -14, -4, -5, 7, 9, 11, -4, -15, -6, 1, -14, 4, 3, 10, -5, 2, 1, 6, 11, 2, -2, -5, -7, -6, 2, -15, 11, -6, 8, -4, 2, 1, -1, 4, -6, -15, 1, 5, -15, 10, 14, 9, -8, -6, 4, -6, 11, 12, -15, 7, -1, -9, 9, -1, 0, -4, -1, -12, -2, 14, -9, 7, 0, -3, -4, 1, -2, 12, 14, -10, 0, 5, 14, -1, 14, 3, 8, 10, -8, 8, -5, -2, 6, -11, 12, 13, -7, -12, 8, 6, -13, 14, -2, -5, -11, 1, 3, -6 ];[[-15, 1, 14], [-15, 2, 13], [-15, 3, 12], [-15, 4, 11], [-15, 5, 10], [-15, 6, 9], [-15, 7, 8], [-14, 0, 14], [-14, 1, 13], [-14, 2, 12], [-14, 3, 11], [-14, 4, 10], [-14, 5, 9], [-14, 6, 8], [-14, 7, 7], [-13, -1, 14], [-13, 0, 13], [-13, 1, 12], [-13, 2, 11], [-13, 3, 10], [-13, 4, 9], [-13, 5, 8], [-13, 6, 7], [-12, -2, 14], [-12, -1, 13], [-12, 0, 12], [-12, 1, 11], [-12, 2, 10], [-12, 3, 9], [-12, 4, 8], [-12, 5, 7], [-12, 6, 6], [-11, -3, 14], [-11, -2, 13], [-11, -1, 12], [-11, 0, 11], [-11, 1, 10], [-11, 2, 9], [-11, 3, 8], [-11, 4, 7], [-11, 5, 6], [-10, -4, 14], [-10, -3, 13], [-10, -2, 12], [-10, -1, 11], [-10, 0, 10], [-10, 1, 9], [-10, 2, 8], [-10, 3, 7], [-10, 4, 6], [-10, 5, 5], [-9, -5, 14], [-9, -4, 13], [-9, -3, 12], [-9, -2, 11], [-9, -1, 10], [-9, 0, 9], [-9, 1, 8], [-9, 2, 7], [-9, 3, 6], [-9, 4, 5], [-8, -6, 14], [-8, -5, 13], [-8, -4, 12], [-8, -3, 11], [-8, -2, 10], [-8, -1, 9], [-8, 0, 8], [-8, 1, 7], [-8, 2, 6], [-8, 3, 5], [-8, 4, 4], [-7, -7, 14], [-7, -6, 13], [-7, -5, 12], [-7, -4, 11], [-7, -3, 10], [-7, -2, 9], [-7, -1, 8], [-7, 0, 7], [-7, 1, 6], [-7, 2, 5], [-7, 3, 4], [-6, -6, 12], [-6, -5, 11], [-6, -4, 10], [-6, -3, 9], [-6, -2, 8], [-6, -1, 7], [-6, 0, 6], [-6, 1, 5], [-6, 2, 4], [-6, 3, 3], [-5, -5, 10], [-5, -4, 9], [-5, -3, 8], [-5, -2, 7], [-5, -1, 6], [-5, 0, 5], [-5, 1, 4], [-5, 2, 3], [-4, -4, 8], [-4, -3, 7], [-4, -2, 6], [-4, -1, 5], [-4, 0, 4], [-4, 1, 3], [-4, 2, 2], [-3, -2, 5], [-3, -1, 4], [-3, 0, 3], [-3, 1, 2], [-2, -2, 4], [-2, -1, 3], [-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1], [0, 0, 0]]
"
"Sum Closest"	"Time : O(N^2); Space: O(N)
 
Description: 
Given an array S of n integers, find three integers in S such that the 
sum is closest to a given number, target. Return the sum of the three 
integers. You may assume that each input would have exactly one solution. 
For example, given array S = {-1 2 1 -4}, and target = 1. 
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
 
{@link https://leetcode.com/problems/3sum-closest/ }"	"threeSumClosest"	"### Java
```java
public class Solution {

    public int threeSumClosest(int[] nums, int target) {
        int result = target;
        int len = nums.length;
        if (len < 3) {
            return 0;
        }
        Arrays.sort(nums);
        for (int i = 0; i < len; i++) {
            int number = nums[i];

            int leftIndex = i + 1;
            int rightIndex = len - 1;
            while (leftIndex < rightIndex) {
                int threeSum = number + nums[leftIndex] + nums[rightIndex];
                if (threeSum == target) {
                    // best result found!
                    return target;
                } else {
                    // update global result
                    if (result == target
                            || Math.abs(target - threeSum) < Math.abs(target - result)) {
                        result = threeSum;
                    }
                    if (threeSum < target) {
                        while (leftIndex < rightIndex
                                && nums[leftIndex] == nums[leftIndex + 1]) {
                            leftIndex++;
                        }
                        leftIndex++;
                    } else {
                        while (leftIndex < rightIndex
                                && nums[rightIndex] == nums[rightIndex - 1]) {
                            rightIndex--;
                        }
                        rightIndex--;
                    }
                }
            }
        }
        return result;
    }
}
```"	"array(int)[nums];int[target];int
[-1, 2, 1, -4];1;2
[-1, 2, 1, -4];2;2
[43, 75, -90, 47, -49, 72, 17, -31, -68, -22, -21, -30, 65, 88, -75, 23, 97, -61, 53, 87, -3, 33, 20, 51, -79, 43, 80, -9, 34, -89, -7, 93, 43, 55, -94, 29, -32, -49, 25, 72, -6, 35, 53, 63, 6, -62, -96, -83, -73, 66, -11, 96, -90, -27, 78, -51, 79, 35, -63, 85, -82, -15, 100, -82, 1, -4, -41, -21, 11, 12, 12, 72, -82, -22, 37, 47, -18, 61, 60, 55, 22, -6, 26, -60, -42, -92, 68, 45, -1, -26, 5, -56, -1, 73, 92, -55, -20, -43, -56, -15, 7, 52, 35, -90, 63, 41, -55, -58, 46, -84, -92, 17, -66, -23, 96, -19, -44, 77, 67, -47, -48, 99, 51, -25, 19, 0, -13, -88, -10, -67, 14, 7, 89, -69, -83, 86, -70, -66, -38, -50, 66, 0, -67, -91, -65, 83, 42, 70, -6, 52, -21, -86, -87, -44, 8, 49, -76, 86, -3, 87, -32, 81, -58, 37, -55, 19, -26, 66, -89, -70, -69, 37, 0, 19, -65, 38, 7, 3, 1, -96, 96, -65, -52, 66, 5, -3, -87, -16, -96, 57, -74, 91, 46, -79, 0, -69, 55, 49, -96, 80, 83, 73, 56, 22, 58, -44, -40, -45, 95, 99, -97, -22, -33, -92, -51, 62, 20, 70, 90];284;284
[-3, -2, -5, 3, -4];-1;-2
"
"Letter Combinations Of A Phone Number"	"Time : O(); Space: O()
 
Description: 
Given a digit string, return all possible letter combinations that the 
number could represent. 
A mapping of digit to letters (just like on the telephone buttons) 
is given below.
Input:Digit string ""23"" 
Output: [""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""]. 
Note: 
Although the above answer is in lexicographical order, your answer 
could be in any order you want.
 
{@link https://leetcode.com/problems/letter-combinations-of-a-phone-number/ }"	"letterCombinations"	"### Java
```java
public class Solution {

    public static final String[] mapping = { """", """", ""abc"", ""def"", ""ghi"",
            ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz"" };

    // iterative, BFS version
    public List<String> letterCombinations(String digits) {
        List<String> cur = new ArrayList<String>();
        if (digits.length() == 0) {
            return cur;
        }
        cur.add("""");
        for (int i = 0; i < digits.length(); i++) {
            String strs = mapping[digits.charAt(i) - '0'];
            List<String> next = new ArrayList<>();
            for (int j = 0; j < strs.length(); j++) {
                char ch = strs.charAt(j);
                // try to insert 'ch' to each current combination
                for (String comb : cur) {
                    next.add(comb + ch);
                }
            }
            cur = next;
        }
        return cur;
    }
}
```"	"string[digits];list(string)
""23"";[""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
"""";[]
""9"";[""w"",""x"",""y"",""z""]
""234"";[""adg"",""adh"",""adi"",""aeg"",""aeh"",""aei"",""afg"",""afh"",""afi"",""bdg"",""bdh"",""bdi"",""beg"",""beh"",""bei"",""bfg"",""bfh"",""bfi"",""cdg"",""cdh"",""cdi"",""ceg"",""ceh"",""cei"",""cfg"",""cfh"",""cfi""]
"
"Sum"	"Time : O(N^3); Space: O(N^2)
 
Description: 
Given an array S of n integers, are there elements a, b, c, and d in S 
such that a + b + c + d = target? Find all unique quadruplets in the 
array which gives the sum of target. 
Note: 
Elements in a quadruplet (a,b,c,d) must be in non-descending order. 
(ie, a ≤ b ≤ c ≤ d) 
The solution set must not contain duplicate quadruplets. 
For example, given array S = {1 0 -1 0 -2 2}, and target = 0. 
A solution set is: (-1,  0, 0, 1) (-2, -1, 1, 2) (-2,  0, 0, 2)
 
{@link https://leetcode.com/problems/4sum/ }"	"fourSum"	"### Java
```java
public class Solution {

    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        int len = nums.length;
        if (len < 4) {
            // not enough numbers
            return result;
        }

        Arrays.sort(nums);

        // for each number that can be the 1st number of quadruplet
        for (int i = 0; i < len - 3; i++) {
            int firstNumber = nums[i];
            // skip to next possible first number
            if (i == 0 || firstNumber != nums[i - 1]) {
                for (int j = i + 1; j < len - 2; j++) {
                    // skip duplicates
                    int secondNumber = nums[j];
                    if (j == i + 1 || secondNumber != nums[j - 1]) {
                        int twoSumTarget = target - firstNumber - secondNumber;
                        int leftIndex = j + 1;
                        int rightIndex = len - 1;
                        while (leftIndex < rightIndex) {
                            int twoSum = nums[leftIndex] + nums[rightIndex];
                            if (twoSum == twoSumTarget) {
                                // found one !
                                result.add(Arrays.asList(firstNumber,
                                        secondNumber, nums[leftIndex],
                                        nums[rightIndex]));
                                // jump duplicates from left to right
                                while (leftIndex < rightIndex
                                        && nums[leftIndex] == nums[leftIndex + 1]) {
                                    leftIndex++;
                                }
                                // skip duplicates from right to left
                                while (leftIndex < rightIndex
                                        && nums[rightIndex] == nums[rightIndex - 1]) {
                                    rightIndex--;
                                }
                                leftIndex++;
                                rightIndex--;
                            } else if (twoSum < twoSumTarget) {
                                leftIndex++;
                            } else {
                                rightIndex--;
                            }
                        }
                    }
                }
            }
        }
        return result;

    }
}
```"	"array(int)[nums];int[target];list(list(int))
[ 1, 0, -1, 0, -2, 2 ];0;[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]
[ 1, -2, -5, -4, -3, 3, 3, 5 ];-11;[[-5, -4, -3, 1]]
"
"Generate Parentheses"	"Time : O(N^4); Space: O(N)
 
Description: 
Given n pairs of parentheses, write a function to generate all 
combinations of well-formed parentheses. 
For example, given n = 3, a solution set is: 
""((()))"", ""(()())"", ""(())()"", ""()(())"", ""()()()""
 
{@link https://leetcode.com/problems/generate-parentheses/ }"	"generateParenthesis"	"### Java
```java
public class Solution {

    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<String>();
        int leftsUsed = 0;
        int rightsUsed = 0;
        String prefix = """";
        generateParenthesis(n, leftsUsed, rightsUsed, prefix, result);
        return result;
    }

    private void generateParenthesis(int n, int leftsUsed, int rightsUsed,
            String prefix, List<String> result) {
        // base case
        if (leftsUsed == n && rightsUsed == n) {
            // one combination found!
            result.add(prefix);
            return;
        }
        // recursive case
        if (leftsUsed == rightsUsed) {
            // next must be '(""
            generateParenthesis(n, leftsUsed + 1, rightsUsed, prefix + ""("", result);
        } else {
            // can either be ""("" or "")""
            if (leftsUsed < n) {
                // still has ""("" left for use
                generateParenthesis(n, leftsUsed + 1, rightsUsed, prefix + ""("", result);
            }
            if (rightsUsed < n) {
                generateParenthesis(n, leftsUsed, rightsUsed + 1, prefix + "")"", result);
            }
        }
    }
}
```"	"int[n];list(string)
0;[""""]
1;[""()""]
2;[""()()"", ""(())""]
3;[""((()))"", ""(()())"", ""(())()"", ""()(())"", ""()()()""]
"
"Swap Nodes In Pairs"	"Time : O() ; Space: O()
 
Description:
Given a linked list, swap every two adjacent nodes and return its head. 
For example, Given 1->2->3->4, you should return the list as 2->1->4->3. 
Your algorithm should use only constant space. You may not modify the 
values in the list, only nodes itself can be changed.
 
{@link https://leetcode.com/problems/swap-nodes-in-pairs/ }"	"swapPairs"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {
    public ListNode<Integer> swapPairs(ListNode<Integer> head) {
        ListNode<Integer> dummy = new ListNode();
        dummy.next = head;

        ListNode<Integer> pre = dummy;
        ListNode<Integer> cur = pre.next;
        while (cur != null && cur.next != null) {
            ListNode post = cur.next.next;

            // swap cur and cur.next
            pre.next = cur.next;
            cur.next.next = cur;
            cur.next = post;

            pre = pre.next.next;
            cur = post;
        }
        return dummy.next;
    }
}
```"	"linked_list(int)[head];linked_list(int)
[1,1,2,2,3,3,4];[2,1,4,3]
[1,1,2,2,3];[2,1,3]
[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10];[2,1,4,3,6,5,8,7,10,9]
"
"Divide Two Integers"	"Time : O(N); Space: O(1)
 
Description: 
Divide two integers without using multiplication, division and mod operator. 
If it is overflow, return MAX_INT.
 
{@link https://leetcode.com/problems/divide-two-integers/ }"	"divide"	"### Java
```java
public class Solution {

    public int divide(int dividend, int divisor) {
        if (divisor == 1) {
            return dividend;
        }
        if (dividend == Integer.MIN_VALUE && Math.abs(divisor) == 1) {
            return Integer.MAX_VALUE;
        }

        int sign = (dividend > 0 ^ divisor > 0) ? -1 : 1;

        long ans = 0;
        long end = Math.abs((long) dividend);
        long sor = Math.abs((long) divisor);

        while (end >= sor) {
            long temp = sor;
            long power = 1;
            while ((temp << 1) < end) {
                power <<= 1;
                temp <<= 1;
            }
            ans += power;
            end -= temp;

        }
        return (int) (sign * ans);
    }
}
```"	"int[dividend];int[divisor];int
8;4;2
4;8;0
9;4;2
0;4;0
5;-2;-2
-2147483648;-1;2147483647
-2147483648;1;-2147483648
-2147483648;2;-1073741824
"
"Next Permutation"	"Time : O(N); Space: O(1)
 
Description: 
 
Implement the next permutation, which rearranges numbers into the 
numerically next greater permutation of numbers. 
If such arrangement is not possible, it must be rearranged as the 
lowest possible order ie, sorted in an ascending order. 
The replacement must be in-place, do not allocate extra memory. 
Examples: 
 1,2,3 → 1,3,2 
 3,2,1 → 1,2,3 
 1,1,5 → 1,5,1 
 20, 50, 113 → 20, 113, 50 
 
Inputs are in the left-hand column and its corresponding 
outputs are in the right-hand column.
 
 
{@link https://leetcode.com/problems/next-permutation/ }"	"nextPermutation"	"### Java
```java
public class Solution {
    public int[] nextPermutation(int[] input) {
        int[] nums = new int[input.length];
        System.arraycopy(input, 0, nums, 0, nums.length);
        int start = nums.length - 1;
        while (start > 0 && nums[start - 1] >= nums[start]) {
            start--;
        }
        if (start > 0) {
            int end = nums.length - 1;
            while (nums[end] <= nums[start - 1]) {
                end--;
            }
            swap(nums, start - 1, end);
        }

        for (int i = start; i < (start + nums.length) / 2; i++) {
            swap(nums, i, nums.length - 1 + start - i);
        }
        return nums;
    }

    void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```"	"array(int)[input];array(int)
[ 1, 2, 3 ];[ 1, 3, 2 ]
[ 3, 2, 1 ];[ 1, 2, 3 ]
[ 1, 1, 5 ];[ 1, 5, 1 ]
[ 20, 50, 113 ];[20, 113, 50]
[444, 994, 508, 72, 125, 299, 181, 238, 354, 223, 691, 249, 838, 890, 758, 675, 424, 199, 201, 788, 609, 582, 979, 259, 901, 371, 766, 759, 983, 728, 220, 16, 158, 822, 515, 488, 846, 321, 908, 469, 84, 460, 961, 285, 417, 142, 952, 626, 916, 247, 116, 975, 202, 734, 128, 312, 499, 274, 213, 208, 472, 265, 315, 335, 205, 784, 708, 681, 160, 448, 365, 165, 190, 693, 606, 226, 351, 241, 526, 311, 164, 98, 422, 363, 103, 747, 507, 669, 153, 856, 701, 319, 695, 52];[444, 994, 508, 72, 125, 299, 181, 238, 354, 223, 691, 249, 838, 890, 758, 675, 424, 199, 201, 788, 609, 582, 979, 259, 901, 371, 766, 759, 983, 728, 220, 16, 158, 822, 515, 488, 846, 321, 908, 469, 84, 460, 961, 285, 417, 142, 952, 626, 916, 247, 116, 975, 202, 734, 128, 312, 499, 274, 213, 208, 472, 265, 315, 335, 205, 784, 708, 681, 160, 448, 365, 165, 190, 693, 606, 226, 351, 241, 526, 311, 164, 98, 422, 363, 103, 747, 507, 669, 153, 856, 701, 695, 52, 319]
[2, 3, 1];[3, 1, 2]
[3, 4, 2, 1];[4, 1, 2, 3]
[626, 436, 819, 100, 382, 173, 817, 581, 220, 95, 814, 660, 397, 852, 15, 532, 564, 715, 179, 872, 236, 790, 223, 379, 83, 924, 454, 846, 742, 730, 689, 112, 110, 516, 85, 149, 228, 202, 988, 212, 69, 602, 887, 445, 327, 527, 347, 906, 54, 460, 517, 376, 395, 494, 827, 448, 919, 799, 133, 879, 709, 184, 812, 514, 976, 700, 156, 568, 453, 267, 547, 8, 951, 326, 652, 772, 213, 714, 706, 972, 318, 768, 506, 59, 854, 422];[626, 436, 819, 100, 382, 173, 817, 581, 220, 95, 814, 660, 397, 852, 15, 532, 564, 715, 179, 872, 236, 790, 223, 379, 83, 924, 454, 846, 742, 730, 689, 112, 110, 516, 85, 149, 228, 202, 988, 212, 69, 602, 887, 445, 327, 527, 347, 906, 54, 460, 517, 376, 395, 494, 827, 448, 919, 799, 133, 879, 709, 184, 812, 514, 976, 700, 156, 568, 453, 267, 547, 8, 951, 326, 652, 772, 213, 714, 706, 972, 318, 768, 506, 422, 59, 854]
[2, 4, 3, 1];[3, 1, 2, 4]
"
"Search For A Range"	"Time : O(lgN); Space: O(N)
 
Description: 
Given a sorted array of integers, find the starting and ending position 
of a given target value. 
Your algorithm's runtime complexity must be in the order of O(log n). 
If the target is not found in the array, return [-1, -1]. 
For example, 
Given [5, 7, 7, 8, 8, 10] and target value 8, 
return [3, 4].
 
{@link https://leetcode.com/problems/search-for-a-range/ }"	"searchRange"	"### Java
```java
public class Solution {

    public int[] searchRange(int[] nums, int target) {
        int[] result = { -1, -1 };
        int len = nums.length;
        if (len == 0) {
            return result;
        }
        int start = -1;
        // use binary search to find the left bound of range
        int left = 0;
        int right = len - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = nums[mid];
            if (midVal == target && (mid == 0 || nums[mid - 1] < target)) {
                // left bound should have the same value as target and 
                // the value to its left (if exists) is smaller than left bound's value
                start = mid;
                result[0] = start;
                break;
            } else if (midVal < target) {
                left = mid + 1;
            } else {
                // (midVal > target || nums[mid - 1] == target)
                right = mid - 1;
            }
        }
        if (start == -1) {
            return result;
        }

        // use binary search to find the right bound of range
        left = start;
        right = len - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = nums[mid];
            if (midVal == target && (mid == len - 1 || nums[mid + 1] > target)) {
                // mid + 1 is the right bound
                result[1] = mid;
                return result;
            } else if (midVal > target) {
                right = mid - 1;
            } else {
                // there are still elements on the right side that has
                // target value
                left = mid + 1;
            }
        }
        return result;
    }
}
```"	"array(int)[nums];int[target];array(int)
[5, 7, 7, 8, 8, 10];8;[3, 4]
[5, 7, 7, 8, 8, 10];5;[0, 0]
[5, 7, 7, 8, 8, 10];10;[5, 5]
[5, 7, 7, 8, 8, 10];3;[-1, -1]
[5, 7, 7, 8, 8, 10];6;[-1, -1]
[5, 7, 7, 8, 8, 10];12;[-1, -1]
[5, 7, 7, 8, 8, 10, 10, 10];10;[5, 7]
[5, 5, 5, 7, 7, 8, 8, 10, 10, 10];5;[0, 2]
[5, 7, 8, 8, 8, 8, 10, 10];8;[2, 5]

"
"Search Insert Position"	"Time : O(lgN); Space: O(1)
 
Description: 
Given a sorted array and a target value, return the index if the target 
is found. If not, return the index where it would be if it were 
inserted in order. 
You may assume no duplicates in the array. 
Here are few examples. 
 [1,3,5,6], 5 → 2 
 [1,3,5,6], 2 → 1 
 [1,3,5,6], 7 → 4 
 [1,3,5,6], 0 → 0
 
{@link https://leetcode.com/problems/search-insert-position/ }"	"searchInsert"	"### Java
```java
/** 
 * We can consider the scenario that nums only has one element, (i.e. both
 * left and right pointers are pointing to the same position)
 * 
 */
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // insert at mid
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }

        }
        return left;
    }
}
```"	"array(int)[nums];int[target];int
[1, 3, 5, 6];5;2
[1, 3, 5, 6];2;1
[1, 3, 5, 6];7;4
[1, 3, 5, 6];0;0
[1];0;0
[1];1;0
[1];2;1
"
"Combination Sum"	"Time : O(N^2); Space: O(N^2)
 
Description: 
Given a set of candidate numbers (C) and a target number (T), find all 
unique combinations in C where the candidate numbers sums to T. 
The same repeated number may be chosen from C unlimited number of times. 
Note: All numbers (including target) will be positive integers. 
Elements in a combination (a1, a2, … , ak) must be in non-descending 
order. (ie, a1 ≤ a2 ≤ … ≤ ak). 
The solution set must not contain duplicate combinations. 
For example, given candidate set 2,3,6,7 and target 7, 
A solution set is: 
 [7] 
 [2, 2, 3] 
 
 
{@link https://leetcode.com/problems/combination-sum/ }"	"combinationSum"	"### Java
```java
public class Solution {

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<List<Integer>>();
        Arrays.sort(candidates);
        int index = 0;
        recurse(new ArrayList<Integer>(), target, candidates, index, res);
        return res;
    }

    private void recurse(List<Integer> combination, int target,
            int[] nums, int index, List<List<Integer>> result) {
        // base case
        if (target == 0) {
            // found one valid combination
            result.add(new ArrayList<>(combination));
        }

        // recursive case
        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            if(target - num < 0) {
                // no need to check later siblings
                break;
            }
            combination.add(num);
            recurse(combination, target - num, nums, i, result);
            combination.remove(combination.size() - 1);
        }
    }
}
```"	"array(int)[candidates];int[target];list(list(int))
[2, 3, 6, 7];7;[[2,2,3],[7]]
[2];2;[[2]]
[3];2;[]
[2, 3, 4, 6, 7];10;[[2, 2, 2, 2, 2], [2, 2, 2, 4], [2, 2, 3, 3], [2, 2, 6], [2, 4, 4], [3, 3, 4], [3, 7], [4, 6]]
"
"Combination Sum I I"	"Time : O(N^2); Space: O(N^2)
 
Description: 
Given a collection of candidate numbers (C) and a target number (T), 
find all unique combinations in C where the candidate numbers sums to T. 
Each number in C may only be used once in the combination. 
Note: 
All numbers (including target) will be positive integers. 
Elements in a combination (a1, a2, … , ak) must be in non-descending 
order. (ie, a1 ≤ a2 ≤ … ≤ ak). 
The solution set must not contain duplicate combinations. 
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: [1, 7] [1, 2, 5] [2, 6] [1, 1, 6] 
 
{@link https://leetcode.com/problems/combination-sum-ii/ }"	"combinationSum2"	"### Java
```java
public class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        List<Integer> combination = new ArrayList<Integer>();
        Arrays.sort(candidates);
        int index = 0;
        combinationSum2(candidates, target, index, combination, result);
        return result;
    }

    private void combinationSum2(int[] nums, int target, int index,
            List<Integer> combination, List<List<Integer>> result) {
        // base case
        if (target == 0) {
            // found one valid combination
            result.add(combination);
        }

        // recursive case
        // try each number as the next number put into combination
        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            if (i != index && num == nums[i - 1]) {
                // skip duplicate at the same position of resulting combination
                continue;
            }
            if (target - num < 0) {
                // prune: no need to try larger number in candidates
                // to put in current combination
                // no need to check later siblings
                break;
            }
            List<Integer> copy = new ArrayList<Integer>(combination);
            copy.add(num);
            combinationSum2(nums, target - num, i + 1, copy, result);
        }
    }
}
```"	"array(int)[candidates];int[target];list(list(int))
[10, 1, 2, 7, 6, 1, 5];8;[[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]
[2, 3, 6, 7];7;[[7]]
[3, 1, 3, 5, 1, 1];8;[[1, 1, 1, 5], [1, 1, 3, 3], [3, 5]]
"
"Multiply Strings"	"Time : O(NM); Space: O(N + M)
 
Description: 
Given two numbers represented as strings, return multiplication of
the numbers as a string. 
Note: The numbers can be arbitrarily large and are non-negative.
 
{@link https://leetcode.com/problems/multiply-strings/ }"	"multiply"	"### Java
```java
public class Solution {
    
    public String multiply(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int[] product = new int[num1.length() + num2.length()];
        for (int i = num1.length() - 1; i >= 0; i--) {
            int carry = 0;
            int j = num2.length() - 1;
            int index = i + j + 1;  // index where stores current result
            while (j >= 0 || carry != 0) {
                int n1 = j >= 0 ? num2.charAt(j--) - '0' : 0;
                int n2 = i >= 0 ? num1.charAt(i) - '0' : 0;
                int multi = n1 * n2 + carry + product[index];
                carry = multi / 10;
                product[index--] = multi % 10;
            }
        }
        boolean obvious = false; // first non-zero digit
        for (int i = 0; i < product.length; i++) {
            if (product[i] == 0 && !obvious) {
                continue;
            }
            obvious = true;
            sb.append(product[i]);
        }
        return sb.length() == 0 ? ""0"" : sb.toString();
    }

    // version2: need a reverse at the end
    public String multiply_reverse(String num1, String num2) {
        int len1 = num1.length();
        int len2 = num2.length();
        int[] product = new int[len1 + len2];
        for (int i = len1 - 1; i >= 0; i--) {
            for (int j = len2 - 1; j >= 0; j--) {
                int index = len1 + len2 - i - j - 2;
                product[index] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                product[index + 1] += product[index] / 10;
                product[index] %= 10;
            }
        }
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = product.length - 1; i > 0; i--) {
            if (stringBuilder.length() == 0 && product[i] == 0)
                continue;
            stringBuilder.append(product[i]);
        }
        stringBuilder.append(product[0]);
        return stringBuilder.toString();
    }
}
```"	"string[num1];string[num2];string
""1"";""0"";""0""
""2"";""1"";""2""
""100000"";""200000"";""20000000000""
""15"";""15"";""225""
""30000"";""40000"";""1200000000""
""93553535314"";""25247452591474"";""2361988447605003674312836""
"
"Permutations"	"Time : O(N!); Space: O(N!)
 
Description: 
Given a collection of numbers, return all possible permutations. 
For example, [1,2,3] have the following permutations: 
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
 
 
{@link https://leetcode.com/problems/permutations/ }"	"permute"	"### Java
```java
public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (nums.length == 0) {
            return result;
        }
        // put the seed set into result
        result.add(new ArrayList<>(Arrays.asList(nums[0])));
        for (int i = 1; i < nums.length; i++) {
            int num = nums[i];
            List<List<Integer>> next = new ArrayList<>();
            // try to insert num into each existing sets in result
            for (int j = 0; j <= i; j++) {
                // insert num[i] at position j of each existing set
                for (List<Integer> list : result) {
                    // create new copy of list is faster than operation on
                    // the same code
                    List<Integer> expanding = new ArrayList<>(list);
                    expanding.add(j, num);
                    next.add(expanding);
                    
                    //slow version: because list.remove() is O(N)
//                    list.add(j, num);
//                    next.add(list);
//                    list.remove(j);
                }
            }
            result = next;
        }
        return result;
    }
}
```"	"array(int)[nums];list(list(int))
[];[]
[1, 2, 3];[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
[1];[[1]]
[1, 2];[[1, 2], [2, 1]]
[4, 5, 6, 7];[[4, 5, 6, 7], [4, 5, 7, 6], [4, 6, 5, 7], [4, 6, 7, 5], [4, 7, 5, 6], [4, 7, 6, 5], [5, 4, 6, 7], [5, 4, 7, 6], [5, 6, 4, 7], [5, 6, 7, 4], [5, 7, 4, 6], [5, 7, 6, 4], [6, 4, 5, 7], [6, 4, 7, 5], [6, 5, 4, 7], [6, 5, 7, 4], [6, 7, 4, 5], [6, 7, 5, 4], [7, 4, 5, 6], [7, 4, 6, 5], [7, 5, 4, 6], [7, 5, 6, 4], [7, 6, 4, 5], [7, 6, 5, 4]]
"
"Rotate Image"	"Time : O(N^2); Space: O(N^2)
 
Description: 
You are given an n x n 2D matrix representing an image. 
Rotate the image by 90 degrees (clockwise). 
Follow up: Could you do this in-place?
 
{@link https://leetcode.com/problems/rotate-image/ }"	"rotate"	"### Java
```java
public class Solution {

    /*
     *  1  2  3  4               13  9  5 1               13  9 5 1    
     *  5  6  7  8  outer loop   14  6  7 2  inner loop   14 10 6 2 
     *  9 10 11 12 ============> 15 10 11 3 ============> 15 11 7 3 
     * 13 14 15 16               16 12  8 4               16 12 8 4
     */
    public int[][] rotate(int[][] matrix) {
        int n = matrix.length;
        if (n == 0) {
            return matrix;
        }
        int half = n / 2;
        // for each loop
        for (int i = 0; i < half; i++) {
            int startIndex = i;
            int endIndex = startIndex + (n - 2 * i) - 1;
            // in one row, we leave the last number unchanged
            // so it is j < endIndex, not j <= endIndex
            for (int offset = 0; startIndex + offset < endIndex; offset++) {
                // number in the first row
                int temp1 = matrix[startIndex][startIndex + offset];
                // number in the last column
                int temp2 = matrix[startIndex + offset][endIndex];
                // number in the last row
                int temp3 = matrix[endIndex][endIndex - offset];
                // number in the first column
                int temp4 = matrix[endIndex - offset][startIndex];

                matrix[startIndex][startIndex + offset] = temp4;
                matrix[startIndex + offset][endIndex] = temp1;
                matrix[endIndex][endIndex - offset] = temp2;
                matrix[endIndex - offset][startIndex] = temp3;

            }
        }
        return matrix;

    }

    public void printMatrix(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + "" "");
            }
            System.out.print(""\n"");
        }
    }
}
```"	"array(array(int))[matrix];array(array(int))
[[1, 2, 3], [4, 5, 6], [7, 8, 9]];[[7, 4, 1], [8, 5, 2], [9, 6, 3]]
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]];[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]];[[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]
[[2, 29, 20, 26, 16, 28], [12, 27, 9, 25, 13, 21], [32, 33, 32, 2, 28, 14], [13, 14, 32, 27, 22, 26], [33, 1, 20, 7, 21, 7], [4, 24, 1, 6, 32, 34]];[[4, 33, 13, 32, 12, 2], [24, 1, 14, 33, 27, 29], [1, 20, 32, 32, 9, 20], [6, 7, 27, 2, 25, 26], [32, 21, 22, 28, 13, 16], [34, 7, 26, 14, 21, 28]]
"
"Group Anagrams"	"Time : O(mnlg(mn)); Space: O()
 
Description: 
Note: 
For the return value, each inner list's elements must follow the lexicographic order. 
All inputs will be in lower-case.
 
{@link https://leetcode.com/problems/anagrams/ }"	"groupAnagrams"	"### Java
```java
public class Solution {

    /**
     * For each string, sort it alphabetically, and then check whether this
     * sorted string has appeared in map.
     */
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> result = new ArrayList<>();
        // <sorted string, index of list in result list>
        Map<String, Integer> anagrams = new HashMap<>();
        Arrays.sort(strs);
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String sorted = new String(chars);
            if (!anagrams.containsKey(sorted)) {
                anagrams.put(sorted, result.size());
                result.add(new ArrayList<>());
            }
            result.get(anagrams.get(sorted)).add(str);
        }
        return result;
    }
    
    
    // version 2: larger map, not as space efficient as version1
    public List<List<String>> groupAnagrams2(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        Arrays.sort(strs);
        // <sorted array, list of anagrams>
        Map<String, List<String>> anagrams = new HashMap<>();
        for (String s : strs) {
            char[] str = s.toCharArray();
            Arrays.sort(str);
            String anagram = new String(str);
            if (!anagrams.containsKey(anagram)) {
                anagrams.put(anagram, new LinkedList<>());
            }
            anagrams.get(anagram).add(s);
        }
        for (List<String> list : anagrams.values()) {
            res.add(list);
        }
        return res;
    }
}
```"	"array(string)[strs];list(list(string))
[""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""];[[""ate"", ""eat"",""tea""], [""nat"", ""tan""], [""bat""]]
[ """", """"];[["""", """"]]
[ ""ant"", ""ant""];[[""ant"", ""ant""]]
[ """", """", """"];[["""", """", """"]]
"
"Powx N"	"Time : O(logN); Space: O(1)
 
Description: 
Implement pow(x, n).
 
{@link https://leetcode.com/problems/powx-n/ }
P.S. : 1. deal with StackOverflow
       2. bit operation to judge for odd or even number"	"myPow"	"### Java
```java
public class Solution {

    public double myPow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return x;
        }
        // local cache
        double result = myPow(x, n / 2);
        result *= result;
        if ((n & 0x1) == 1) {
            // if n is odd number: only if last bit in n is 1, n & 0x1 can be 1
            // pay attention to negative n
            result *= n > 0 ? x : (1 / x);
        }
        return result;
    }
}
```"	"float[x];int[n];float
20;3;8000
8.88023;3;700.28148
8;3;512
1.00000;-2147483648;1
-1.00000;-2147483648;1
"
"Maximum Subarray"	"Time : O(); Space: O()
 
Description: 
Find the contiguous subarray within an array (containing at least one 
number) which has the largest sum. 
For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6. 
More practice: 
If you have figured out the O(n) solution, try coding another solution 
using the divide and conquer approach, which is more subtle.
 
{@link https://leetcode.com/problems/maximum-subarray/ }"	"maxSubArray"	"### Java
```java
public class Solution {

    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int result = nums[0];
        int contiguous = result;
        for (int i = 1; i < nums.length; i++) {
            int number = nums[i];
            if (contiguous < 0) {
                contiguous = number;
            } else {
                contiguous += number;
            }
            result = Math.max(result, contiguous);
        }
        return result;
    }
}
```"	"array(int)[nums];int
[ -2, 1, -3, 4, -1, 2, 1, -5, 4 ];6
[ 3, 2, 1 ];6
[ -3, -2, -1 ];-1
[ -3, 2, -2 ];2
"
"Spiral Matrix"	"Time : O(); Space: O()
 
Description: 
Given a matrix of m x n elements (m rows, n columns), return all 
elements of the matrix in spiral order. 
For example, 
Given the following matrix: 
[ 
 [ 1, 2, 3 ], 
 [ 4, 5, 6 ], 
 [ 7, 8, 9 ] 
] 
You should return [1,2,3,6,9,8,7,4,5].
 
 
{@link https://leetcode.com/problems/spiral-matrix/ }
P.S. : how to terminate for half rows of matrix (including the middle row)
! index of middle row  =  (rows - 1) / 2"	"spiralOrder"	"### Java
```java
public class Solution {

    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<Integer>();
        int rows = matrix.length;
        if (rows == 0) {
            return result;
        }
        int cols = matrix[0].length;
        // loop including the middle row in matrix
        for (int i = 0; i <= (rows - 1) / 2; i++) {
            int rowStart = i;
            int colStart = i;
            int colEnd = cols - i - 1;
            int rowEnd = rows - i - 1;
            // top row
            for (int j = colStart; j <= colEnd; j++) {
                result.add(matrix[rowStart][j]);
            }
            // right column
            if (colEnd >= 0 && colEnd < cols && colEnd >= colStart) {
                for (int j = rowStart + 1; j <= rowEnd; j++) {
                    result.add(matrix[j][colEnd]);
                }
            }
            // bottom row, skip if same as top row
            if (rowEnd > rowStart) {
                for (int j = colEnd - 1; j >= colStart; j--) {
                    result.add(matrix[rowEnd][j]);
                }
            }
            // left column, skip if same as right column
            if (colStart < colEnd) {
                for (int j = rowEnd - 1; j >= rowStart + 1; j--) {
                    result.add(matrix[j][colStart]);
                }
            }
        }
        return result;
    }
}
```"	"array(array(int))[matrix];list(int)
[[ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]];[1, 2, 3, 6, 9, 8, 7, 4, 5]
[[ 1, 2, 3 ]];[1, 2, 3]
[[ 1], [2], [3] ]];[1, 2, 3]
[[ 1, 2 ], [ 3, 4 ], [ 5, 6 ]];[1, 2, 4, 6, 5, 3]
[[1, 2, 3, 4 ], [ 5, 6, 7, 8 ]];[1, 2, 3, 4, 8, 7, 6, 5]
[[ 1, 11 ], [ 2, 12 ], [ 3, 13 ], [ 4, 14 ], [ 5, 15 ], [ 6, 16 ], [ 7, 17 ], [ 8, 18 ], [ 9, 19 ], [ 10, 20 ]];[1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2]
"
"Jump Game"	"Time : O(N); Space: O(1)
 
Description: 
Given an array of non-negative integers, you are initially positioned at 
the first index of the array. 
Each element in the array represents your maximum jump length at that position. 
Determine if you are able to reach the last index. 
For example: 
 A = [2,3,1,1,4], return true. 
 A = [3,2,1,0,4], return false.
 
{@link https://leetcode.com/problems/jump-game/ }"	"canJump"	"### Java
```java
public class Solution {

    public boolean canJump(int[] nums) {
        int i = 0;
        int n = nums.length;
        int reach = 0;
        for (; i < n && i <= reach; i++) {
            reach = Math.max(nums[i] + i, reach);
        }
        return i == n;
    }
}
```"	"array(int)[nums];bool
[ 2, 3, 1, 1, 4 ];true
[ 3, 2, 1, 0, 4 ];false
"
"Spiral Matrix I I"	"Time : O(); Space: O()
 
Description: 
Given an integer n, generate a square matrix filled with elements 
from 1 to n2 in spiral order. 
For example, 
Given n = 3, You should return the following matrix: 
[ 
 [ 1, 2, 3 ], 
 [ 8, 9, 4 ], 
 [ 7, 6, 5 ]
]
 
{@link https://leetcode.com/problems/spiral-matrix-ii/ }
P.S. : middle row: (n - 1) / 2"	"generateMatrix"	"### Java
```java
public class Solution {

    public int[][] generateMatrix(int n) {
        int[][] result = new int[n][n];
        if (n <= 0) {
            return result;
        }
        int number = 1;
        for (int i = 0; i < (n + 1) / 2; i++) {
            int rowStart = i;
            int rowEnd = n - i - 1;
            int colStart = i;
            int colEnd = n - i - 1;
            // top row
            for (int col = colStart; col <= colEnd; col++) {
                result[rowStart][col] = number++;
            }

            // right column
            for (int row = rowStart + 1; row <= rowEnd; row++) {
                result[row][colEnd] = number++;
            }

            // bottom row
            if (rowEnd > rowStart) {
                for (int col = colEnd - 1; col >= colStart; col--) {
                    result[rowEnd][col] = number++;
                }
            }

            // left column
            if (colStart < colEnd) {
                for (int row = rowEnd - 1; row >= rowStart + 1; row--) {
                    result[row][colStart] = number++;
                }
            }
        }
        return result;
    }
}
```"	"int[n];array(array(int))
0;[]
1;[ [ 1 ] ]
2;[ [ 1, 2 ], [ 4, 3 ] ]
3;[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]
4;[ [ 1, 2, 3, 4 ], [ 12, 13, 14, 5 ], [ 11, 16, 15, 6 ], [ 10, 9, 8, 7 ] ]
"
"Permutation Sequence"	"Time : O(); Space: O()
 
Description: 
The set [1,2,3,…,n] contains a total of n! unique permutations. 
By listing and labeling all of the permutations in order, 
We get the following sequence (ie, for n = 3): 
""123"" ""132"" ""213"" ""231"" ""312"" ""321"" 
Given n and k, return the kth permutation sequence. 
Note: Given n will be between 1 and 9 inclusive.
 
{@link https://leetcode.com/problems/permutation-sequence/ }
P.S. : how to write bug-free code"	"getPermutation"	"### Java
```java
public class Solution {

    public String getPermutation(int n, int k) {
        StringBuilder result = new StringBuilder();

        // calculate (n-1)!
        // for the 1st digit in result, there are n choices (i.e. buckets),
        // and each bucket has (n - 1) sub-buckets.
        int bucketSize = 1;
        for (int i = 1; i < n; i++) {
            bucketSize *= i;
        }

        // all digits in permutation
        List<Integer> digits = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            digits.add(i + 1);
        }
        int q = n - 1;
        while (digits.size() != 0) {
            int iBucket = (k - 1) / bucketSize;
            k = (k - 1) % bucketSize + 1;

            result.append(digits.get(iBucket));
            digits.remove(iBucket);
            if (q == 0) {
                bucketSize = 1;
            } else {
                bucketSize /= q;
            }
            q--;
        }
        return result.toString();
    }
}
```"	"int[n];int[k];string
3;1;""123""
3;2;""132""
3;3;""213""
3;4;""231""
3;5;""312""
3;6;""321""
4;1;""1234""
4;3;""1324""

"
"Rotate List"	"Time : O(); Space: O()
 
Description: 
Given a list, rotate the list to the right by k places, where k is 
non-negative. 
For example: 
 Given 1->2->3->4->5->NULL and k = 2, 
 return 4->5->1->2->3->NULL.
 
{@link https://leetcode.com/problems/rotate-list/ }
P.S. : dummy head + two pointers"	"rotateRight"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    public ListNode<Integer> rotateRight(ListNode<Integer> head, int k) {
        if (head == null) {
            return head;
        }

        // create dummy head
        ListNode dummy = new ListNode<Integer>();
        dummy.data = -1;
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;

        // count the length of list
        int len = 0;
        while (fast.next != null) {
            len++;
            fast = fast.next;
        }
        fast = dummy;

        k = k % len;
        if (k != 0) {
            // let fast pointer itself moves k steps
            for (int i = 0; i < k; i++) {
                fast = fast.next;
            }
            // let fast and slow move together until fast reaches the last node
            while (fast.next != null) {
                fast = fast.next;
                slow = slow.next;
            }
            // reconnect
            fast.next = dummy.next;
            dummy.next = slow.next;
            slow.next = null;
        }

        return dummy.next;
    }
}
```"	"linked_list(int)[head];int[k];linked_list(int)
[1,1,2,2,3,3,4,4,5];2;[4,5,1,2,3]
[1,1,2,2,3,3,4,4,5];1;[5,1,2,3,4]
[1,1,2,2,3,3,4,4,5];3;[3,4,5,1,2]
[1,1,2,2,3,3,4,4,5];5;[1,2,3,4,5]
[1,1,2,2,3,3,4,4,5];6;[5,1,2,3,4]
[];6;[]
[1];1;[1]
"
"Unique Paths"	"Time : O(mn); Space: O(mn)
 
Description: 
A robot is located at the top-left corner of a m x n grid (marked 
'Start' in the diagram below). 
The robot can only move either down or right at any point in time. The 
robot is trying to reach the bottom-right corner of the grid (marked 
'Finish' in the diagram below). 
How many possible unique paths are there?
 
{@link https://leetcode.com/problems/unique-paths/ }"	"uniquePaths"	"### Java
```java
public class Solution {

    public int uniquePaths(int m, int n) {
        if (m <= 0 || n <= 0) {
            return 0;
        }
        // syntax sugar: 0 is default value
        int[][] paths = new int[m + 1][n + 1];

        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (i == 1 && j == 1) {
                    // starting point
                    paths[i][j] = 1;
                } else {
                    paths[i][j] = paths[i - 1][j] + paths[i][j - 1];
                }
            }
        }

        return paths[m][n];
    }
}
```"	"int[m];int[n];int
1;1;1
1;2;1
2;2;2
3;2;3
3;1;1
"
"Unique Paths I I"	"Time : O(mn); Space: O(n)
 
Description: 
Follow up for ""Unique Paths"": 
Now consider if some obstacles are added to the grids. How many unique 
paths would there be? 
An obstacle and empty space is marked as 1 and 0 respectively in the grid. 
For example, 
There is one obstacle in the middle of a 3x3 grid as illustrated below. 
[ 
 [0,0,0], 
 [0,1,0], 
 [0,0,0] 
] 
The total number of unique paths is 2.
 
{@link https://leetcode.com/problems/unique-paths-ii/ }
P.S. : corner case in the leftmost column"	"uniquePathsWithObstacles"	"### Java
```java
public class Solution {

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        if (m == 0 || obstacleGrid[0].length == 0) {
            return 0;
        }
        int n = obstacleGrid[0].length;
        int[] dp = new int[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    // 1 means obstacle, so way to reach here
                    dp[j] = 0;
                } else if (j == 0) {
                    // the cell in leftmost column
                    // if 0 way to reach cell[i-1][0],
                    // then 0 way to reach cell[i][0]
                    dp[j] = (i > 0 && dp[j] == 0) ? 0 : 1;
                } else {
                    dp[j] = dp[j - 1] + dp[j];
                }
            }
        }
        return dp[n - 1];
    }
}
```"	"array(array(int))[obstacleGrid];int
[ [ 0, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 0 ] ];2
[ [ 1, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ];0
[ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ];0
[ [ 0, 0, 1 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ];5
[ [ 0, 0 ], [ 0, 0 ], [ 1, 0 ] ];2
"
"Minimum Path Sum"	"Time : O(N^2); Space: O(N)
 
Description: 
Given a m x n grid filled with non-negative numbers, find a path from top 
left to bottom right which minimizes the sum of all numbers along its path. 
Note: You can only move either down or right at any point in time.
 
{@link https://leetcode.com/problems/minimum-path-sum/ }
P.S. : min weighted path; avoid index out of bound"	"minPathSum"	"### Java
```java
public class Solution {
    /*
     * For each cell in grid, it can be reached either from the upper cell or
     * the cell to its left. Choose the one that has minimum sum from them.
     */
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int[] dp = new int[n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (j == 0) {
                    // 1st column in grid, can only be reached from upper cell
                    dp[j] = dp[j] + grid[i][j];
                } else if (i == 0) {
                    // 1st row in grid, can only be reached from cell to its
                    // left
                    dp[j] = dp[j - 1] + grid[i][j];
                } else {
                    dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j]);
                }
            }
        }
        return dp[n - 1];
    }
}
```"	"array(array(int))[grid];int
[ [ 1 ] ];1
[ [ 1, 1 ], [ 3, 1 ] ];3
[ [ 1, 1, 3 ], [ 4, 1, 1 ] ];4
[ [ 1, 2, 3 ], [ 1, 1, 8 ], [ 4, 1, 1 ], [ 4, 8, 1 ] ];6
[ [ 1, 2, 3, 2, 1 ] ];9
"
"Sqrtx"	"Time : O(logN); Space: O(1)
 
Description
Implement int sqrt(int x). 
Compute and return the square root of x.
 
{@link https://leetcode.com/problems/sqrtx/ }"	"mySqrt"	"### Java
```java
public class Solution {

    // find the last value that value*value <= x
    public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int left = 1;
        int right = x;
        while (left <= right) {
            // avoid potential Stack Overflow caused by (left + right) / 2;
            int half = (right - left) / 2 + left;
            if (half <= x / half && ((half + 1) > x / (half + 1))) {
                return half;
            } else if (half > x / half) {
                // instead of (half * half) > x to avoid stack overflow
                right = half - 1;
            } else {
                left = half + 1;
            }
        }
        return left;
    }
}
```"	"int[x];int
4;2
1;1
9;3
5;2
2147483647;46340
"
"Simplify Path"	"Time : O(N); Space: O(N)
--------------------------------------------------------------
{@link https://leetcode.com/problems/simplify-path/ } 
P.S. : 1.String.substring(beginIndex, endIndex)  //[beginIndex,endIndex)
       2.String.indexOf(str, fromIndex)  // [fromIndex,],
                                         // fromIndex=[0,len-1]"	"simplifyPath"	"### Java
```java
public class Solution {
    /**
     * add a global set to contain characters that should be skipped
     */
    private Set<String> skipSet = new HashSet<String>() {
        {
            add(""/"");
            add(""."");
            add("""");
        }
    };

    /**
     * Split the input string into array by delimiter ""/"". 
     * Since each "".."" will cause path to move back to its parent directory, 
     * we pop out the latest path from stack whenever we meet with a "".."".
     * ! pay attention to empty path case
     */
    public String simplifyPath(String path) {
        Stack<String> paths = new Stack<String>();
        String[] tokens = path.split(""/"");
        for (String token : tokens) {
            if (skipSet.contains(token) == false) {
                if (token.equals("".."") && paths.isEmpty() == false) {
                    // go back to parent directory
                    paths.pop();
                } else if (!token.equals("".."")) {
                    // for valid directory other than ""..""
                    paths.push(token);
                }
            }
        }
        return ""/"" + String.join(""/"", paths);
    }
}
```"	"string[path];string
""/home/"";""/home""
""/a/./b/../../c/"";""/c""
""/../"";""/""
""/home//foo/"";""/home/foo""
""/abc/..."";""/abc/...""
""///"";""/""
"
"Set Matrix Zeroes"	"Time : O(N^2); Space: O(1)
 
Description:
Given a m x n matrix, if an element is 0, set its entire row and column 
to 0. Do it in place. 
Follow up: 
Could you devise a constant space solution?
 
{@link https://leetcode.com/problems/set-matrix-zeroes/ }
P.S. : use input space to achieve O(1) space"	"setZeroes"	"### Java
```java
public class Solution {

    public int[][] setZeroes(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return matrix;
        }
        int m = matrix.length;
        int n = matrix[0].length;
        int wasteRow = -1;
        int wasteCol = -1;
        // find '0' in matrix and label them in ""waste"" line and column
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    if (wasteRow == -1) {
                        // first time to find 0
                        wasteRow = i;
                        wasteCol = j;
                    } else {
                        // label in waste row and column
                        matrix[wasteRow][j] = 0;
                        matrix[i][wasteCol] = 0;
                    }
                }
            }
        }
        if (wasteRow == -1) {
            return matrix;
        }
        // set zeroes based on label
        for (int col = 0; col < n; col++) {
            if (matrix[wasteRow][col] == 0) {
                // set zeroes on columns except waste columns
                // we need that information for later use
                if (col != wasteCol) {
                    for (int row = 0; row < m; row++) {
                        matrix[row][col] = 0;
                    }
                }
            }
        }
        for (int row = 0; row < m; row++) {
            if (matrix[row][wasteCol] == 0) {
                // set zeroes in the row
                for (int col = 0; col < n; col++) {
                    matrix[row][col] = 0;
                }
            } else {
                // clean this column
                matrix[row][wasteCol] = 0;
            }
        }
        return matrix;
    }
}
```"	"array(array(int))[matrix];array(array(int))
[ [ 1, 2, 3 ], [ 4, 0, 6 ], [ 7, 8, 9 ] ];[ [ 1, 0, 3 ], [ 0, 0, 0 ], [ 7, 0, 9 ] ]
[ [ 0, 2, 3 ], [ 4, 0, 6 ], [ 7, 8, 0 ] ];[ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
[ [ 0, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];[ [ 0, 0, 0 ], [ 0, 5, 6 ], [ 0, 8, 9 ] ]
[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 0 ] ];[ [ 1, 2, 0 ], [ 4, 5, 0 ], [ 0, 0, 0 ] ]
[ [ 1, 2, 3 ], [ 4, 5, 0 ], [ 7, 0, 9 ] ];[ [ 1, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
"
"Search A2 D Matrix"	"Time : O(lg(mn)); Space: O(1)
 
Description:
Write an efficient algorithm that searches for a value in an m x n matrix. 
This matrix has the following properties: 
Integers in each row are sorted from left to right. 
The first integer of each row is greater than the last integer of the 
previous row.
For example, 
Consider the following matrix: 
[ 
 [1,   3,  5,  7], 
 [10, 11, 16, 20], 
 [23, 30, 34, 50] 
]
Given target = 3, return true.
 
{@link https://leetcode.com/problems/search-a-2d-matrix/ }"	"searchMatrix"	"### Java
```java
public class Solution {

    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int rows = matrix.length;
        int cols = matrix[0].length;
        int startRow = 0;
        int endRow = rows - 1;
        while (startRow < endRow) {
            int halfRow = (startRow + endRow) / 2;
            int half = matrix[halfRow][cols - 1];
            if (half == target) {
                return true;
            } else if (half < target) {
                // go to lower rows to find target
                startRow = halfRow + 1;
            } else {
                // !target can be in end row
                endRow = halfRow;
            }
        }
        // search in 1D array
        return searchLine(matrix[startRow], target);
    }

    private boolean searchLine(int[] line, int target) {
        if (line.length == 0) {
            return false;
        }
        int left = 0;
        int right = line.length - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (line[mid] == target) {
                return true;
            } else if (line[mid] < target) {
                // go to right part
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
}
```"	"array(array(int))[matrix];int[target];bool
[ [  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];3;true
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];100;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];15;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];30;true
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];0;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];10;true
[ [  1,  3,  5,  7 ] ];10;false
[ [  1,  3,  5,  7 ] ];7;true
[ [  1,  3,  5,  7 ] ];1;true
[ [  1,  3,  5,  7 ] ];4;false
[ [  1,  3,  5,  7 ] ];5;true
[[ 1 ], [ 5 ], [ 9 ] ];1;true
[[ 1 ], [ 5 ], [ 9 ] ];18;false
[[ 1 ], [ 5 ], [ 9 ] ];0;false
[[ 1 ], [ 5 ], [ 9 ] ];3;false
[[ 1 ], [ 5 ], [ 9 ] ];7;false
"
"Sort Colors"	"Time : O(N); Space: O(1)
 
Description:
Given an array with n objects colored red, white or blue, sort them so 
that objects of the same color are adjacent, with the colors in the order 
red, white and blue. 
Here, we will use the integers 0, 1, and 2 to represent the color red, 
white, and blue respectively. 
Note: 
You are not suppose to use the library's sort function for this problem. 
Follow up: 
Could you come up with an one-pass algorithm using only constant space?
 
{@link https://leetcode.com/problems/sort-colors/ }"	"sortColors"	"### Java
```java
public class Solution {
    
    // concise version
    public int[] sortColors(int[] nums) {
        int r = -1;
        int w = -1;
        for (int b = 0; b < nums.length; b++) {
            int num = nums[b];
            if (num == 1) {
                nums[b] = nums[++w];
                nums[w] = 1;
            } else if (num == 0) {
                nums[b] = nums[++w];
                nums[w] = nums[++r];
                nums[r] = 0;
            }
        }
        return nums;
    }

    public void sortColorsVerbose(int[] nums) {
        int red = -1;
        int white = -1;
        int blue = -1;
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (num == 2) {
                // enlarge blue part 
                blue++;
            } else if (num == 1) {
                // enlarge white part
                ++blue;
                nums[blue] = nums[++white];
                nums[white] = 1;
            } else {
                // enlarge red part
                blue++;
                nums[blue] = nums[++white];
                nums[white] = nums[++red];
                nums[red] = 0;
            }
        }
    }
}
```"	"array(int)[nums];array(int)
[ 0, 0, 1, 2, 2 ];[ 0, 0, 1, 2, 2 ]
[ 2, 2, 1, 1, 0 ];[ 0, 1, 1, 2, 2 ]
[ 2, 0, 1, 2, 0 ];[ 0, 0, 1, 2, 2 ]
[ 2, 1, 2, 1 ];[ 1, 1, 2, 2 ]
[ 2, 1, 0, 1, 2, 1 ];[ 0, 1, 1, 1, 2, 2 ]
"
"Combinations"	"Time : O(); Space: O()
 
Description: 
Given two integers n and k, return all possible combinations of k numbers 
out of 1 ... n. 
For example, 
If n = 4 and k = 2, a solution is: 
[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ]
 
{@link https://leetcode.com/problems/combinations/ }"	"combine"	"### Java
```java
public class Solution {

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new ArrayList<>();
        if (k > n) {
            return result;
        }
        ArrayList<Integer> list = new ArrayList<>();
        int index = 0;
        combineHelper(n, k, index, list, result);
        return result;
    }
    
    private void combineHelper(int n, int k, int index, List<Integer> list, List<List<Integer>> res) {
        if (list.size() == k) {
            res.add(new ArrayList<>(list));
        }
        if (list.size() > k) {
            return;
        }
        for (int i = index; i < n; i++) {
            list.add(i + 1);
            combineHelper(n, k, i + 1, list, res);
            list.remove(list.size() - 1);
        }
    }
    
}
```"	"int[n];int[k];list(list(int))
4;2;[[2, 4], [3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]
4;1;[[1], [2], [3], [4]]
4;3;[[1, 2, 3], [2, 3, 4], [1, 3, 4], [1, 2, 4]]
4;4;[[1, 2, 3, 4]]
"
"Subsets"	"Time : O(2^n); Space: O()
 
Description: 
My Submissions Question Solution 
Given a set of distinct integers, nums, return all possible subsets. 
Note: Elements in a subset must be in non-descending order. 
The solution set must not contain duplicate subsets. 
For example, If nums = [1,2,3], a solution is: 
[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]
 
{@link https://leetcode.com/problems/subsets/ }"	"subsets"	"### Java
```java
public class Solution {

    // try to insert each number into all existing subsets
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Arrays.sort(nums);

        // push initial empty subset
        res.add(new ArrayList<>());

        for (int num : nums) {
            int sz = res.size(); // we don't need temp list any more
            for (int i = 0; i < sz; i++) {
                List<Integer> list = new ArrayList<>(res.get(i));
                list.add(num);
                res.add(list);
            }
        }
        return res;
    }
    
    // we have to use temporary list
    public List<List<Integer>> subsets2(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Arrays.sort(nums);

        // push initial empty subset
        res.add(new ArrayList<>());

        for (int num : nums) {
            // try insert num into all existing subsets
            List<List<Integer>> temp = new ArrayList<>(); 
            for (List<Integer> sub : res) {
                List<Integer> list = new ArrayList<>(sub);
                list.add(num);
                temp.add(list);
            }
            res.addAll(temp);
        }
        return res;
    }
}
```"	"array(int)[nums];list(list(int))
[ 1, 2, 3 ];[[], [1], [2], [3], [1, 3], [1, 2], [2, 3], [1, 2, 3]]
[ 1, 2 ];[[], [1], [2], [1, 2]]
[ 1 ];[[], [1]]
[ 4, 1, 0 ];[[], [0], [0, 1], [0, 4], [0, 1, 4], [1], [1, 4], [4]]
[];[[]]
"
"Word Search"	"Time : O(); Space: O()
 
Description: 
Given a 2D board and a word, find if the word exists in the grid. 
The word can be constructed from letters of sequentially adjacent cell, 
where ""adjacent"" cells are those horizontally or vertically neighboring. 
The same letter cell may not be used more than once. 
For example, Given board = 
[ 
 [""ABCE""], 
 [""SFCS""], 
 [""ADEE""] 
] 
word = ""ABCCED"", -> returns true, 
word = ""SEE"", -> returns true, 
word = ""ABCB"", -> returns false.
 
{@link https://leetcode.com/problems/word-search/ }"	"exist"	"### Java
```java
public class Solution {

    public boolean exist(String[][] board, String word) {
        if (board.length == 0 || board[0].length == 0) {
            return false;
        }
        int rows = board.length;
        int cols = board[0].length;
        boolean[][] visited = new boolean[rows][cols];
        int wordIndex = 0;
        // because the choices for matching 1st character of word
        // is different from choices for matching rest characters of word, i.e.
        // each position on board can be the 1st position,
        // only adjacent positions can be the position for matching the next
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // try each possible starting point to
                // match 1st character in word
                if (exist(wordIndex, i, j, rows, cols, board, word, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean exist(int wordIndex, int row, int col, int rows, int cols,
            String[][] board, String word, boolean[][] visited) {
        // base case
        if (wordIndex == word.length()) {
            // word found in board
            return true;
        }

        // recursive case
        if ((row >= 0 && row < rows) && (col >= 0 && col < cols)
                && visited[row][col] == false
                && (board[row][col].equals(String.valueOf(word.charAt(wordIndex))))) {
            // go on searching in adjacent positions
            visited[row][col] = true;
            boolean found = 
                       exist(wordIndex + 1, row - 1, col, rows, cols, board, 
                            word, visited)
                    || exist(wordIndex + 1, row + 1, col, rows, cols, board,
                            word, visited)
                    || exist(wordIndex + 1, row, col - 1, rows, cols, board,
                            word, visited)
                    || exist(wordIndex + 1, row, col + 1, rows, cols, board,
                            word, visited);
            if (found) {
                return true;
            } else {
                visited[row][col] = false;
            }
        }
        return false;
    }
}
```"	"array(array(string))[board];string[word];bool
[ [ ""A"", ""B"", ""C"", ""E"" ], [ ""S"", ""F"", ""C"", ""S"" ], [ ""A"", ""D"", ""E"", ""E"" ] ];""ABCCED"";true
[ [ ""A"", ""B"", ""C"", ""E"" ], [ ""S"", ""F"", ""C"", ""S"" ], [ ""A"", ""D"", ""E"", ""E"" ] ];""SEE"";true
[ [ ""A"", ""B"", ""C"", ""E"" ], [ ""S"", ""F"", ""C"", ""S"" ], [ ""A"", ""D"", ""E"", ""E"" ] ];""ABCB"";false
[ [ ""A"", ""B"", ""C"" ], [ ""D"", ""E"", ""F"" ], [ ""G"", ""H"", ""I"" ] ];""BEDGH"";true
"
"Remove Duplicates From Sorted Array I I"	"Time : O(N); Space: O(1)
 
Description: 
Follow up for ""Remove Duplicates"": 
What if duplicates are allowed at most twice? 
For example, Given sorted array nums = [1,1,1,2,2,3], 
Your function should return length = 5, with the first five elements of 
nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond 
the new length.
 
{@link https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ }"	"removeDuplicates"	"### Java
```java
public class Solution {

    public int removeDuplicates(int[] nums) {
        int j = -1;  // last index of `good` part
        for (int i = 0; i < nums.length; i++) {
            if (i < 2 || (nums[i] != nums[j - 1])) {
                nums[++j] = nums[i];
            }
        }
        return j + 1;
    }

    // version2, use `continue` keyword
    public int removeDuplicates2(int[] nums) {
        int j = -1;
        for (int i = 0; i < nums.length; i++) {
            if (i >= 2 && nums[i] == nums[j] && nums[i] == nums[j - 1]) {
                continue;
            }
            nums[++j] = nums[i];
        }
        return j + 1;
    }
}
```"	"array(int)[nums];int
[ ];0
[ 1, 1, 1, 2, 2, 3 ];5
[ 1, 1, 1, 2, 2, 3, 3, 3 ];6
[ 1, 2, 3, 4, 4, 4 ];5
[ 1, 2, 3, 4, 4, 4, 5, 5 ];7
[ 1, 1, 1, 2, 3, 4, 5 ];6
[ 1, 1 ];2
[ 1, 2, 2 ];3
[ 1 ];1
"
"Search In Rotated Sorted Array I I"	"Time : O(logN); Space: O(1)
 
Description: 
Follow up for ""Search in Rotated Sorted Array"" 
Duplicates are allowed in array.
Write a function to determine if a given target is in the array.
 
{@link https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ }"	"search"	"### Java
```java
public class Solution {

    public boolean search(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }
        int left = 0;
        int right = len - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return true;
            }
            if (nums[mid] > nums[right]) {
                // left part is sorted
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else if (nums[mid] < nums[right]) {
                // right part is sorted
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                // nums[mid] == nums[right]
                // because nums[mid] != target, so know nums[right] != target
                right--;
            }
        }
        return false;
    }
}
```"	"array(int)[nums];int[target];bool
[1,1,1,1];1;true
[1,1,1,1];2;false
[1,1,1,1];0;false
[2, 5, 1, 1, 1, 2, 2];2;true
[2, 5, 1, 1, 1, 2, 2];3;false
[2, 5, 5, 7, 1, 1, 1, 2, 2];5;true
[2, 5, 5, 7, 1, 1, 1, 2, 2];3;false
[2, 5, 5, 7, 1, 1, 1, 2, 2];8;false
[1, 1, 3, 1];3;true
[1, 3];0;false
[3, 1, 1];3;true
[1, 3, 1, 1, 1];3;true
"
"Remove Duplicates From Sorted List I I"	"Time : O(N) ; Space: O(1)
 
Description: 
Given a sorted linked list, delete all nodes that have duplicate numbers, 
leaving only distinct numbers from the original list. 
For example, 
Given 1->2->3->3->4->4->5, return 1->2->5. 
Given 1->1->1->2->3, return 2->3.
 
{@link https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ }"	"deleteDuplicates"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    public ListNode<Integer> deleteDuplicates(ListNode<Integer> head) {
        ListNode<Integer> dummy = new ListNode<>();
        dummy.next = head;
        ListNode pre = dummy; // last unique node we found
        ListNode node = pre.next;
        while (node != null) {
            // find the last node that has the same value as current node
            while (node.next != null && node.next.data == node.data) {
                node = node.next;
            }
            // now, node has different value from its next node (if next
            // node exists), we need to compare with previous node to
            // see whether `node` has unique value
            if (pre.next == node) {
                // ! don't use (pre.val == node.val) unless you are sure
                // dummy has different value from head node
                pre = node;
            } else {
                pre.next = node.next;
            }
            node = node.next;
        }
        return dummy.next;
}
```"	"linked_list(int)[head];linked_list(int)
[1,1,2,2,3,3,3,4,3,5,4,6,4,7,4,8,4,9,5];[1,1,2,2,5]
[1,1,1,2,1,3,2,4,3];[2,3]
[1,1,1,2,1,3,2];[2]
[1,1,2,2,2,3,2];[1]
[1,1,1,2,1,3,1,4,2,5,2,6,2,7,3,8,3,9,3,10,3,11,3];[]
"
"Partition List"	"Time : O(N); Space: O(1)
 
Description: 
Given a linked list and a value x, partition it such that all nodes less 
than x come before nodes greater than or equal to x. 
You should preserve the original relative order of the nodes in each of 
the two partitions. 
For example, 
Given 1->4->3->2->5->2 and x = 3, return 1->2->2->4->3->5.
 
{@link https://leetcode.com/problems/partition-list/ }"	"partition"	"### Java
```java
public class Solution {
   public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        int index = 0;
        List<String> path = new ArrayList<>();
        partition(s, index, path, result);
        return  result;
    }

    // backtracking
    private void partition(String s, int index, List<String> path,
            List<List<String>> result) {
        // base case
        if (index == s.length()) {
            result.add(path);
            return;
        }
        // recursive case
        for (int i = index; i < s.length(); i++) {
            String sub = s.substring(index, i + 1);
            if (isPalindrome(sub)) {
                List<String> newPath = new ArrayList<String>(path);
                newPath.add(sub);
                // go on searching
                partition(s, i + 1, newPath, result);
            }
        }
    }

    private Map<String, Boolean> memo = new HashMap<>();

    private boolean isPalindrome(String sub) {
        if (memo.containsKey(sub)) {
            return memo.get(sub);
        }
        boolean ispalin = true;
        for (int i = 0, j = sub.length() - 1; i < j; i++, j--) {
            if (sub.charAt(i) != sub.charAt(j)) {
                ispalin = false;
                break;
            }
        }
        memo.put(sub, ispalin);
        return ispalin;
    }
}
```"	"string[s];list(list(string))
""aab"";[[""aa"",""b""],[""a"",""a"",""b""]]
""a"";[[""a""]]
""abbab"";[[""a"",""b"",""b"",""a"",""b""],[""a"",""b"",""bab""],[""a"",""bb"",""a"",""b""],[""abba"",""b""]]
"
"Gray Code"	"Time : O(2^n); Space: O(n)
 
Description: 
The gray code is a binary numeral system where two successive values 
differ in only one bit. 
Given a non-negative integer n representing the total number of bits in 
the code, print the sequence of gray code. A gray code sequence must begin with 0. 
For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 
 00 - 0 
 01 - 1 
 11 - 3 
 10 - 2 
 
Note: For a given n, a gray code sequence is not uniquely defined. 
For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. 
 
{@link https://leetcode.com/problems/gray-code/ }"	"grayCode"	"### Java
```java
public class Solution {

    // DFS version
    public List<Integer> grayCode(int n) {
        List<Integer> result = new ArrayList<>();
        int i = 0;
        result.add(0);
        grayCode(i, n, result);
        return result;
    }

    private void grayCode(int i, int n, List<Integer> result) {
        // base case
        if (i == n) {
            return;
        }
        // recursive case
        int base = (int) Math.pow(2, i);
        int len = result.size();
        for (int j = len - 1; j >= 0; j--) {
            result.add(base + result.get(j));
        }
        grayCode(i + 1, n, result);
    }
    
}
```"	"int[n];list(int)
2;[0,1,3,2]
0;[0]
1;[0,1]
3;[0,1,3,2,6,7,5,4]
"
"Subsets I I"	"Time : O(2^n); Space: O(2^n)
 
 Given a collection of integers that might contain duplicates, nums,
 return all possible subsets. 
 
 Note: 
 Elements in a subset must be in non-descending order. 
 The solution set must not contain duplicate subsets. 
 
 For example, 
 If nums = [1,2,2], a solution is:
     [ [2], [1], [1,2,2], [2,2], [1,2], [] ]
     
 
{@link https://leetcode.com/problems/subsets-ii/ }"	"subsetsWithDup"	"### Java
```java
public class Solution {

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        // empty list is subset of any list
        result.add(new ArrayList<>());
        // enlarged size by last non-repeated number
        int k = 0;
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            int size = result.size();
            int start = 0;
            if (i == 0 || num != nums[i - 1]) {
                k = size;
            } else {
                // for repeating number
                start = size - k;
            }
            // for a non-repeated number, a new number will double the size of current result
            // by adding this number to each of existing subset;
            // for a repeated number, this repeated number will only change
            // those ""new subsets"" created by last number in the loop
            for (int j = start; j < size; j++) {
                List<Integer> list = new ArrayList<>(result.get(j));
                list.add(num);
                result.add(list);
            }
        }
        return result;
    }
}
```"	"array(int)[nums];list(list(int))
[];[[]]
[ 1, 2, 2 ];[[], [1], [2], [1, 2, 2], [2, 2], [1, 2]]
[ 1, 2 ];[[], [1], [2], [1, 2]]
[ 1 ];[[], [1]]
[1, 1, 2, 3, 3];[[], [1], [2], [3], [1,1], [1,2], [1,3], [2,3], [3,3], [1,1,2], [1,1,3], [1,2,3], [1,3,3], [2,3,3], [1,1,2,3], [1,1,3,3], [1,2,3,3], [1,1,2,3,3]]
[ 1, 1, 1 ];[[], [1], [1, 1], [1,1,1]]
"
"Decode Ways"	"Time : O(N); Space: O(1)
 
Description: 
A message containing letters from A-Z is being encoded to numbers using 
the following mapping: 
 'A' -> 1 'B' -> 2 ... 'Z' -> 26 
 Given an encoded message containing digits, determine the total number 
 of ways to decode it. 
 
 For example, 
 Given encoded message ""12"", it could be decoded as ""AB"" (1 2) or ""L"" (12). 
 The number of ways decoding ""12"" is 2.
 
{@link https://leetcode.com/problems/decode-ways/ }"	"numDecodings"	"### Java
```java
public class Solution {

    /**
     * Similarly to climbing stairs, for each s[i] we have two choices,
     * 1) if s[i-1:i] is in [10, 26], we can treat s[i:1:i] as the last number we decode 
     * 2) if s[i] is in [1, 9], we can treat s[i] as the last number we decode
     */
    public int numDecodings(String s) {
        int len = s.length();
        if (len == 0) {
            return 0;
        }
        int p1 = 1;   // number of decoding s[0 : i - 2]
        int p2 = 1;   // number of decoding s[0 : i - 1]
        int last = 0; // last digit before current digit

        for (int i = 0; i < len ; i++) {
            int digit = s.charAt(i) - '0';
            // number of decoding s[0 : i]
            int result = 0;

            int num = last * 10 + digit;
            // if last 2 digits is in [10,26]
            if (num >= 10 && num <= 26) {
                result += p1;
            }

            // if last digit is [1-9]
            if (digit != 0) {
                result += p2;
            }
            
            // update
            p1 = p2;
            p2 = result;
            last = digit;
        }
        return p2;
    }
}
```"	"string[s];int
""1212"";5
""611"";2
""012"";0
""27"";1
""10"";1
""0"";0
""100"";0
""101"";1
"""";0
""1"";1
""8"";1
"
"Reverse Linked List I I"	"Time : O(N); Space: O(1)
 
Description:
Reverse a linked list from position m to n. Do it in-place and in one-pass. 
For example: 
Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL. 
Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.
 
{@link https://leetcode.com/problems/reverse-linked-list-ii/ }
Do it in-place and in one-pass.
1 <= m <= n <= length is satisfied."	"reverseBetween"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    public ListNode<Integer> reverseBetween(ListNode<Integer> head, int m, int n) {
        ListNode<Integer> dummy = new ListNode();
        dummy.next = head;

        ListNode<Integer> pre = dummy;
        // let pre walks (m - 1) steps itself
        for (int i = 0; i < m - 1; i++) {
            pre = pre.next;
        }
        ListNode<Integer> start = pre.next;
        ListNode<Integer> then = start.next;
        // reverse nodes between m and n
        for (int i = 0; i < n -m; i++) {
            start.next = then.next;
            then.next = pre.next;
            pre.next = then;
            then = start.next;
        }
        return dummy.next;
    }
}
```"	"linked_list(int)[head];int[m];int[n];linked_list(int)
[1, 1, 2, 2, 3, 3, 4, 4, 5];2;4;[1, 4, 3, 2, 5]
[1, 1, 2, 2, 3, 3, 4, 4, 5];1;5;[5, 4, 3, 2, 1]
[1, 1, 2, 2, 3, 3, 4, 4, 5];1;1;[1, 2, 3, 4, 5]
[1, 1, 2, 2, 3, 3, 4, 4, 5];5;5;[1, 2, 3, 4, 5]
"
"Restore I P Addresses"	"Time : O(); Space: O()
 
Description: 
Given a string containing only digits, restore it by returning all
possible valid IP address combinations. 
For example:
 Given ""25525511135"", 
 return [""255.255.11.135"", ""255.255.111.35""]. 
(Order does not matter) 
 
{@link https://leetcode.com/problems/restore-ip-addresses/ }"	"restoreIpAddresses"	"### Java
```java
public class Solution {
    // backtracking: cut into required parts
    public List<String> restoreIpAddresses(String s) {
        List<String> result = new ArrayList<>();
        String combination = """";
        restoreIpAddresses(0, 4, s, combination, result);
        return result;
    }

    private void restoreIpAddresses(int index, int parts, String s,
            String combination, List<String> result) {
        // base case
        if (index == s.length() && parts == 0) {
            // one combination is found!
            // remove the last '.' at the end of combination
            result.add(combination.substring(0, combination.length() - 1));
        }
        // recursive case
        if (parts > 0) {
            // the 1st part of ip address can at most take 3 characters
            for (int i = index; i < s.length() && i < index + 3; i++) {
                String ip = s.substring(index, i + 1);
                if (isValidIPNumber(ip)) {
                    String newCombination = combination + ip + ""."";
                    restoreIpAddresses(i + 1, parts - 1, s, newCombination, result);
                }
            }
        }
    }

    // whether number is [""0"" ~ ""255""]
    private boolean isValidIPNumber(String number) {
        int num = Integer.parseInt(number);
        if (num <= 9) {
            return number.length() == 1;
        } else if (num <= 99) {
            return number.length() == 2;
        } else {
            return num <= 255;
        }
    }
}
```"	"string[s];list(string)
""25525511135"";[""255.255.11.135"", ""255.255.111.35""]
""01011"";[""0.1.0.11"", ""0.10.1.1""]
""172162541"";[""17.216.25.41"", ""17.216.254.1"", ""172.16.25.41"", ""172.16.254.1"", ""172.162.5.41"", ""172.162.54.1""]
""0000"";[""0.0.0.0""]
"
"Binary Tree Inorder Traversal"	"Time : O(N); Space: O(N)
 
Description: 
Given a binary tree, return the inorder traversal of its nodes' values. 
For example: 
Given binary tree {1,#,2,3}, 
         1
           \
            2
           /
          3
return [1,3,2]. 
Note: Recursive solution is trivial, could you do it iteratively?
 
{@link https://leetcode.com/problems/binary-tree-inorder-traversal/ }"	"inorderTraversal"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    // more concise version compared to my verbose one
    public List<Integer> inorderTraversal(BinaryTreeNode<Integer> root) {
        List<Integer> result = new ArrayList<>();
        Stack<BinaryTreeNode<Integer>> stack = new Stack<>();
        BinaryTreeNode<Integer> node = root;
        while (node != null || !stack.empty()) {
            // push left nodes into stack
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            result.add(node.data);
            // ! key step: invoke recursive call on node's right child
            node = node.right;
        }
        return result;
    }

//    public List<Integer> inorderTraversal(BinaryTreeNode<Integer> root) {
//        List<Integer> result = new ArrayList<>();
//        if (root == null) {
//            return result;
//        }
//        Stack<BinaryTreeNode<Integer>> stack = new Stack<>();
//        BinaryTreeNode<Integer> node = root;
//        while (node != null) {
//            stack.push(node);
//            node = node.left;
//        }
//        
//        while (!stack.empty()) {
//            node = stack.pop();
//            result.add(node.val);
//            if (node.right != null) {
//                node = node.right;
//                while (node != null) {
//                    stack.push(node);
//                    node = node.left;
//                }
//            }
//        }
//        return result;
//    }
}
```"	"binary_tree(int)[root];list(int)
null;[]
[1, null, 2, 3];[1, 3, 2]
[1, 2, 3, 4, 5, 6, 7];[4, 2, 5, 1, 6, 3, 7]
[1, null];[1]
[1, 2, null, 3];[3, 2, 1]
[1, null, 2, null, 3];[1, 2, 3]
"
"Unique Binary Search Trees I I"	"Time : O(); Space: O()
 
Description: 
Given n, generate all structurally unique BST's (binary search trees) 
that store values 1...n. 
For example, 
Given n = 3, your program should return all 5 unique BST's shown below. 
1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3
 
{@link https://leetcode.com/problems/unique-binary-search-trees-ii/ }"	"generateTrees"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public List<BinaryTreeNode<Integer>> generateTrees(int n) {
        if (n <= 0) {
            return new ArrayList<BinaryTreeNode<Integer>>();
        }
        int start = 1;
        int end = n;
        return generateTrees(start, end);
    }

    private List<BinaryTreeNode<Integer>> generateTrees(int start, int end) {
        List<BinaryTreeNode<Integer>> result = new ArrayList<>();
        // base case
        if (start > end) {
            result.add(null);
            return result;
        }

        // recursive case
        for (int rootVal = start; rootVal <= end; rootVal++) {
            List<BinaryTreeNode<Integer>> lefts = generateTrees(start, rootVal - 1);
            List<BinaryTreeNode<Integer>> rights = generateTrees(rootVal + 1, end);
            for (BinaryTreeNode<Integer> left : lefts) {
                for (BinaryTreeNode<Integer> right : rights) {
                    BinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>();
                    root.data = rootVal;
                    root.left = left;
                    root.right = right;
                    result.add(root);
                }
            }
        }
        return result;
    }
}
```"	"int[n];list(binary_tree(int))
3;[[1,null,3,null,null,2],[3,2,null,1],[3,1,null,null,2],[2,1,3],[1,null,2,null,3]]
2;[[1,null,2],[2,1]]
"
"Unique Binary Search Trees"	"Time : O(); Space: O()
 
Description: 
Given n, how many structurally unique BST's (binary search trees) that 
store values 1...n?
 
{@link https://leetcode.com/problems/unique-binary-search-trees/ }"	"numTrees"	"### Java
```java
public class Solution {
    public int numTrees(int n) {
        if (n <= 0) {
            return 0;
        }
        int start = 1;
        int end = n;
        return numTrees(start, end);
    }

    private int numTrees(int start, int end) {
        // base case
        int result = 0;
        if (start > end) {
            return 1;
        }
        // recursive case
        for (int root = start; root <= end; root++) {
            int lefts = numTrees(start, root - 1);
            int rights = numTrees(root + 1, end);
            result += lefts * rights;
        }
        return result;
    }
}
```"	"int[n];int
3;5
1;1
2;2
19;1767263190
19;1767263190
18;477638700
"
"Validate Binary Search Tree"	"Time : O(); Space: O()
 
Description:
 Given a binary tree, determine if it is a valid binary search tree (BST). 
 Assume a BST is defined as follows: 
 
 The left subtree of a node contains only nodes with keys less than the node's key. 
 The right subtree of a node contains only nodes with keys greater than the node's key. 
 Both the left and right subtrees must also be binary search trees.
 
 
{@link https://leetcode.com/problems/validate-binary-search-tree/ }"	"isValidBST"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public boolean isValidBST(BinaryTreeNode<Integer> root) {
        return isValidBST(root, null, null);
    }

    private boolean isValidBST(BinaryTreeNode<Integer> root, Integer min, Integer max) {
        if (root == null) {
            return true;
        }
        if ((min != null && root.data <= min) || (max != null && root.data >= max)) {
            return false;
        }
        return isValidBST(root.left, min, root.data)
                && isValidBST(root.right, root.data, max);
    }
}
```"	"binary_tree(int)[root];bool
[10, 5, 15, null, null, 6, 20];false
[15, 6, 20, 5, 10];true
[3, 2, null, 1];true
[1, null, 2, null, 3];true
[3, 2, null, null, 4];false
"
"Binary Tree Zigzag Level Order Traversal"	"Time : O(); Space: O()
 
Description: 
Given a binary tree, return the zigzag level order traversal of its nodes' 
values. (ie, from left to right, then right to left for the next level 
and alternate between). 
For example: 
Given binary tree {3,9,20,#,#,15,7}, 
    3
   / \
  9  20
    /  \ 
   15   7 
return its zigzag level order traversal as: 
[ [3], [20,9], [15,7] ]
 
{@link https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ }"	"zigzagLevelOrder"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public List<List<Integer>> zigzagLevelOrder(BinaryTreeNode<Integer> root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Queue<BinaryTreeNode<Integer>> curLevel = new LinkedList<>();
        curLevel.add(root);
        boolean oddLevel = true;
        while (!curLevel.isEmpty()) {
            Queue<BinaryTreeNode<Integer>> nextLevel = new LinkedList<>();
            int curLevelLen = curLevel.size();

            // initialize list with current list's size
            List<Integer> curList = new ArrayList<>(
                    Arrays.asList(new Integer[curLevelLen]));

            for (int i = 0; i < curLevelLen; i++) {
                BinaryTreeNode<Integer> node = curLevel.poll();
                // index to put current value
                int index = oddLevel ? i : (curLevelLen - i - 1);
                curList.set(index, node.data);

                if (node.left != null) {
                    nextLevel.add(node.left);
                }
                if (node.right != null) {
                    nextLevel.add(node.right);
                }

            }
            // for next level
            result.add(curList);
            oddLevel = !oddLevel;
            curLevel = nextLevel;
        }
        return result;
    }
}
```"	"binary_tree(int)[root];list(list(int))
[3, 9, 20, null, null, 15, 7];[[3], [20, 9], [15, 7]]
[3, 9, 20, null, null, 15];[[3], [20, 9], [15]]
[3, null, 20, 15];[[3], [20], [15]]
null;[]
"
"Construct Binary Tree From Preorder And Inorder Traversal"	"Time : O(); Space: O()
 
Description: 
Given preorder and inorder traversal of a tree, construct the binary tree. 
Note: 
You may assume that duplicates do not exist in the tree.
 
{@link https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/}"	"buildTree"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public BinaryTreeNode<Integer> buildTree(int[] preorder, int[] inorder) {
        if (preorder.length != inorder.length || preorder.length == 0) {
            return null;
        }
        int preStart = 0;
        int preEnd = preorder.length - 1;
        int inStart = 0;
        int inEnd = inorder.length - 1;
        return buildTree(preorder, preStart, preEnd, inorder, inStart, inEnd);
    }

    private BinaryTreeNode<Integer> buildTree(int[] preorder, int preStart, int preEnd,
            int[] inorder, int inStart, int inEnd) {
        // base case
        if (preStart > preEnd) {
            return null;
        }
        if (preStart == preEnd) {
            BinaryTreeNode<Integer> ret = new BinaryTreeNode<>();
            ret.data = preorder[preStart];
            return ret;
        }
        // recursive case
        int rootVal = preorder[preStart];
        // find index of root in inorder array
        int rootIndexInInorder = -1;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                rootIndexInInorder = i;
                break;
            }
        }
        //TODO: if rootIndex == -1, throws exception
        BinaryTreeNode<Integer> root = new BinaryTreeNode<>();
        root.data = rootVal;
        int leftEnd = rootIndexInInorder - inStart + preStart;
        root.left = buildTree(preorder, preStart + 1, leftEnd,
                inorder, inStart, rootIndexInInorder - 1);
        root.right = buildTree(preorder, leftEnd + 1, preEnd,
                inorder, rootIndexInInorder + 1, inEnd);
        return root;
    }
}
```"	"array(int)[inorder];array(int)[postorder];binary_tree(int)
[1];[1];[1]
[3, 2, 1];[3, 2, 1];[1, 2, null, 3]
[1, 2, 3];[3, 2, 1];[1, null, 2, null, 3]
[1, 2, 3];[2, 1, 3];[1, 2, 3]
[2, 6, 8, 4, 1, 5, 7, 3];[8, 6, 4, 2, 7, 5, 3, 1];[1, 2, 3, null, 4, 5, null, 6, null, null, 7, null, 8]
[4, 6, 8, 2, 1, 5, 7, 3, 9];[8, 6, 4, 2, 7, 5, 9, 3, 1];[1, 2, 3, 4, null, 5, 9, null, 6, null, 7, null, 8]
[1, 2];[1, 2];[1, null, 2]
"
"Construct Binary Tree From Inorder And Postorder Traversal"	"Time : O(); Space: O()
 
Description: 
Given inorder and postorder traversal of a tree, construct the binary tree. 
Note: 
You may assume that duplicates do not exist in the tree
 
{@link https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ }"	"buildTree"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data) { this.data = data; }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public BinaryTreeNode<Integer> buildTree(int[] inorder, int[] postorder) {
        if (inorder.length != postorder.length || inorder.length == 0) {
            return null;
        }
        int inStart = 0;
        int inEnd = inorder.length - 1;
        int postStart = 0;
        int postEnd = postorder.length - 1;
        return buildTree(inorder, inStart, inEnd, postorder, postStart, postEnd);
    }

    private BinaryTreeNode<Integer> buildTree(int[] inorder, int inStart, int inEnd,
            int[] postorder, int postStart, int postEnd) {
        // base case
        if (inStart > inEnd) {
            return null;
        }
        if (inStart == inEnd) {
            return new BinaryTreeNode<Integer>(inorder[inStart]);
        }

        // recursive case
        int rootVal = postorder[postEnd];
        // find root value in inorder array
        int rootIndexInInorder = -1;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                rootIndexInInorder = i;
                break;
            }
        }
        BinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(rootVal);
        int leftEnd = rootIndexInInorder - 1 - inStart + postStart;
        root.left = buildTree(inorder, inStart, rootIndexInInorder - 1,
                postorder, postStart, leftEnd);
        root.right = buildTree(inorder, rootIndexInInorder + 1, inEnd,
                postorder, leftEnd + 1, postEnd - 1);

        return root;
    }
}
```"	"array(int)[inorder];array(int)[postorder];binary_tree(int)
[1];[1];[1]
[3, 2, 1];[3, 2, 1];[1, 2, null, 3]
[1, 2, 3];[3, 2, 1];[1, null, 2, null, 3]
[2, 1, 3];[2, 3, 1];[1, 2, 3]
[2, 6, 8, 4, 1, 5, 7, 3];[8, 6, 4, 2, 7, 5, 3, 1];[1, 2, 3, null, 4, 5, null, 6, null, null, 7, null, 8]
[4, 6, 8, 2, 1, 5, 7, 3, 9];[8, 6, 4, 2, 7, 5, 9, 3, 1];[1, 2, 3, 4, null, 5, 9, null, 6, null, 7, null, 8]
[1, 2];[2, 1];[1, null, 2]
"
"Convert Sorted Array To Binary Search Tree"	"Time : O(); Space: O()
 
Description: 
Given an array where elements are sorted in ascending order,  
convert it to a height balanced BST.                          
 
{@link https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ }"	"sortedArrayToBST"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data) { this.data = data; }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public BinaryTreeNode<Integer> sortedArrayToBST(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return null;
        }
        int startIndex = 0;
        int endIndex = len - 1;
        return sortedArrayToBST(nums, startIndex, endIndex);
    }

    private BinaryTreeNode<Integer> sortedArrayToBST(int[] nums, int startIndex, int endIndex) {
        // base case
        if (startIndex > endIndex) {
            return null;
        }
        if (startIndex == endIndex) {
            return new BinaryTreeNode<Integer>(nums[startIndex]);
        }
        // recursive case
        int middle = (startIndex + endIndex) / 2;
        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(nums[middle]);
        root.left = sortedArrayToBST(nums, startIndex, middle - 1);
        root.right = sortedArrayToBST(nums, middle + 1, endIndex);
        return root;
    }
}
```"	"array(int)[nums];binary_tree(int)
[1, 2, 3, 4, 5];[3, 1, 4, null, 2, null, 5]
[1, null];[1]
[1, 2, 3, 4];[2, 1, 3, null, null, null, 4]
"
"Convert Sorted List To Binary Search Tree"	"Time : O(N); Space: O(N)
 
Description: 
Given a singly linked list where elements are sorted        
in ascending order, convert it to a height balanced BST.    
 
{@link https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ }
1. how to get middle index (len - 1) / 2 v.s. len / 2;"	"sortedListToBST"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data) { this.data = data; }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

   public BinaryTreeNode<Integer> sortedListToBST(ListNode<Integer> head) {
        if (head == null) {
            return null;
        }
        int len = 0;
        ListNode<Integer> node = head;
        while (node != null) {
            node = node.next;
            len++;
        }
        return sortedListToBST(head, len);
    }

    private BinaryTreeNode<Integer> sortedListToBST(ListNode<Integer> head, int len) {
        // base case
        if (len == 0) {
            return null;
        }
        if (len == 1) {
            return new BinaryTreeNode<>(head.data);
        }
        // recursive case
        int middle = (len - 1) / 2;
        ListNode<Integer> node = head;
        for (int i = 0; i < middle; i++) {
            node = node.next;
        }
        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(node.data);
        root.left = sortedListToBST(head, middle);
        root.right = sortedListToBST(node.next, len - middle - 1);
        return root;
    }
}
```"	"linked_list(int)[nums];binary_tree(int)
[1];[1]
[1, 1, 2];[1, null, 2]
[1, 1, 2, 2, 3];[2, 1, 3]
[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7];[4, 2, 6, 1, 3, 5, 7]
"
"Path Sum I I"	"Time : O(N); Space: O(N^2)
 
Description: 
Given a binary tree and a sum, find all root-to-leaf paths 
where each path's sum equals the given sum.
 
 
{@link https://leetcode.com/problems/path-sum-ii/ }
add 1d list into 2d list."	"pathSum"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public List<List<Integer>> pathSum(BinaryTreeNode<Integer> root, int sum) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        int target = sum;
        List<Integer> path = new ArrayList<>();
        pathSum(root, target, path, result);
        return result;
    }

    private void pathSum(BinaryTreeNode<Integer> root, int target, List<Integer> path,
            List<List<Integer>> result) {
        // base case
        if (root == null) {
            return;
        }
        path.add(root.data);
        if (root.left == null && root.right == null && root.data == target) {
            // base case
            // ! don't use result.add(path) because this will only add a
            // reference;
            result.add(new ArrayList<>(path));
        } else {
            // recursive case
            pathSum(root.left, target - root.data, path, result);
            pathSum(root.right, target - root.data, path, result);
        }
        path.remove(path.size() - 1);
    }
}
```"	"binary_tree(int)[root];int[sum];list(list(int))
[5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1];22;[[5, 4, 11, 2], [5, 8, 4, 5]]
[10, 5, 12, 4, 7];22;[[10, 5, 7], [10, 12]]
[10, 5, 12, 4, 7];15;[]
[5, 4, null, 3, null, 2, null, 1];15;[[5, 4, 3, 2, 1]]
[1, null, 2, null, 3, null, 4, null, 5];15;[[1, 2, 3, 4, 5]]
[5, null, 4, null, 3, null, 2, null, 1];16;[]
[16, null];16;[[16]]
[1, null];16;[]
[1, 2];3;[[1, 2]]
null;16;[]
[1, null];1;[[1]]
"
"Flatten Binary Tree To Linked List"	"Time : O(); Space: O()
 
Description: 
Given a binary tree, flatten it to a linked list in-place. 
For example, Given 
     1
    / \ 
   2   5 
  / \   \ 
 3   4   6 
 
The flattened tree should look like: 
1 \ 2 \ 3 \ 4 \ 5 \ 6
 
{@link: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ }"	"flatten"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public BinaryTreeNode<Integer> flatten(BinaryTreeNode<Integer> root) {
        return flattenTree(root);
    }

    public BinaryTreeNode<Integer> flattenTree(BinaryTreeNode<Integer> root) {
        if (root == null) {
            return null;
        }
        BinaryTreeNode<Integer> left = root.left;
        BinaryTreeNode<Integer> right = root.right;
        // ! don't forget to remove the left child
        root.left = null;
        root.right = flattenTree(left);

        BinaryTreeNode<Integer> node = root;
        // find the last right node
        while (node.right != null) {
            node = node.right;
        }

        node.right = flattenTree(right);
        return root;
    }
}
```"	"binary_tree(int)[root];binary_tree(int)
[1,2,5,3,4,null,6];[1,null,2,null,3,null,4,null,5,null,6]
"
"Triangle"	"Time : O(NM); Space: O(N)
 
Description:
Given a triangle, find the minimum path sum from top to bottom. Each 
step you may move to adjacent numbers on the row below. 
For example, given the following triangle 
[    [2], 
    [3,4], 
   [6,5,7], 
  [4,1,8,3] ] 
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). 
Note: 
Bonus point if you are able to do this using only O(n) extra space, 
where n is the total number of rows in the triangle.
 
{@link https://leetcode.com/problems/triangle/ }"	"minimumTotal"	"### Java
```java
public class Solution {

    public int minimumTotal(List<List<Integer>> a) {
        if (a.size() == 0 || a.get(0).size() == 0) {
            return 0;
        }
        int rows = a.size();
        int cols = a.get(rows - 1).size();
        int[] dp = new int[cols + 1];
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = 0; j < a.get(i).size(); j++) {
                dp[j] = a.get(i).get(j) + Math.min(dp[j], dp[j + 1]);
            }
        }
        return dp[0];
    }
}
```"	"list(list(int))[a];int
[[2],[3,4],[6,5,7],[4,1,8,3]];11
[[2]];2
[[1],[2,3]];3
"
"Best Time To Buy And Sell Stock"	"Time : O(N); Space: O(1)
 
Description: 
Say you have an array for which the ith element is the price           
of a given stock on day i.                                             
                                                                       
If you were only permitted to complete at most one transaction         
(ie, buy one and sell one share of the stock), design an algorithm     
to find the maximum profit.                                            
 
{@link https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ }"	"maxProfit"	"### Java
```java
public class Solution {

    public int maxProfit(int[] prices) {
        int result = 0; 
        // lowest price so far
        int minPrice = Integer.MAX_VALUE;
        for (int price : prices) {

            minPrice = Math.min(minPrice, price);

            result = Math.max(result, price - minPrice);

        }
        return result;
    }
}
```"	"array(int)[prices];int
[1, 2, 3, 4, 5];4
[5, 4, 3, 2, 1];0
[1, 4, 2, 6, 3, 3];5
[3, 2, 1, 3, 2, 7, 3];6
"
"Best Time To Buy And Sell Stock I I"	"Time : O(N); Space: O(1)
 
Say you have an array for which the ith element is the price of     
a given stock on day i.                                             
Design an algorithm to find the maximum profit. You may complete as 
many transactions as you like (ie, buy one and sell one share of the
stock multiple times). However, you may not engage in multiple
transactions at the same time (ie, you must sell the stock before
you buy again).
 
{@link https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ }"	"maxProfit"	"### Java
```java
public class Solution {

    /**
     * Decide whether to buy yesterday's stock only when we know today's price.
     * 
     * If stock's price is higher than yesterday, we then bought stock at yesterday,
     * and sell it today, so we can earn the revenue. Otherwise, we refuse
     * to buy stock at yesterday.
     */
    public int maxProfit(int[] prices) {
        int result = 0;
        int last = Integer.MAX_VALUE;
        for (int i = 0; i < prices.length; i++) {
            int price = prices[i];
            int diff = price - last;
            result += diff > 0 ? diff : 0;
            last = price;
        }
        return result;
    }
}
```"	"array(int)[prices];int
[ 1, 2, 3, 4, 5 ];4
[ 5, 4, 3, 2, 1 ];0
[ 1, 4, 2, 6, 3, 3 ];7
[ 3, 2, 1, 3, 2, 7, 3 ];7
[ 3 ];0
[ 7551982, 8124939, 4023780, 7868369, 4412570, 2542961, 7380261, 1164290, 7781065, 1164599, 2563492, 5354415, 4994454, 2627136, 5933501, 668219, 1821804, 7818378, 33654, 4167689, 8652323, 5750640, 9822437, 3466466, 554089, 6168826, 335687, 2466661, 8511732, 6288553, 2905889, 7747975, 3744045, 1545003, 1008624, 8041203, 7176125, 4321092, 714053, 7200073, 166697, 7814651, 3090485, 8318668, 6600364, 3352620, 2430137, 7685821, 1442555, 828955, 6540266, 5305436, 116568, 1883410, 7975347, 9629015, 4735259, 6559041, 1832532, 5840170, 6983732, 5886179, 1496505, 7241412, 144558, 9462840, 8579314, 2488436, 9677478, 7589124, 5636642, 2440601, 1767332, 2399786, 6299635, 8534665, 1367339, 805592, 5572668, 6990026, 8465261, 4808596, 7641452, 8464860, 3170126, 7403200, 6932907, 3776122, 1313688, 3992189, 2382116, 3886952, 349816, 1596435, 7353742, 9964868, 9882224, 3818546, 3885458, 1200559, 3910256, 7949895, 463872, 6392805, 9513226, 3427933, 3470571, 6225817, 552452, 5567651, 6414423, 6701681, 4725847, 894529, 8046603, 426263, 5280891, 9197661, 9764507, 1740413, 9530261, 9163599, 7561587, 5848442, 7312422, 4794268, 5793465, 5039382, 5147388, 7346933, 4697363, 6436473, 5159752, 2207985, 8256403, 8958858, 6099618, 2172252, 3063342, 4324166, 3919237, 8985768, 2703255, 2386343, 3064166, 247762, 7271683, 1812487, 7163753, 4635382, 449426, 2561592, 3746615, 8741199, 6696192, 606265, 5374062, 3065308, 6918398, 2956279, 8949324, 2804580, 3421479, 7846658, 8895839, 8277589, 1262596, 451779, 9972218, 6378556, 4216958, 7127258, 8593578, 326883, 4737513, 6578257, 7582654, 8675499, 9038961, 7902676, 8874020, 5513073, 631930, 912719, 8394492, 1508363, 455175, 9215635, 6813970, 2021710, 5673212, 184474, 4511247, 4653238, 2218883, 9669544, 295018, 3694660, 1709444, 4019025, 5047809, 45740, 1035395, 8159408, 1557286, 1304144, 6496263, 2094202, 9945315, 1905585, 1143081, 6994125, 9609830, 1077628, 3488222, 6299366, 7187139, 3883908, 7077292, 3210807, 7328762, 7695314, 1138834, 7689433, 5083719, 202831, 8138452, 5495064, 7543763, 1597085, 5429837, 8455839, 6925605, 6600884, 3571512, 3422637, 8911245, 3700762, 2338168, 6830853, 2539094, 490627, 2294717, 497349, 8297867, 7299269, 4769134, 285033, 4335917, 9908413, 152868, 2658658, 3525848, 1884044, 4953877, 8660374, 8989154, 888731, 7217408, 2614940, 7990455, 9779818, 1441488, 9605891, 4518756, 3705442, 9331226, 404585, 9011202, 7355000, 7461968, 6512552, 2689841, 2873446, 256454, 1068037, 8786859, 2323599, 3332506, 2361155, 7476810, 5605915, 5950352, 6491737, 8696129, 4637800, 4207476, 9334774, 840248, 9159149, 5201180, 7211332, 3135016, 8524857, 4566111, 7697488, 1833291, 7227481, 8289951, 2389102, 9102789, 8585135, 1869227, 4082835, 8447466, 4985240, 4176179 ];552236226
"
"Word Ladder"	"Time : O(); Space: O(N)
 
Description: 
Given two words (beginWord and endWord), and a dictionary, find the 
length of shortest transformation sequence from beginWord to endWord, 
such that: 
     Only one letter can be changed at a time 
     Each intermediate word must exist in the dictionary 
For example, 
Given: start = ""hit"" end = ""cog"" 
dict = [""hot"",""dot"",""dog"",""lot"",""log""] 
As one shortest transformation is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog"", 
return its length 5.
 
{@link https://leetcode.com/problems/word-ladder/ }"	"ladderLength"	"### Java
```java
public class Solution {

    // two-end BFS, construct graph from begin and end at the same time
    public int ladderLength(String beginWord, String endWord, List<String> wordDict) {
        int len = 1;
        Set<String> beginSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        Set<String> visited = new HashSet<>();
        beginSet.add(beginWord);
        endSet.add(endWord);
        visited.add(beginWord);
        visited.add(endWord);
        
        while (!beginSet.isEmpty() && !endSet.isEmpty()) {
            // add new words to smaller set to achieve better performance
            boolean isBeginSetSmall = beginSet.size() < endSet.size();
            Set<String> small = isBeginSetSmall ? beginSet : endSet;
            Set<String> big = isBeginSetSmall ? endSet : beginSet;
            Set<String> next = new HashSet<>();
            len++;
            for (String str : small) {
                // construct all possible words
                for (int i = 0; i < str.length(); i++) {
                    for (char ch = 'a'; ch <= 'z'; ch++) {
                        StringBuilder sb = new StringBuilder(str);
                        sb.setCharAt(i, ch);
                        String word = sb.toString();
                        if (big.contains(word)) {
                            return len;
                        }
                        if (wordDict.contains(word) && !visited.contains(word)) {
                            visited.add(word);
                            next.add(word);
                        }
                    }
                }
            }
            if (isBeginSetSmall) {
                beginSet = next;
            } else {
                endSet = next;
            }
        }
        return 0;
    }
}
```"	"string[beginWord];string[endWord];list(string)[wordDict];int
""hit"";""dog"";[""hot"",""dog""];0
""hit"";""cog"";[""hot"",""dot"",""dog"",""lot"",""log""];5
""hit"";""hit"";[""hot"",""dot"",""dog"",""lot"",""log""];2
""hot"";""dog"";[""hot"",""cog"",""dog"",""tot"",""hog"",""hop"",""pot"",""dot""];3
""red"";""tax"";[""ted"",""tex"",""red"",""tax"",""tad"",""den"",""rex"",""pee""];4
""nape"";""mild"";[ ""dose"", ""ends"", ""dine"", ""jars"", ""prow"", ""soap"", ""guns"", ""hops"", ""cray"", ""hove"", ""ella"", ""hour"", ""lens"", ""jive"", ""wiry"", ""earl"", ""mara"", ""part"", ""flue"", ""putt"", ""rory"", ""bull"", ""york"", ""ruts"", ""lily"", ""vamp"", ""bask"", ""peer"", ""boat"", ""dens"", ""lyre"", ""jets"", ""wide"", ""rile"", ""boos"", ""down"", ""path"", ""onyx"", ""mows"", ""toke"", ""soto"", ""dork"", ""nape"", ""mans"", ""loin"", ""jots"", ""male"", ""sits"", ""minn"", ""sale"", ""pets"", ""hugo"", ""woke"", ""suds"", ""rugs"", ""vole"", ""warp"", ""mite"", ""pews"", ""lips"", ""pals"", ""nigh"", ""sulk"", ""vice"", ""clod"", ""iowa"", ""gibe"", ""shad"", ""carl"", ""huns"", ""coot"", ""sera"", ""mils"", ""rose"", ""orly"", ""ford"", ""void"", ""time"", ""eloy"", ""risk"", ""veep"", ""reps"", ""dolt"", ""hens"", ""tray"", ""melt"", ""rung"", ""rich"", ""saga"", ""lust"", ""yews"", ""rode"", ""many"", ""cods"", ""rape"", ""last"", ""tile"", ""nosy"", ""take"", ""nope"", ""toni"", ""bank"", ""jock"", ""jody"", ""diss"", ""nips"", ""bake"", ""lima"", ""wore"", ""kins"", ""cult"", ""hart"", ""wuss"", ""tale"", ""sing"", ""lake"", ""bogy"", ""wigs"", ""kari"", ""magi"", ""bass"", ""pent"", ""tost"", ""fops"", ""bags"", ""duns"", ""will"", ""tart"", ""drug"", ""gale"", ""mold"", ""disk"", ""spay"", ""hows"", ""naps"", ""puss"", ""gina"", ""kara"", ""zorn"", ""boll"", ""cams"", ""boas"", ""rave"", ""sets"", ""lego"", ""hays"", ""judy"", ""chap"", ""live"", ""bahs"", ""ohio"", ""nibs"", ""cuts"", ""pups"", ""data"", ""kate"", ""rump"", ""hews"", ""mary"", ""stow"", ""fang"", ""bolt"", ""rues"", ""mesh"", ""mice"", ""rise"", ""rant"", ""dune"", ""jell"", ""laws"", ""jove"", ""bode"", ""sung"", ""nils"", ""vila"", ""mode"", ""hued"", ""cell"", ""fies"", ""swat"", ""wags"", ""nate"", ""wist"", ""honk"", ""goth"", ""told"", ""oise"", ""wail"", ""tels"", ""sore"", ""hunk"", ""mate"", ""luke"", ""tore"", ""bond"", ""bast"", ""vows"", ""ripe"", ""fond"", ""benz"", ""firs"", ""zeds"", ""wary"", ""baas"", ""wins"", ""pair"", ""tags"", ""cost"", ""woes"", ""buns"", ""lend"", ""bops"", ""code"", ""eddy"", ""siva"", ""oops"", ""toed"", ""bale"", ""hutu"", ""jolt"", ""rife"", ""darn"", ""tape"", ""bold"", ""cope"", ""cake"", ""wisp"", ""vats"", ""wave"", ""hems"", ""bill"", ""cord"", ""pert"", ""type"", ""kroc"", ""ucla"", ""albs"", ""yoko"", ""silt"", ""pock"", ""drub"", ""puny"", ""fads"", ""mull"", ""pray"", ""mole"", ""talc"", ""east"", ""slay"", ""jamb"", ""mill"", ""dung"", ""jack"", ""lynx"", ""nome"", ""leos"", ""lade"", ""sana"", ""tike"", ""cali"", ""toge"", ""pled"", ""mile"", ""mass"", ""leon"", ""sloe"", ""lube"", ""kans"", ""cory"", ""burs"", ""race"", ""toss"", ""mild"", ""tops"", ""maze"", ""city"", ""sadr"", ""bays"", ""poet"", ""volt"", ""laze"", ""gold"", ""zuni"", ""shea"", ""gags"", ""fist"", ""ping"", ""pope"", ""cora"", ""yaks"", ""cosy"", ""foci"", ""plan"", ""colo"", ""hume"", ""yowl"", ""craw"", ""pied"", ""toga"", ""lobs"", ""love"", ""lode"", ""duds"", ""bled"", ""juts"", ""gabs"", ""fink"", ""rock"", ""pant"", ""wipe"", ""pele"", ""suez"", ""nina"", ""ring"", ""okra"", ""warm"", ""lyle"", ""gape"", ""bead"", ""lead"", ""jane"", ""oink"", ""ware"", ""zibo"", ""inns"", ""mope"", ""hang"", ""made"", ""fobs"", ""gamy"", ""fort"", ""peak"", ""gill"", ""dino"", ""dina"", ""tier"" ];6
""zings"";""brown"";[ ""chump"", ""sours"", ""mcgee"", ""piers"", ""match"", ""folds"", ""rinse"", ""films"", ""small"", ""umbel"", ""assad"", ""morin"", ""plied"", ""basin"", ""moots"", ""blurb"", ""suits"", ""solve"", ""sooty"", ""fluky"", ""bombs"", ""nurse"", ""ceres"", ""lopes"", ""yucky"", ""ricks"", ""goads"", ""loses"", ""coyly"", ""marcy"", ""bonds"", ""niece"", ""cures"", ""sonic"", ""crows"", ""dicey"", ""gaped"", ""buggy"", ""riles"", ""homer"", ""fakir"", ""hello"", ""riper"", ""makes"", ""laked"", ""sinus"", ""fangs"", ""acton"", ""spiky"", ""salts"", ""boots"", ""skiff"", ""maker"", ""pence"", ""fells"", ""cedar"", ""kited"", ""raved"", ""flake"", ""jiffy"", ""tanks"", ""barns"", ""sized"", ""gluts"", ""amman"", ""jumps"", ""cavil"", ""quaff"", ""rents"", ""looms"", ""toner"", ""gibes"", ""aside"", ""drawn"", ""karin"", ""torte"", ""haded"", ""psych"", ""hacks"", ""jesus"", ""fumed"", ""lisle"", ""spays"", ""sumps"", ""beats"", ""tunas"", ""naked"", ""bathe"", ""gulfs"", ""karma"", ""snuff"", ""boast"", ""grins"", ""turds"", ""plant"", ""spicy"", ""risen"", ""tints"", ""tomas"", ""stand"", ""noses"", ""toxin"", ""sheep"", ""paddy"", ""abase"", ""jeeps"", ""dated"", ""tough"", ""timid"", ""forty"", ""kusch"", ""pones"", ""smack"", ""token"", ""havel"", ""vanes"", ""repay"", ""chums"", ""paved"", ""chimp"", ""spinx"", ""smirk"", ""pupas"", ""bares"", ""mites"", ""egged"", ""palsy"", ""gyros"", ""wolfe"", ""chips"", ""pouts"", ""johns"", ""barbs"", ""slunk"", ""hires"", ""seals"", ""rally"", ""tromp"", ""roads"", ""writs"", ""aches"", ""corny"", ""fiats"", ""hench"", ""gilts"", ""blake"", ""phony"", ""drams"", ""skimp"", ""suing"", ""horus"", ""hewer"", ""barfs"", ""hewed"", ""needs"", ""epsom"", ""knots"", ""tided"", ""befit"", ""eager"", ""melva"", ""coves"", ""plush"", ""pawed"", ""zebra"", ""gales"", ""blots"", ""foggy"", ""rooks"", ""comas"", ""laxly"", ""cries"", ""kirks"", ""monks"", ""magic"", ""fugue"", ""apter"", ""limos"", ""congo"", ""rosin"", ""seder"", ""bones"", ""holes"", ""fated"", ""gamay"", ""snags"", ""wimpy"", ""rites"", ""gilds"", ""slink"", ""staph"", ""sioux"", ""bends"", ""wilma"", ""warts"", ""reeds"", ""yolks"", ""lover"", ""demon"", ""salve"", ""hulas"", ""shard"", ""worst"", ""leach"", ""omits"", ""flint"", ""tines"", ""julio"", ""trots"", ""silly"", ""cocks"", ""gleam"", ""react"", ""camps"", ""nicks"", ""bored"", ""coded"", ""swine"", ""scope"", ""aloes"", ""south"", ""hands"", ""rainy"", ""david"", ""newer"", ""ferns"", ""jelly"", ""index"", ""gibbs"", ""truly"", ""tubes"", ""opera"", ""raven"", ""noyce"", ""whims"", ""titus"", ""hared"", ""vined"", ""dealt"", ""slats"", ""erick"", ""rolls"", ""breed"", ""udder"", ""oozed"", ""prays"", ""tsars"", ""harry"", ""shelf"", ""norms"", ""larks"", ""hazes"", ""brice"", ""gifts"", ""units"", ""veeps"", ""dumas"", ""mommy"", ""spock"", ""dotty"", ""molls"", ""slobs"", ""diane"", ""buddy"", ""boost"", ""ginny"", ""rends"", ""marks"", ""timur"", ""bands"", ""genes"", ""slews"", ""leeds"", ""karyn"", ""mobil"", ""mixes"", ""ronny"", ""sadly"", ""rinks"", ""smash"", ""baled"", ""pulpy"", ""toils"", ""yards"", ""piing"", ""dried"", ""veils"", ""spook"", ""snaky"", ""sizer"", ""spout"", ""percy"", ""sheol"", ""blank"", ""waxes"", ""herod"", ""attar"", ""doped"", ""polls"", ""banes"", ""penny"", ""knelt"", ""laded"", ""manic"", ""acids"", ""squat"", ""jerry"", ""stony"", ""woofs"", ""idles"", ""bruin"", ""carla"", ""sheik"", ""hodge"", ""goody"", ""merge"", ""nicer"", ""scums"", ""evens"", ""lames"", ""wends"", ""midge"", ""jives"", ""tuner"", ""reins"", ""boars"", ""fryer"", ""realm"", ""dyson"", ""narks"", ""torts"", ""yawed"", ""waked"", ""cress"", ""curvy"", ""bongs"", ""fared"", ""jilts"", ""liens"", ""ducat"", ""shaft"", ""pesos"", ""dulls"", ""donna"", ""potty"", ""winks"", ""marsh"", ""giddy"", ""tiffs"", ""scoot"", ""nifty"", ""daisy"", ""slots"", ""stacy"", ""colby"", ""skims"", ""malls"", ""sifts"", ""jinns"", ""flank"", ""molar"", ""hatch"", ""wiped"", ""taped"", ""clink"", ""brims"", ""credo"", ""fezes"", ""molds"", ""finds"", ""quids"", ""terra"", ""damns"", ""dusky"", ""wanes"", ""musty"", ""barer"", ""snare"", ""honey"", ""piked"", ""wiser"", ""elvin"", ""dolly"", ""fetal"", ""ships"", ""reign"", ""cause"", ""caved"", ""mecca"", ""blink"", ""close"", ""birth"", ""pints"", ""reefs"", ""amado"", ""comae"", ""waite"", ""willy"", ""lorry"", ""nixed"", ""quire"", ""napes"", ""voted"", ""eldon"", ""nappy"", ""myles"", ""laser"", ""pesky"", ""leant"", ""septa"", ""mucks"", ""agree"", ""sworn"", ""lofty"", ""slush"", ""holst"", ""tevet"", ""wases"", ""cheer"", ""torah"", ""treks"", ""purge"", ""class"", ""popes"", ""roans"", ""curve"", ""quads"", ""magma"", ""drier"", ""hales"", ""chess"", ""prigs"", ""sivan"", ""romes"", ""finch"", ""peels"", ""mousy"", ""atria"", ""offer"", ""coals"", ""crash"", ""tauts"", ""oinks"", ""dazed"", ""flaps"", ""truck"", ""treed"", ""colas"", ""petty"", ""marty"", ""cadet"", ""clips"", ""zones"", ""wooed"", ""haves"", ""grays"", ""gongs"", ""minis"", ""macaw"", ""horde"", ""witch"", ""flows"", ""heady"", ""fuels"", ""conks"", ""lifts"", ""tumid"", ""husks"", ""irony"", ""pines"", ""glops"", ""fonds"", ""covey"", ""chino"", ""riggs"", ""tonya"", ""slavs"", ""caddy"", ""poled"", ""blent"", ""mired"", ""whose"", ""scows"", ""forte"", ""hikes"", ""riped"", ""knobs"", ""wroth"", ""bagel"", ""basks"", ""nines"", ""scams"", ""males"", ""holed"", ""solid"", ""farms"", ""glaxo"", ""poise"", ""drays"", ""ryder"", ""slash"", ""rajas"", ""goons"", ""bowed"", ""shirt"", ""blurs"", ""fussy"", ""rills"", ""loren"", ""helps"", ""feels"", ""fiefs"", ""hines"", ""balms"", ""blobs"", ""fiord"", ""light"", ""dinky"", ""maids"", ""sagas"", ""joked"", ""pyxed"", ""lilly"", ""leers"", ""galls"", ""malts"", ""minos"", ""ionic"", ""lower"", ""peale"", ""ratty"", ""tuber"", ""newed"", ""whirl"", ""eases"", ""wests"", ""herds"", ""clods"", ""floes"", ""skate"", ""weeds"", ""tones"", ""rangy"", ""kings"", ""adder"", ""pitts"", ""smith"", ""coats"", ""lenny"", ""sorta"", ""floss"", ""looks"", ""angie"", ""peppy"", ""upper"", ""darin"", ""white"", ""lofts"", ""clint"", ""jared"", ""heros"", ""ruler"", ""tonia"", ""sexed"", ""grail"", ""villa"", ""topic"", ""kenny"", ""dopes"", ""hoots"", ""boobs"", ""gerry"", ""eries"", ""lyres"", ""lunch"", ""glove"", ""cumin"", ""harms"", ""races"", ""today"", ""crust"", ""track"", ""mends"", ""snout"", ""shark"", ""iliad"", ""shrew"", ""dorky"", ""monty"", ""dodge"", ""toted"", ""worse"", ""dream"", ""weird"", ""gaunt"", ""damon"", ""rimes"", ""layer"", ""salem"", ""bards"", ""dills"", ""hobby"", ""gives"", ""shall"", ""crazy"", ""brace"", ""faxed"", ""pools"", ""foamy"", ""viral"", ""strop"", ""liver"", ""ceded"", ""jolts"", ""jonah"", ""tight"", ""lilia"", ""hussy"", ""mutts"", ""crate"", ""girls"", ""marge"", ""hypos"", ""mewls"", ""bulls"", ""gazes"", ""wands"", ""avior"", ""sonya"", ""slick"", ""clump"", ""cater"", ""aural"", ""agave"", ""grief"", ""shana"", ""fices"", ""moans"", ""grape"", ""fetid"", ""jenna"", ""humus"", ""poesy"", ""cooks"", ""still"", ""lease"", ""wanda"", ""oddly"", ""areas"", ""frats"", ""imply"", ""files"", ""ramon"", ""seuss"", ""hubby"", ""wakes"", ""rural"", ""nodal"", ""doric"", ""carry"", ""chefs"", ""fails"", ""klaus"", ""shine"", ""filly"", ""yawls"", ""brows"", ""cabby"", ""favor"", ""styli"", ""filed"", ""jinni"", ""ferry"", ""balls"", ""lakes"", ""voled"", ""drone"", ""lusty"", ""tansy"", ""among"", ""trail"", ""liven"", ""slake"", ""madge"", ""steps"", ""donne"", ""sties"", ""picks"", ""lacks"", ""jumpy"", ""meade"", ""bogie"", ""bauer"", ""scene"", ""lubes"", ""brigs"", ""label"", ""fines"", ""grebe"", ""limns"", ""mouse"", ""ensue"", ""swags"", ""bunch"", ""kayla"", ""micky"", ""sneak"", ""bulbs"", ""camus"", ""yours"", ""aisha"", ""dunne"", ""volta"", ""cores"", ""dweeb"", ""libby"", ""flees"", ""shops"", ""bided"", ""satan"", ""socks"", ""draws"", ""golfs"", ""taunt"", ""genus"", ""belts"", ""orbit"", ""taxis"", ""hinds"", ""fakes"", ""chart"", ""wings"", ""words"", ""digit"", ""copse"", ""deena"", ""perry"", ""sanes"", ""huffy"", ""chung"", ""lucks"", ""fills"", ""selma"", ""wafts"", ""pecks"", ""trite"", ""combs"", ""sooth"", ""weary"", ""salty"", ""brews"", ""kooky"", ""robby"", ""loans"", ""props"", ""huang"", ""marry"", ""swabs"", ""tinny"", ""mince"", ""japed"", ""ellis"", ""lowed"", ""newly"", ""loath"", ""drown"", ""loved"", ""joker"", ""lints"", ""kinky"", ""skits"", ""feats"", ""hiker"", ""doles"", ""every"", ""dolby"", ""stirs"", ""lobed"", ""fusty"", ""cozen"", ""vader"", ""byron"", ""dozes"", ""slows"", ""bethe"", ""ploys"", ""misty"", ""binds"", ""bumpy"", ""spurs"", ""wolfs"", ""ernie"", ""nails"", ""prows"", ""seeds"", ""visas"", ""dowse"", ""pores"", ""jocks"", ""cower"", ""hoofs"", ""mined"", ""marat"", ""gorge"", ""souse"", ""clack"", ""liter"", ""jewel"", ""hates"", ""boats"", ""stark"", ""blabs"", ""murks"", ""woken"", ""stomp"", ""peeks"", ""perky"", ""pasta"", ""goats"", ""hocks"", ""kinks"", ""gushy"", ""outdo"", ""gelds"", ""foxes"", ""fives"", ""sybil"", ""upton"", ""taine"", ""helga"", ""mauls"", ""gills"", ""grows"", ""bauds"", ""aloft"", ""cline"", ""payer"", ""pinch"", ""thorn"", ""slits"", ""thumb"", ""biked"", ""cowls"", ""grams"", ""disks"", ""belly"", ""randy"", ""hunts"", ""prize"", ""minty"", ""river"", ""chevy"", ""gages"", ""cysts"", ""years"", ""scoff"", ""becky"", ""inert"", ""abler"", ""bevel"", ""dyers"", ""tonne"", ""glows"", ""ocean"", ""spits"", ""bowen"", ""tings"", ""baths"", ""goals"", ""whiny"", ""merry"", ""fares"", ""leila"", ""cairo"", ""honor"", ""verge"", ""teary"", ""pimps"", ""sarah"", ""meets"", ""tamed"", ""bumps"", ""alias"", ""pings"", ""wears"", ""dante"", ""snore"", ""ruled"", ""savor"", ""gapes"", ""loony"", ""chaps"", ""froth"", ""fancy"", ""herbs"", ""cutes"", ""crowd"", ""ghana"", ""teddy"", ""abate"", ""scalp"", ""mules"", ""patsy"", ""minks"", ""shuck"", ""billy"", ""helen"", ""stain"", ""moles"", ""jodie"", ""homed"", ""stack"", ""niger"", ""denny"", ""kinds"", ""elves"", ""waled"", ""rover"", ""medan"", ""churn"", ""whizz"", ""green"", ""reach"", ""lajos"", ""mates"", ""ditch"", ""grads"", ""start"", ""press"", ""rimed"", ""hells"", ""vised"", ""slums"", ""notes"", ""canes"", ""taper"", ""camry"", ""weans"", ""sinks"", ""arise"", ""crown"", ""prier"", ""ramps"", ""wotan"", ""chars"", ""mussy"", ""rodes"", ""sonar"", ""cheri"", ""sired"", ""snell"", ""basel"", ""eider"", ""sades"", ""times"", ""ovule"", ""gusto"", ""myrna"", ""gabby"", ""dully"", ""spake"", ""beast"", ""towns"", ""allay"", ""gaged"", ""smell"", ""skids"", ""clone"", ""slack"", ""pooch"", ""vulva"", ""arson"", ""blown"", ""kongo"", ""maize"", ""thick"", ""brags"", ""spore"", ""soles"", ""trial"", ""snort"", ""price"", ""bowel"", ""stoke"", ""pents"", ""hutch"", ""flack"", ""arced"", ""cubic"", ""hiram"", ""tongs"", ""lades"", ""coons"", ""finer"", ""games"", ""unpin"", ""vests"", ""slabs"", ""santa"", ""tamer"", ""asian"", ""tease"", ""miked"", ""lodes"", ""vents"", ""leafy"", ""stats"", ""shuts"", ""bully"", ""edith"", ""bloch"", ""corps"", ""bloom"", ""doses"", ""coins"", ""skips"", ""gains"", ""hided"", ""coops"", ""ninja"", ""pills"", ""raves"", ""hanks"", ""seres"", ""ewing"", ""bests"", ""wrath"", ""burgs"", ""thrum"", ""cabin"", ""daren"", ""imams"", ""junks"", ""brood"", ""bacon"", ""creel"", ""gazed"", ""teats"", ""halos"", ""gypsy"", ""ether"", ""train"", ""tiles"", ""bulks"", ""bolls"", ""added"", ""roger"", ""sites"", ""balmy"", ""tilts"", ""swoop"", ""jules"", ""bawdy"", ""mango"", ""stoop"", ""girts"", ""costs"", ""lemur"", ""yucks"", ""swazi"", ""okays"", ""piped"", ""ticks"", ""tomes"", ""filch"", ""depth"", ""meals"", ""coots"", ""bites"", ""pansy"", ""spelt"", ""leeks"", ""hills"", ""drops"", ""verde"", ""japes"", ""holds"", ""bangs"", ""maxed"", ""plume"", ""frets"", ""lymph"", ""modes"", ""twits"", ""devon"", ""cawed"", ""putty"", ""sowed"", ""likes"", ""quips"", ""board"", ""loxed"", ""slags"", ""dilly"", ""refit"", ""saved"", ""takes"", ""meter"", ""prove"", ""spacy"", ""poach"", ""cilia"", ""pears"", ""lists"", ""gated"", ""verdi"", ""shave"", ""notch"", ""culls"", ""shams"", ""weedy"", ""gaols"", ""hoops"", ""kraft"", ""burro"", ""roles"", ""rummy"", ""click"", ""plots"", ""mitty"", ""yanks"", ""drool"", ""papal"", ""rearm"", ""prose"", ""fucks"", ""berra"", ""salas"", ""tents"", ""flues"", ""loves"", ""poker"", ""parry"", ""polyp"", ""agent"", ""flown"", ""walls"", ""studs"", ""troll"", ""baron"", ""earle"", ""panda"", ""wiley"", ""raged"", ""sexes"", ""berne"", ""vista"", ""rojas"", ""cones"", ""byway"", ""vases"", ""wines"", ""forth"", ""freya"", ""gully"", ""fires"", ""sails"", ""dusts"", ""terse"", ""booed"", ""stung"", ""basic"", ""saver"", ""basis"", ""hmong"", ""brawn"", ""pured"", ""locks"", ""downs"", ""punts"", ""rhine"", ""metes"", ""title"", ""shims"", ""bents"", ""blows"", ""harte"", ""boyle"", ""peach"", ""posts"", ""olson"", ""might"", ""flier"", ""rubes"", ""lingo"", ""tarts"", ""nexus"", ""woman"", ""mains"", ""finis"", ""mikes"", ""pleas"", ""trams"", ""shawl"", ""gunny"", ""sleds"", ""ruder"", ""aries"", ""usher"", ""refed"", ""toady"", ""caper"", ""tries"", ""gimpy"", ""doors"", ""thieu"", ""deere"", ""mucky"", ""rests"", ""mares"", ""cards"", ""bouts"", ""dines"", ""rants"", ""giles"", ""flunk"", ""enact"", ""derek"", ""dover"", ""conan"", ""mooed"", ""fiver"", ""kaput"", ""enrol"", ""payed"", ""feint"", ""miner"", ""shyer"", ""whelk"", ""perch"", ""furor"", ""hayes"", ""tammy"", ""caves"", ""maims"", ""cairn"", ""tract"", ""legal"", ""adler"", ""veldt"", ""basal"", ""spiny"", ""surer"", ""bolds"", ""grove"", ""heaps"", ""noway"", ""pokes"", ""tubed"", ""beaks"", ""loots"", ""drawl"", ""jones"", ""typed"", ""funny"", ""cells"", ""beaus"", ""bayed"", ""rears"", ""seats"", ""hazed"", ""flubs"", ""maura"", ""goths"", ""rumba"", ""morse"", ""fumes"", ""slide"", ""snoot"", ""music"", ""sully"", ""perth"", ""pocks"", ""mills"", ""lopez"", ""sacks"", ""stine"", ""gawks"", ""gavel"", ""rains"", ""wound"", ""hares"", ""guild"", ""leger"", ""foxed"", ""craws"", ""rinds"", ""faced"", ""groom"", ""lully"", ""boded"", ""lends"", ""serge"", ""sword"", ""faked"", ""envoy"", ""stick"", ""tumor"", ""riser"", ""bolts"", ""trued"", ""gasps"", ""thoth"", ""veers"", ""verbs"", ""boles"", ""lunar"", ""taxes"", ""vexes"", ""pucks"", ""welsh"", ""pelts"", ""shift"", ""booth"", ""smote"", ""spied"", ""gnawn"", ""crete"", ""dough"", ""tasha"", ""timed"", ""wired"", ""state"", ""hears"", ""lauds"", ""wills"", ""dummy"", ""basil"", ""belie"", ""calls"", ""crams"", ""matts"", ""gybes"", ""limed"", ""snots"", ""moder"", ""faces"", ""sibyl"", ""spare"", ""crops"", ""drips"", ""frown"", ""doggy"", ""pearl"", ""reese"", ""curls"", ""earns"", ""poles"", ""tiara"", ""risks"", ""lethe"", ""titan"", ""tucks"", ""trace"", ""vises"", ""prick"", ""sears"", ""ogled"", ""preps"", ""livid"", ""kicky"", ""candy"", ""weeps"", ""tapes"", ""cokes"", ""foods"", ""wards"", ""coifs"", ""shirk"", ""elsie"", ""ketch"", ""trunk"", ""goofs"", ""kodak"", ""toyed"", ""lance"", ""whale"", ""soups"", ""roars"", ""poxed"", ""tombs"", ""noons"", ""hindi"", ""basie"", ""hoffa"", ""bayou"", ""tests"", ""roots"", ""shove"", ""hoses"", ""doled"", ""tempt"", ""kilos"", ""velma"", ""avers"", ""dorks"", ""comic"", ""fanny"", ""poops"", ""sicks"", ""leary"", ""merer"", ""finks"", ""garbo"", ""cains"", ""mimed"", ""sates"", ""celli"", ""flats"", ""grown"", ""broth"", ""augur"", ""chaos"", ""sangs"", ""chide"", ""barks"", ""guide"", ""mewed"", ""synch"", ""rings"", ""scrap"", ""zings"", ""howls"", ""duded"", ""noemi"", ""geeks"", ""nexis"", ""comte"", ""helot"", ""whams"", ""brand"", ""hogan"", ""moira"", ""trips"", ""loges"", ""baits"", ""winds"", ""marla"", ""never"", ""louis"", ""anted"", ""helix"", ""morns"", ""heeds"", ""crags"", ""rowdy"", ""becks"", ""venue"", ""diary"", ""stoat"", ""feeds"", ""kiths"", ""riled"", ""drags"", ""lucia"", ""deeps"", ""sends"", ""fonts"", ""swing"", ""fence"", ""stout"", ""trice"", ""taker"", ""drugs"", ""babel"", ""plows"", ""pends"", ""sloes"", ""gents"", ""brawl"", ""arabs"", ""leaps"", ""flied"", ""fulls"", ""meats"", ""megan"", ""burch"", ""oscar"", ""evict"", ""betsy"", ""lasts"", ""ethos"", ""mavis"", ""petal"", ""fever"", ""alone"", ""snips"", ""assay"", ""rocks"", ""talon"", ""grass"", ""clive"", ""discs"", ""wrapt"", ""calfs"", ""razed"", ""learn"", ""bruce"", ""midst"", ""swear"", ""merck"", ""meyer"", ""funks"", ""lobby"", ""fears"", ""decay"", ""sedge"", ""alien"", ""reaps"", ""koran"", ""range"", ""enter"", ""lepke"", ""honed"", ""gallo"", ""staid"", ""joist"", ""lines"", ""paler"", ""fined"", ""sorts"", ""piper"", ""highs"", ""busch"", ""dario"", ""north"", ""ashed"", ""sands"", ""songs"", ""rakes"", ""garza"", ""pinks"", ""rival"", ""leann"", ""allow"", ""golds"", ""hilts"", ""berry"", ""hicks"", ""idler"", ""weiss"", ""cider"", ""desks"", ""skies"", ""hulls"", ""warns"", ""datum"", ""brown"", ""leapt"", ""dregs"", ""dozed"", ""stump"", ""reply"", ""finny"", ""clues"", ""diode"", ""dicks"", ""rabid"", ""moors"", ""limbs"", ""gulls"", ""scary"", ""dungs"", ""liege"", ""vicky"", ""nigel"", ""peeps"", ""dolls"", ""blame"", ""sings"", ""wants"", ""fuzes"", ""proud"", ""bungs"", ""seams"", ""bingo"", ""buffs"", ""shire"", ""decks"", ""hosed"", ""scots"", ""pumas"", ""jazzy"", ""books"", ""ellie"", ""hayed"", ""snowy"", ""twill"", ""links"", ""coped"", ""spats"", ""reyes"", ""piles"", ""hovel"", ""reads"", ""wryer"", ""patty"", ""sling"", ""oneal"", ""waves"", ""gorse"", ""ofter"", ""teams"", ""strep"", ""mores"", ""daily"", ""spoil"", ""limes"", ""foots"", ""dells"", ""hakes"", ""danny"", ""furls"", ""flaws"", ""tarot"", ""dusty"", ""potts"", ""tells"", ""pager"", ""claps"", ""serra"", ""josie"", ""award"", ""pewee"", ""snack"", ""lobes"", ""damps"", ""tanya"", ""lures"", ""mushy"", ""hertz"", ""caret"", ""marco"", ""parks"", ""pithy"", ""synge"", ""spoon"", ""troth"", ""drama"", ""bleak"", ""lidia"", ""banns"", ""forms"", ""iambs"", ""crick"", ""patel"", ""mercy"", ""waded"" ];12
""sand"";""acne"";[ ""slit"", ""bunk"", ""wars"", ""ping"", ""viva"", ""wynn"", ""wows"", ""irks"", ""gang"", ""pool"", ""mock"", ""fort"", ""heel"", ""send"", ""ship"", ""cols"", ""alec"", ""foal"", ""nabs"", ""gaze"", ""giza"", ""mays"", ""dogs"", ""karo"", ""cums"", ""jedi"", ""webb"", ""lend"", ""mire"", ""jose"", ""catt"", ""grow"", ""toss"", ""magi"", ""leis"", ""bead"", ""kara"", ""hoof"", ""than"", ""ires"", ""baas"", ""vein"", ""kari"", ""riga"", ""oars"", ""gags"", ""thug"", ""yawn"", ""wive"", ""view"", ""germ"", ""flab"", ""july"", ""tuck"", ""rory"", ""bean"", ""feed"", ""rhee"", ""jeez"", ""gobs"", ""lath"", ""desk"", ""yoko"", ""cute"", ""zeus"", ""thus"", ""dims"", ""link"", ""dirt"", ""mara"", ""disc"", ""limy"", ""lewd"", ""maud"", ""duly"", ""elsa"", ""hart"", ""rays"", ""rues"", ""camp"", ""lack"", ""okra"", ""tome"", ""math"", ""plug"", ""monk"", ""orly"", ""friz"", ""hogs"", ""yoda"", ""poop"", ""tick"", ""plod"", ""cloy"", ""pees"", ""imps"", ""lead"", ""pope"", ""mall"", ""frey"", ""been"", ""plea"", ""poll"", ""male"", ""teak"", ""soho"", ""glob"", ""bell"", ""mary"", ""hail"", ""scan"", ""yips"", ""like"", ""mull"", ""kory"", ""odor"", ""byte"", ""kaye"", ""word"", ""honk"", ""asks"", ""slid"", ""hopi"", ""toke"", ""gore"", ""flew"", ""tins"", ""mown"", ""oise"", ""hall"", ""vega"", ""sing"", ""fool"", ""boat"", ""bobs"", ""lain"", ""soft"", ""hard"", ""rots"", ""sees"", ""apex"", ""chan"", ""told"", ""woos"", ""unit"", ""scow"", ""gilt"", ""beef"", ""jars"", ""tyre"", ""imus"", ""neon"", ""soap"", ""dabs"", ""rein"", ""ovid"", ""hose"", ""husk"", ""loll"", ""asia"", ""cope"", ""tail"", ""hazy"", ""clad"", ""lash"", ""sags"", ""moll"", ""eddy"", ""fuel"", ""lift"", ""flog"", ""land"", ""sigh"", ""saks"", ""sail"", ""hook"", ""visa"", ""tier"", ""maws"", ""roeg"", ""gila"", ""eyes"", ""noah"", ""hypo"", ""tore"", ""eggs"", ""rove"", ""chap"", ""room"", ""wait"", ""lurk"", ""race"", ""host"", ""dada"", ""lola"", ""gabs"", ""sobs"", ""joel"", ""keck"", ""axed"", ""mead"", ""gust"", ""laid"", ""ends"", ""oort"", ""nose"", ""peer"", ""kept"", ""abet"", ""iran"", ""mick"", ""dead"", ""hags"", ""tens"", ""gown"", ""sick"", ""odis"", ""miro"", ""bill"", ""fawn"", ""sumo"", ""kilt"", ""huge"", ""ores"", ""oran"", ""flag"", ""tost"", ""seth"", ""sift"", ""poet"", ""reds"", ""pips"", ""cape"", ""togo"", ""wale"", ""limn"", ""toll"", ""ploy"", ""inns"", ""snag"", ""hoes"", ""jerk"", ""flux"", ""fido"", ""zane"", ""arab"", ""gamy"", ""raze"", ""lank"", ""hurt"", ""rail"", ""hind"", ""hoot"", ""dogy"", ""away"", ""pest"", ""hoed"", ""pose"", ""lose"", ""pole"", ""alva"", ""dino"", ""kind"", ""clan"", ""dips"", ""soup"", ""veto"", ""edna"", ""damp"", ""gush"", ""amen"", ""wits"", ""pubs"", ""fuzz"", ""cash"", ""pine"", ""trod"", ""gunk"", ""nude"", ""lost"", ""rite"", ""cory"", ""walt"", ""mica"", ""cart"", ""avow"", ""wind"", ""book"", ""leon"", ""life"", ""bang"", ""draw"", ""leek"", ""skis"", ""dram"", ""ripe"", ""mine"", ""urea"", ""tiff"", ""over"", ""gale"", ""weir"", ""defy"", ""norm"", ""tull"", ""whiz"", ""gill"", ""ward"", ""crag"", ""when"", ""mill"", ""firs"", ""sans"", ""flue"", ""reid"", ""ekes"", ""jain"", ""mutt"", ""hems"", ""laps"", ""piss"", ""pall"", ""rowe"", ""prey"", ""cull"", ""knew"", ""size"", ""wets"", ""hurl"", ""wont"", ""suva"", ""girt"", ""prys"", ""prow"", ""warn"", ""naps"", ""gong"", ""thru"", ""livy"", ""boar"", ""sade"", ""amok"", ""vice"", ""slat"", ""emir"", ""jade"", ""karl"", ""loyd"", ""cerf"", ""bess"", ""loss"", ""rums"", ""lats"", ""bode"", ""subs"", ""muss"", ""maim"", ""kits"", ""thin"", ""york"", ""punt"", ""gays"", ""alpo"", ""aids"", ""drag"", ""eras"", ""mats"", ""pyre"", ""clot"", ""step"", ""oath"", ""lout"", ""wary"", ""carp"", ""hums"", ""tang"", ""pout"", ""whip"", ""fled"", ""omar"", ""such"", ""kano"", ""jake"", ""stan"", ""loop"", ""fuss"", ""mini"", ""byrd"", ""exit"", ""fizz"", ""lire"", ""emil"", ""prop"", ""noes"", ""awed"", ""gift"", ""soli"", ""sale"", ""gage"", ""orin"", ""slur"", ""limp"", ""saar"", ""arks"", ""mast"", ""gnat"", ""port"", ""into"", ""geed"", ""pave"", ""awls"", ""cent"", ""cunt"", ""full"", ""dint"", ""hank"", ""mate"", ""coin"", ""tars"", ""scud"", ""veer"", ""coax"", ""bops"", ""uris"", ""loom"", ""shod"", ""crib"", ""lids"", ""drys"", ""fish"", ""edit"", ""dick"", ""erna"", ""else"", ""hahs"", ""alga"", ""moho"", ""wire"", ""fora"", ""tums"", ""ruth"", ""bets"", ""duns"", ""mold"", ""mush"", ""swop"", ""ruby"", ""bolt"", ""nave"", ""kite"", ""ahem"", ""brad"", ""tern"", ""nips"", ""whew"", ""bait"", ""ooze"", ""gino"", ""yuck"", ""drum"", ""shoe"", ""lobe"", ""dusk"", ""cult"", ""paws"", ""anew"", ""dado"", ""nook"", ""half"", ""lams"", ""rich"", ""cato"", ""java"", ""kemp"", ""vain"", ""fees"", ""sham"", ""auks"", ""gish"", ""fire"", ""elam"", ""salt"", ""sour"", ""loth"", ""whit"", ""yogi"", ""shes"", ""scam"", ""yous"", ""lucy"", ""inez"", ""geld"", ""whig"", ""thee"", ""kelp"", ""loaf"", ""harm"", ""tomb"", ""ever"", ""airs"", ""page"", ""laud"", ""stun"", ""paid"", ""goop"", ""cobs"", ""judy"", ""grab"", ""doha"", ""crew"", ""item"", ""fogs"", ""tong"", ""blip"", ""vest"", ""bran"", ""wend"", ""bawl"", ""feel"", ""jets"", ""mixt"", ""tell"", ""dire"", ""devi"", ""milo"", ""deng"", ""yews"", ""weak"", ""mark"", ""doug"", ""fare"", ""rigs"", ""poke"", ""hies"", ""sian"", ""suez"", ""quip"", ""kens"", ""lass"", ""zips"", ""elva"", ""brat"", ""cosy"", ""teri"", ""hull"", ""spun"", ""russ"", ""pupa"", ""weed"", ""pulp"", ""main"", ""grim"", ""hone"", ""cord"", ""barf"", ""olav"", ""gaps"", ""rote"", ""wilt"", ""lars"", ""roll"", ""balm"", ""jana"", ""give"", ""eire"", ""faun"", ""suck"", ""kegs"", ""nita"", ""weer"", ""tush"", ""spry"", ""loge"", ""nays"", ""heir"", ""dope"", ""roar"", ""peep"", ""nags"", ""ates"", ""bane"", ""seas"", ""sign"", ""fred"", ""they"", ""lien"", ""kiev"", ""fops"", ""said"", ""lawn"", ""lind"", ""miff"", ""mass"", ""trig"", ""sins"", ""furl"", ""ruin"", ""sent"", ""cray"", ""maya"", ""clog"", ""puns"", ""silk"", ""axis"", ""grog"", ""jots"", ""dyer"", ""mope"", ""rand"", ""vend"", ""keen"", ""chou"", ""dose"", ""rain"", ""eats"", ""sped"", ""maui"", ""evan"", ""time"", ""todd"", ""skit"", ""lief"", ""sops"", ""outs"", ""moot"", ""faze"", ""biro"", ""gook"", ""fill"", ""oval"", ""skew"", ""veil"", ""born"", ""slob"", ""hyde"", ""twin"", ""eloy"", ""beat"", ""ergs"", ""sure"", ""kobe"", ""eggo"", ""hens"", ""jive"", ""flax"", ""mons"", ""dunk"", ""yest"", ""begs"", ""dial"", ""lodz"", ""burp"", ""pile"", ""much"", ""dock"", ""rene"", ""sago"", ""racy"", ""have"", ""yalu"", ""glow"", ""move"", ""peps"", ""hods"", ""kins"", ""salk"", ""hand"", ""cons"", ""dare"", ""myra"", ""sega"", ""type"", ""mari"", ""pelt"", ""hula"", ""gulf"", ""jugs"", ""flay"", ""fest"", ""spat"", ""toms"", ""zeno"", ""taps"", ""deny"", ""swag"", ""afro"", ""baud"", ""jabs"", ""smut"", ""egos"", ""lara"", ""toes"", ""song"", ""fray"", ""luis"", ""brut"", ""olen"", ""mere"", ""ruff"", ""slum"", ""glad"", ""buds"", ""silt"", ""rued"", ""gelt"", ""hive"", ""teem"", ""ides"", ""sink"", ""ands"", ""wisp"", ""omen"", ""lyre"", ""yuks"", ""curb"", ""loam"", ""darn"", ""liar"", ""pugs"", ""pane"", ""carl"", ""sang"", ""scar"", ""zeds"", ""claw"", ""berg"", ""hits"", ""mile"", ""lite"", ""khan"", ""erik"", ""slug"", ""loon"", ""dena"", ""ruse"", ""talk"", ""tusk"", ""gaol"", ""tads"", ""beds"", ""sock"", ""howe"", ""gave"", ""snob"", ""ahab"", ""part"", ""meir"", ""jell"", ""stir"", ""tels"", ""spit"", ""hash"", ""omit"", ""jinx"", ""lyra"", ""puck"", ""laue"", ""beep"", ""eros"", ""owed"", ""cede"", ""brew"", ""slue"", ""mitt"", ""jest"", ""lynx"", ""wads"", ""gena"", ""dank"", ""volt"", ""gray"", ""pony"", ""veld"", ""bask"", ""fens"", ""argo"", ""work"", ""taxi"", ""afar"", ""boon"", ""lube"", ""pass"", ""lazy"", ""mist"", ""blot"", ""mach"", ""poky"", ""rams"", ""sits"", ""rend"", ""dome"", ""pray"", ""duck"", ""hers"", ""lure"", ""keep"", ""gory"", ""chat"", ""runt"", ""jams"", ""lays"", ""posy"", ""bats"", ""hoff"", ""rock"", ""keri"", ""raul"", ""yves"", ""lama"", ""ramp"", ""vote"", ""jody"", ""pock"", ""gist"", ""sass"", ""iago"", ""coos"", ""rank"", ""lowe"", ""vows"", ""koch"", ""taco"", ""jinn"", ""juno"", ""rape"", ""band"", ""aces"", ""goal"", ""huck"", ""lila"", ""tuft"", ""swan"", ""blab"", ""leda"", ""gems"", ""hide"", ""tack"", ""porn"", ""scum"", ""frat"", ""plum"", ""duds"", ""shad"", ""arms"", ""pare"", ""chin"", ""gain"", ""knee"", ""foot"", ""line"", ""dove"", ""vera"", ""jays"", ""fund"", ""reno"", ""skid"", ""boys"", ""corn"", ""gwyn"", ""sash"", ""weld"", ""ruiz"", ""dior"", ""jess"", ""leaf"", ""pars"", ""cote"", ""zing"", ""scat"", ""nice"", ""dart"", ""only"", ""owls"", ""hike"", ""trey"", ""whys"", ""ding"", ""klan"", ""ross"", ""barb"", ""ants"", ""lean"", ""dopy"", ""hock"", ""tour"", ""grip"", ""aldo"", ""whim"", ""prom"", ""rear"", ""dins"", ""duff"", ""dell"", ""loch"", ""lava"", ""sung"", ""yank"", ""thar"", ""curl"", ""venn"", ""blow"", ""pomp"", ""heat"", ""trap"", ""dali"", ""nets"", ""seen"", ""gash"", ""twig"", ""dads"", ""emmy"", ""rhea"", ""navy"", ""haws"", ""mite"", ""bows"", ""alas"", ""ives"", ""play"", ""soon"", ""doll"", ""chum"", ""ajar"", ""foam"", ""call"", ""puke"", ""kris"", ""wily"", ""came"", ""ales"", ""reef"", ""raid"", ""diet"", ""prod"", ""prut"", ""loot"", ""soar"", ""coed"", ""celt"", ""seam"", ""dray"", ""lump"", ""jags"", ""nods"", ""sole"", ""kink"", ""peso"", ""howl"", ""cost"", ""tsar"", ""uric"", ""sore"", ""woes"", ""sewn"", ""sake"", ""cask"", ""caps"", ""burl"", ""tame"", ""bulk"", ""neva"", ""from"", ""meet"", ""webs"", ""spar"", ""fuck"", ""buoy"", ""wept"", ""west"", ""dual"", ""pica"", ""sold"", ""seed"", ""gads"", ""riff"", ""neck"", ""deed"", ""rudy"", ""drop"", ""vale"", ""flit"", ""romp"", ""peak"", ""jape"", ""jews"", ""fain"", ""dens"", ""hugo"", ""elba"", ""mink"", ""town"", ""clam"", ""feud"", ""fern"", ""dung"", ""newt"", ""mime"", ""deem"", ""inti"", ""gigs"", ""sosa"", ""lope"", ""lard"", ""cara"", ""smug"", ""lego"", ""flex"", ""doth"", ""paar"", ""moon"", ""wren"", ""tale"", ""kant"", ""eels"", ""muck"", ""toga"", ""zens"", ""lops"", ""duet"", ""coil"", ""gall"", ""teal"", ""glib"", ""muir"", ""ails"", ""boer"", ""them"", ""rake"", ""conn"", ""neat"", ""frog"", ""trip"", ""coma"", ""must"", ""mono"", ""lira"", ""craw"", ""sled"", ""wear"", ""toby"", ""reel"", ""hips"", ""nate"", ""pump"", ""mont"", ""died"", ""moss"", ""lair"", ""jibe"", ""oils"", ""pied"", ""hobs"", ""cads"", ""haze"", ""muse"", ""cogs"", ""figs"", ""cues"", ""roes"", ""whet"", ""boru"", ""cozy"", ""amos"", ""tans"", ""news"", ""hake"", ""cots"", ""boas"", ""tutu"", ""wavy"", ""pipe"", ""typo"", ""albs"", ""boom"", ""dyke"", ""wail"", ""woke"", ""ware"", ""rita"", ""fail"", ""slab"", ""owes"", ""jane"", ""rack"", ""hell"", ""lags"", ""mend"", ""mask"", ""hume"", ""wane"", ""acne"", ""team"", ""holy"", ""runs"", ""exes"", ""dole"", ""trim"", ""zola"", ""trek"", ""puma"", ""wacs"", ""veep"", ""yaps"", ""sums"", ""lush"", ""tubs"", ""most"", ""witt"", ""bong"", ""rule"", ""hear"", ""awry"", ""sots"", ""nils"", ""bash"", ""gasp"", ""inch"", ""pens"", ""fies"", ""juts"", ""pate"", ""vine"", ""zulu"", ""this"", ""bare"", ""veal"", ""josh"", ""reek"", ""ours"", ""cowl"", ""club"", ""farm"", ""teat"", ""coat"", ""dish"", ""fore"", ""weft"", ""exam"", ""vlad"", ""floe"", ""beak"", ""lane"", ""ella"", ""warp"", ""goth"", ""ming"", ""pits"", ""rent"", ""tito"", ""wish"", ""amps"", ""says"", ""hawk"", ""ways"", ""punk"", ""nark"", ""cagy"", ""east"", ""paul"", ""bose"", ""solo"", ""teed"", ""text"", ""hews"", ""snip"", ""lips"", ""emit"", ""orgy"", ""icon"", ""tuna"", ""soul"", ""kurd"", ""clod"", ""calk"", ""aunt"", ""bake"", ""copy"", ""acid"", ""duse"", ""kiln"", ""spec"", ""fans"", ""bani"", ""irma"", ""pads"", ""batu"", ""logo"", ""pack"", ""oder"", ""atop"", ""funk"", ""gide"", ""bede"", ""bibs"", ""taut"", ""guns"", ""dana"", ""puff"", ""lyme"", ""flat"", ""lake"", ""june"", ""sets"", ""gull"", ""hops"", ""earn"", ""clip"", ""fell"", ""kama"", ""seal"", ""diaz"", ""cite"", ""chew"", ""cuba"", ""bury"", ""yard"", ""bank"", ""byes"", ""apia"", ""cree"", ""nosh"", ""judo"", ""walk"", ""tape"", ""taro"", ""boot"", ""cods"", ""lade"", ""cong"", ""deft"", ""slim"", ""jeri"", ""rile"", ""park"", ""aeon"", ""fact"", ""slow"", ""goff"", ""cane"", ""earp"", ""tart"", ""does"", ""acts"", ""hope"", ""cant"", ""buts"", ""shin"", ""dude"", ""ergo"", ""mode"", ""gene"", ""lept"", ""chen"", ""beta"", ""eden"", ""pang"", ""saab"", ""fang"", ""whir"", ""cove"", ""perk"", ""fads"", ""rugs"", ""herb"", ""putt"", ""nous"", ""vane"", ""corm"", ""stay"", ""bids"", ""vela"", ""roof"", ""isms"", ""sics"", ""gone"", ""swum"", ""wiry"", ""cram"", ""rink"", ""pert"", ""heap"", ""sikh"", ""dais"", ""cell"", ""peel"", ""nuke"", ""buss"", ""rasp"", ""none"", ""slut"", ""bent"", ""dams"", ""serb"", ""dork"", ""bays"", ""kale"", ""cora"", ""wake"", ""welt"", ""rind"", ""trot"", ""sloe"", ""pity"", ""rout"", ""eves"", ""fats"", ""furs"", ""pogo"", ""beth"", ""hued"", ""edam"", ""iamb"", ""glee"", ""lute"", ""keel"", ""airy"", ""easy"", ""tire"", ""rube"", ""bogy"", ""sine"", ""chop"", ""rood"", ""elbe"", ""mike"", ""garb"", ""jill"", ""gaul"", ""chit"", ""dons"", ""bars"", ""ride"", ""beck"", ""toad"", ""make"", ""head"", ""suds"", ""pike"", ""snot"", ""swat"", ""peed"", ""same"", ""gaza"", ""lent"", ""gait"", ""gael"", ""elks"", ""hang"", ""nerf"", ""rosy"", ""shut"", ""glop"", ""pain"", ""dion"", ""deaf"", ""hero"", ""doer"", ""wost"", ""wage"", ""wash"", ""pats"", ""narc"", ""ions"", ""dice"", ""quay"", ""vied"", ""eons"", ""case"", ""pour"", ""urns"", ""reva"", ""rags"", ""aden"", ""bone"", ""rang"", ""aura"", ""iraq"", ""toot"", ""rome"", ""hals"", ""megs"", ""pond"", ""john"", ""yeps"", ""pawl"", ""warm"", ""bird"", ""tint"", ""jowl"", ""gibe"", ""come"", ""hold"", ""pail"", ""wipe"", ""bike"", ""rips"", ""eery"", ""kent"", ""hims"", ""inks"", ""fink"", ""mott"", ""ices"", ""macy"", ""serf"", ""keys"", ""tarp"", ""cops"", ""sods"", ""feet"", ""tear"", ""benz"", ""buys"", ""colo"", ""boil"", ""sews"", ""enos"", ""watt"", ""pull"", ""brag"", ""cork"", ""save"", ""mint"", ""feat"", ""jamb"", ""rubs"", ""roxy"", ""toys"", ""nosy"", ""yowl"", ""tamp"", ""lobs"", ""foul"", ""doom"", ""sown"", ""pigs"", ""hemp"", ""fame"", ""boor"", ""cube"", ""tops"", ""loco"", ""lads"", ""eyre"", ""alta"", ""aged"", ""flop"", ""pram"", ""lesa"", ""sawn"", ""plow"", ""aral"", ""load"", ""lied"", ""pled"", ""boob"", ""bert"", ""rows"", ""zits"", ""rick"", ""hint"", ""dido"", ""fist"", ""marc"", ""wuss"", ""node"", ""smog"", ""nora"", ""shim"", ""glut"", ""bale"", ""perl"", ""what"", ""tort"", ""meek"", ""brie"", ""bind"", ""cake"", ""psst"", ""dour"", ""jove"", ""tree"", ""chip"", ""stud"", ""thou"", ""mobs"", ""sows"", ""opts"", ""diva"", ""perm"", ""wise"", ""cuds"", ""sols"", ""alan"", ""mild"", ""pure"", ""gail"", ""wins"", ""offs"", ""nile"", ""yelp"", ""minn"", ""tors"", ""tran"", ""homy"", ""sadr"", ""erse"", ""nero"", ""scab"", ""finn"", ""mich"", ""turd"", ""then"", ""poem"", ""noun"", ""oxus"", ""brow"", ""door"", ""saws"", ""eben"", ""wart"", ""wand"", ""rosa"", ""left"", ""lina"", ""cabs"", ""rapt"", ""olin"", ""suet"", ""kalb"", ""mans"", ""dawn"", ""riel"", ""temp"", ""chug"", ""peal"", ""drew"", ""null"", ""hath"", ""many"", ""took"", ""fond"", ""gate"", ""sate"", ""leak"", ""zany"", ""vans"", ""mart"", ""hess"", ""home"", ""long"", ""dirk"", ""bile"", ""lace"", ""moog"", ""axes"", ""zone"", ""fork"", ""duct"", ""rico"", ""rife"", ""deep"", ""tiny"", ""hugh"", ""bilk"", ""waft"", ""swig"", ""pans"", ""with"", ""kern"", ""busy"", ""film"", ""lulu"", ""king"", ""lord"", ""veda"", ""tray"", ""legs"", ""soot"", ""ells"", ""wasp"", ""hunt"", ""earl"", ""ouch"", ""diem"", ""yell"", ""pegs"", ""blvd"", ""polk"", ""soda"", ""zorn"", ""liza"", ""slop"", ""week"", ""kill"", ""rusk"", ""eric"", ""sump"", ""haul"", ""rims"", ""crop"", ""blob"", ""face"", ""bins"", ""read"", ""care"", ""pele"", ""ritz"", ""beau"", ""golf"", ""drip"", ""dike"", ""stab"", ""jibs"", ""hove"", ""junk"", ""hoax"", ""tats"", ""fief"", ""quad"", ""peat"", ""ream"", ""hats"", ""root"", ""flak"", ""grit"", ""clap"", ""pugh"", ""bosh"", ""lock"", ""mute"", ""crow"", ""iced"", ""lisa"", ""bela"", ""fems"", ""oxes"", ""vies"", ""gybe"", ""huff"", ""bull"", ""cuss"", ""sunk"", ""pups"", ""fobs"", ""turf"", ""sect"", ""atom"", ""debt"", ""sane"", ""writ"", ""anon"", ""mayo"", ""aria"", ""seer"", ""thor"", ""brim"", ""gawk"", ""jack"", ""jazz"", ""menu"", ""yolk"", ""surf"", ""libs"", ""lets"", ""bans"", ""toil"", ""open"", ""aced"", ""poor"", ""mess"", ""wham"", ""fran"", ""gina"", ""dote"", ""love"", ""mood"", ""pale"", ""reps"", ""ines"", ""shot"", ""alar"", ""twit"", ""site"", ""dill"", ""yoga"", ""sear"", ""vamp"", ""abel"", ""lieu"", ""cuff"", ""orbs"", ""rose"", ""tank"", ""gape"", ""guam"", ""adar"", ""vole"", ""your"", ""dean"", ""dear"", ""hebe"", ""crab"", ""hump"", ""mole"", ""vase"", ""rode"", ""dash"", ""sera"", ""balk"", ""lela"", ""inca"", ""gaea"", ""bush"", ""loud"", ""pies"", ""aide"", ""blew"", ""mien"", ""side"", ""kerr"", ""ring"", ""tess"", ""prep"", ""rant"", ""lugs"", ""hobo"", ""joke"", ""odds"", ""yule"", ""aida"", ""true"", ""pone"", ""lode"", ""nona"", ""weep"", ""coda"", ""elmo"", ""skim"", ""wink"", ""bras"", ""pier"", ""bung"", ""pets"", ""tabs"", ""ryan"", ""jock"", ""body"", ""sofa"", ""joey"", ""zion"", ""mace"", ""kick"", ""vile"", ""leno"", ""bali"", ""fart"", ""that"", ""redo"", ""ills"", ""jogs"", ""pent"", ""drub"", ""slaw"", ""tide"", ""lena"", ""seep"", ""gyps"", ""wave"", ""amid"", ""fear"", ""ties"", ""flan"", ""wimp"", ""kali"", ""shun"", ""crap"", ""sage"", ""rune"", ""logs"", ""cain"", ""digs"", ""abut"", ""obit"", ""paps"", ""rids"", ""fair"", ""hack"", ""huns"", ""road"", ""caws"", ""curt"", ""jute"", ""fisk"", ""fowl"", ""duty"", ""holt"", ""miss"", ""rude"", ""vito"", ""baal"", ""ural"", ""mann"", ""mind"", ""belt"", ""clem"", ""last"", ""musk"", ""roam"", ""abed"", ""days"", ""bore"", ""fuze"", ""fall"", ""pict"", ""dump"", ""dies"", ""fiat"", ""vent"", ""pork"", ""eyed"", ""docs"", ""rive"", ""spas"", ""rope"", ""ariz"", ""tout"", ""game"", ""jump"", ""blur"", ""anti"", ""lisp"", ""turn"", ""sand"", ""food"", ""moos"", ""hoop"", ""saul"", ""arch"", ""fury"", ""rise"", ""diss"", ""hubs"", ""burs"", ""grid"", ""ilks"", ""suns"", ""flea"", ""soil"", ""lung"", ""want"", ""nola"", ""fins"", ""thud"", ""kidd"", ""juan"", ""heps"", ""nape"", ""rash"", ""burt"", ""bump"", ""tots"", ""brit"", ""mums"", ""bole"", ""shah"", ""tees"", ""skip"", ""limb"", ""umps"", ""ache"", ""arcs"", ""raft"", ""halo"", ""luce"", ""bahs"", ""leta"", ""conk"", ""duos"", ""siva"", ""went"", ""peek"", ""sulk"", ""reap"", ""free"", ""dubs"", ""lang"", ""toto"", ""hasp"", ""ball"", ""rats"", ""nair"", ""myst"", ""wang"", ""snug"", ""nash"", ""laos"", ""ante"", ""opal"", ""tina"", ""pore"", ""bite"", ""haas"", ""myth"", ""yugo"", ""foci"", ""dent"", ""bade"", ""pear"", ""mods"", ""auto"", ""shop"", ""etch"", ""lyly"", ""curs"", ""aron"", ""slew"", ""tyro"", ""sack"", ""wade"", ""clio"", ""gyro"", ""butt"", ""icky"", ""char"", ""itch"", ""halt"", ""gals"", ""yang"", ""tend"", ""pact"", ""bees"", ""suit"", ""puny"", ""hows"", ""nina"", ""brno"", ""oops"", ""lick"", ""sons"", ""kilo"", ""bust"", ""nome"", ""mona"", ""dull"", ""join"", ""hour"", ""papa"", ""stag"", ""bern"", ""wove"", ""lull"", ""slip"", ""laze"", ""roil"", ""alto"", ""bath"", ""buck"", ""alma"", ""anus"", ""evil"", ""dumb"", ""oreo"", ""rare"", ""near"", ""cure"", ""isis"", ""hill"", ""kyle"", ""pace"", ""comb"", ""nits"", ""flip"", ""clop"", ""mort"", ""thea"", ""wall"", ""kiel"", ""judd"", ""coop"", ""dave"", ""very"", ""amie"", ""blah"", ""flub"", ""talc"", ""bold"", ""fogy"", ""idea"", ""prof"", ""horn"", ""shoo"", ""aped"", ""pins"", ""helm"", ""wees"", ""beer"", ""womb"", ""clue"", ""alba"", ""aloe"", ""fine"", ""bard"", ""limo"", ""shaw"", ""pint"", ""swim"", ""dust"", ""indy"", ""hale"", ""cats"", ""troy"", ""wens"", ""luke"", ""vern"", ""deli"", ""both"", ""brig"", ""daub"", ""sara"", ""sued"", ""bier"", ""noel"", ""olga"", ""dupe"", ""look"", ""pisa"", ""knox"", ""murk"", ""dame"", ""matt"", ""gold"", ""jame"", ""toge"", ""luck"", ""peck"", ""tass"", ""calf"", ""pill"", ""wore"", ""wadi"", ""thur"", ""parr"", ""maul"", ""tzar"", ""ones"", ""lees"", ""dark"", ""fake"", ""bast"", ""zoom"", ""here"", ""moro"", ""wine"", ""bums"", ""cows"", ""jean"", ""palm"", ""fume"", ""plop"", ""help"", ""tuba"", ""leap"", ""cans"", ""back"", ""avid"", ""lice"", ""lust"", ""polo"", ""dory"", ""stew"", ""kate"", ""rama"", ""coke"", ""bled"", ""mugs"", ""ajax"", ""arts"", ""drug"", ""pena"", ""cody"", ""hole"", ""sean"", ""deck"", ""guts"", ""kong"", ""bate"", ""pitt"", ""como"", ""lyle"", ""siam"", ""rook"", ""baby"", ""jigs"", ""bret"", ""bark"", ""lori"", ""reba"", ""sups"", ""made"", ""buzz"", ""gnaw"", ""alps"", ""clay"", ""post"", ""viol"", ""dina"", ""card"", ""lana"", ""doff"", ""yups"", ""tons"", ""live"", ""kids"", ""pair"", ""yawl"", ""name"", ""oven"", ""sirs"", ""gyms"", ""prig"", ""down"", ""leos"", ""noon"", ""nibs"", ""cook"", ""safe"", ""cobb"", ""raja"", ""awes"", ""sari"", ""nerd"", ""fold"", ""lots"", ""pete"", ""deal"", ""bias"", ""zeal"", ""girl"", ""rage"", ""cool"", ""gout"", ""whey"", ""soak"", ""thaw"", ""bear"", ""wing"", ""nagy"", ""well"", ""oink"", ""sven"", ""kurt"", ""etna"", ""held"", ""wood"", ""high"", ""feta"", ""twee"", ""ford"", ""cave"", ""knot"", ""tory"", ""ibis"", ""yaks"", ""vets"", ""foxy"", ""sank"", ""cone"", ""pius"", ""tall"", ""seem"", ""wool"", ""flap"", ""gird"", ""lore"", ""coot"", ""mewl"", ""sere"", ""real"", ""puts"", ""sell"", ""nuts"", ""foil"", ""lilt"", ""saga"", ""heft"", ""dyed"", ""goat"", ""spew"", ""daze"", ""frye"", ""adds"", ""glen"", ""tojo"", ""pixy"", ""gobi"", ""stop"", ""tile"", ""hiss"", ""shed"", ""hahn"", ""baku"", ""ahas"", ""sill"", ""swap"", ""also"", ""carr"", ""manx"", ""lime"", ""debs"", ""moat"", ""eked"", ""bola"", ""pods"", ""coon"", ""lacy"", ""tube"", ""minx"", ""buff"", ""pres"", ""clew"", ""gaff"", ""flee"", ""burn"", ""whom"", ""cola"", ""fret"", ""purl"", ""wick"", ""wigs"", ""donn"", ""guys"", ""toni"", ""oxen"", ""wite"", ""vial"", ""spam"", ""huts"", ""vats"", ""lima"", ""core"", ""eula"", ""thad"", ""peon"", ""erie"", ""oats"", ""boyd"", ""cued"", ""olaf"", ""tams"", ""secs"", ""urey"", ""wile"", ""penn"", ""bred"", ""rill"", ""vary"", ""sues"", ""mail"", ""feds"", ""aves"", ""code"", ""beam"", ""reed"", ""neil"", ""hark"", ""pols"", ""gris"", ""gods"", ""mesa"", ""test"", ""coup"", ""heed"", ""dora"", ""hied"", ""tune"", ""doze"", ""pews"", ""oaks"", ""bloc"", ""tips"", ""maid"", ""goof"", ""four"", ""woof"", ""silo"", ""bray"", ""zest"", ""kiss"", ""yong"", ""file"", ""hilt"", ""iris"", ""tuns"", ""lily"", ""ears"", ""pant"", ""jury"", ""taft"", ""data"", ""gild"", ""pick"", ""kook"", ""colt"", ""bohr"", ""anal"", ""asps"", ""babe"", ""bach"", ""mash"", ""biko"", ""bowl"", ""huey"", ""jilt"", ""goes"", ""guff"", ""bend"", ""nike"", ""tami"", ""gosh"", ""tike"", ""gees"", ""urge"", ""path"", ""bony"", ""jude"", ""lynn"", ""lois"", ""teas"", ""dunn"", ""elul"", ""bonn"", ""moms"", ""bugs"", ""slay"", ""yeah"", ""loan"", ""hulk"", ""lows"", ""damn"", ""nell"", ""jung"", ""avis"", ""mane"", ""waco"", ""loin"", ""knob"", ""tyke"", ""anna"", ""hire"", ""luau"", ""tidy"", ""nuns"", ""pots"", ""quid"", ""exec"", ""hans"", ""hera"", ""hush"", ""shag"", ""scot"", ""moan"", ""wald"", ""ursa"", ""lorn"", ""hunk"", ""loft"", ""yore"", ""alum"", ""mows"", ""slog"", ""emma"", ""spud"", ""rice"", ""worn"", ""erma"", ""need"", ""bags"", ""lark"", ""kirk"", ""pooh"", ""dyes"", ""area"", ""dime"", ""luvs"", ""foch"", ""refs"", ""cast"", ""alit"", ""tugs"", ""even"", ""role"", ""toed"", ""caph"", ""nigh"", ""sony"", ""bide"", ""robs"", ""folk"", ""daft"", ""past"", ""blue"", ""flaw"", ""sana"", ""fits"", ""barr"", ""riot"", ""dots"", ""lamp"", ""cock"", ""fibs"", ""harp"", ""tent"", ""hate"", ""mali"", ""togs"", ""gear"", ""tues"", ""bass"", ""pros"", ""numb"", ""emus"", ""hare"", ""fate"", ""wife"", ""mean"", ""pink"", ""dune"", ""ares"", ""dine"", ""oily"", ""tony"", ""czar"", ""spay"", ""push"", ""glum"", ""till"", ""moth"", ""glue"", ""dive"", ""scad"", ""pops"", ""woks"", ""andy"", ""leah"", ""cusp"", ""hair"", ""alex"", ""vibe"", ""bulb"", ""boll"", ""firm"", ""joys"", ""tara"", ""cole"", ""levy"", ""owen"", ""chow"", ""rump"", ""jail"", ""lapp"", ""beet"", ""slap"", ""kith"", ""more"", ""maps"", ""bond"", ""hick"", ""opus"", ""rust"", ""wist"", ""shat"", ""phil"", ""snow"", ""lott"", ""lora"", ""cary"", ""mote"", ""rift"", ""oust"", ""klee"", ""goad"", ""pith"", ""heep"", ""lupe"", ""ivan"", ""mimi"", ""bald"", ""fuse"", ""cuts"", ""lens"", ""leer"", ""eyry"", ""know"", ""razz"", ""tare"", ""pals"", ""geek"", ""greg"", ""teen"", ""clef"", ""wags"", ""weal"", ""each"", ""haft"", ""nova"", ""waif"", ""rate"", ""katy"", ""yale"", ""dale"", ""leas"", ""axum"", ""quiz"", ""pawn"", ""fend"", ""capt"", ""laws"", ""city"", ""chad"", ""coal"", ""nail"", ""zaps"", ""sort"", ""loci"", ""less"", ""spur"", ""note"", ""foes"", ""fags"", ""gulp"", ""snap"", ""bogs"", ""wrap"", ""dane"", ""melt"", ""ease"", ""felt"", ""shea"", ""calm"", ""star"", ""swam"", ""aery"", ""year"", ""plan"", ""odin"", ""curd"", ""mira"", ""mops"", ""shit"", ""davy"", ""apes"", ""inky"", ""hues"", ""lome"", ""bits"", ""vila"", ""show"", ""best"", ""mice"", ""gins"", ""next"", ""roan"", ""ymir"", ""mars"", ""oman"", ""wild"", ""heal"", ""plus"", ""erin"", ""rave"", ""robe"", ""fast"", ""hutu"", ""aver"", ""jodi"", ""alms"", ""yams"", ""zero"", ""revs"", ""wean"", ""chic"", ""self"", ""jeep"", ""jobs"", ""waxy"", ""duel"", ""seek"", ""spot"", ""raps"", ""pimp"", ""adan"", ""slam"", ""tool"", ""morn"", ""futz"", ""ewes"", ""errs"", ""knit"", ""rung"", ""kans"", ""muff"", ""huhs"", ""tows"", ""lest"", ""meal"", ""azov"", ""gnus"", ""agar"", ""sips"", ""sway"", ""otis"", ""tone"", ""tate"", ""epic"", ""trio"", ""tics"", ""fade"", ""lear"", ""owns"", ""robt"", ""weds"", ""five"", ""lyon"", ""terr"", ""arno"", ""mama"", ""grey"", ""disk"", ""sept"", ""sire"", ""bart"", ""saps"", ""whoa"", ""turk"", ""stow"", ""pyle"", ""joni"", ""zinc"", ""negs"", ""task"", ""leif"", ""ribs"", ""malt"", ""nine"", ""bunt"", ""grin"", ""dona"", ""nope"", ""hams"", ""some"", ""molt"", ""smit"", ""sacs"", ""joan"", ""slav"", ""lady"", ""base"", ""heck"", ""list"", ""take"", ""herd"", ""will"", ""nubs"", ""burg"", ""hugs"", ""peru"", ""coif"", ""zoos"", ""nick"", ""idol"", ""levi"", ""grub"", ""roth"", ""adam"", ""elma"", ""tags"", ""tote"", ""yaws"", ""cali"", ""mete"", ""lula"", ""cubs"", ""prim"", ""luna"", ""jolt"", ""span"", ""pita"", ""dodo"", ""puss"", ""deer"", ""term"", ""dolt"", ""goon"", ""gary"", ""yarn"", ""aims"", ""just"", ""rena"", ""tine"", ""cyst"", ""meld"", ""loki"", ""wong"", ""were"", ""hung"", ""maze"", ""arid"", ""cars"", ""wolf"", ""marx"", ""faye"", ""eave"", ""raga"", ""flow"", ""neal"", ""lone"", ""anne"", ""cage"", ""tied"", ""tilt"", ""soto"", ""opel"", ""date"", ""buns"", ""dorm"", ""kane"", ""akin"", ""ewer"", ""drab"", ""thai"", ""jeer"", ""grad"", ""berm"", ""rods"", ""saki"", ""grus"", ""vast"", ""late"", ""lint"", ""mule"", ""risk"", ""labs"", ""snit"", ""gala"", ""find"", ""spin"", ""ired"", ""slot"", ""oafs"", ""lies"", ""mews"", ""wino"", ""milk"", ""bout"", ""onus"", ""tram"", ""jaws"", ""peas"", ""cleo"", ""seat"", ""gums"", ""cold"", ""vang"", ""dewy"", ""hood"", ""rush"", ""mack"", ""yuan"", ""odes"", ""boos"", ""jami"", ""mare"", ""plot"", ""swab"", ""borg"", ""hays"", ""form"", ""mesh"", ""mani"", ""fife"", ""good"", ""gram"", ""lion"", ""myna"", ""moor"", ""skin"", ""posh"", ""burr"", ""rime"", ""done"", ""ruts"", ""pays"", ""stem"", ""ting"", ""arty"", ""slag"", ""iron"", ""ayes"", ""stub"", ""oral"", ""gets"", ""chid"", ""yens"", ""snub"", ""ages"", ""wide"", ""bail"", ""verb"", ""lamb"", ""bomb"", ""army"", ""yoke"", ""gels"", ""tits"", ""bork"", ""mils"", ""nary"", ""barn"", ""hype"", ""odom"", ""avon"", ""hewn"", ""rios"", ""cams"", ""tact"", ""boss"", ""oleo"", ""duke"", ""eris"", ""gwen"", ""elms"", ""deon"", ""sims"", ""quit"", ""nest"", ""font"", ""dues"", ""yeas"", ""zeta"", ""bevy"", ""gent"", ""torn"", ""cups"", ""worm"", ""baum"", ""axon"", ""purr"", ""vise"", ""grew"", ""govs"", ""meat"", ""chef"", ""rest"", ""lame"" ];11
""catch"";""choir"";[ ""tours"", ""awake"", ""goats"", ""crape"", ""boron"", ""payee"", ""waken"", ""cares"", ""times"", ""piled"", ""maces"", ""cuter"", ""spied"", ""spare"", ""mouse"", ""minty"", ""theed"", ""sprat"", ""veins"", ""brian"", ""crown"", ""years"", ""drone"", ""froth"", ""foggy"", ""laura"", ""sears"", ""shunt"", ""gaunt"", ""hovel"", ""staff"", ""child"", ""arson"", ""haber"", ""knows"", ""rubes"", ""czars"", ""pawed"", ""whine"", ""treed"", ""bauer"", ""jodie"", ""timed"", ""flits"", ""robby"", ""gooks"", ""yawls"", ""purse"", ""veeps"", ""tints"", ""taped"", ""raced"", ""shaft"", ""modes"", ""dykes"", ""slims"", ""parts"", ""emile"", ""frail"", ""salem"", ""jives"", ""heave"", ""bayer"", ""leech"", ""clipt"", ""yanks"", ""wilds"", ""hikes"", ""cilia"", ""spiel"", ""mulls"", ""fetal"", ""homed"", ""drown"", ""suite"", ""defer"", ""oaken"", ""flail"", ""zippy"", ""burke"", ""slued"", ""mowed"", ""manes"", ""verse"", ""serra"", ""bruno"", ""spoke"", ""mikes"", ""hafts"", ""breed"", ""sully"", ""croce"", ""boers"", ""chair"", ""thong"", ""pulse"", ""pasta"", ""perot"", ""fices"", ""shies"", ""nadir"", ""every"", ""diets"", ""roads"", ""cones"", ""tuned"", ""globs"", ""graft"", ""stall"", ""royal"", ""fixes"", ""north"", ""pikes"", ""slack"", ""vests"", ""quart"", ""crawl"", ""tangs"", ""calks"", ""mayor"", ""filmy"", ""barns"", ""block"", ""hoods"", ""storm"", ""cedes"", ""emote"", ""tacks"", ""skirt"", ""horsy"", ""mawed"", ""moray"", ""wring"", ""munch"", ""hewed"", ""hooke"", ""batch"", ""drawl"", ""berth"", ""sport"", ""welch"", ""jeans"", ""river"", ""tabby"", ""amens"", ""stump"", ""cause"", ""maced"", ""hiker"", ""spays"", ""dusty"", ""trail"", ""acorn"", ""zooms"", ""puked"", ""clown"", ""sands"", ""kelli"", ""stein"", ""rawer"", ""water"", ""dolts"", ""momma"", ""fluky"", ""scots"", ""pupil"", ""halls"", ""toady"", ""pored"", ""latch"", ""shags"", ""union"", ""tamps"", ""stead"", ""ryder"", ""knoll"", ""cacao"", ""damns"", ""charm"", ""frank"", ""draws"", ""gowns"", ""risen"", ""saxes"", ""lucks"", ""avert"", ""yolks"", ""clime"", ""wedge"", ""ruses"", ""famed"", ""sabik"", ""gravy"", ""anion"", ""veils"", ""pyres"", ""raspy"", ""lofts"", ""tress"", ""showy"", ""percy"", ""rices"", ""taker"", ""roger"", ""yeats"", ""baked"", ""ayers"", ""fazes"", ""curly"", ""shawn"", ""clare"", ""paine"", ""ranks"", ""hocks"", ""berta"", ""plays"", ""parks"", ""tacos"", ""onion"", ""skeet"", ""acton"", ""lamer"", ""teals"", ""reset"", ""steal"", ""maven"", ""sored"", ""fecal"", ""harsh"", ""totem"", ""swoop"", ""rough"", ""jokes"", ""mires"", ""weird"", ""quits"", ""damps"", ""touts"", ""fling"", ""sarah"", ""peeps"", ""waxen"", ""traps"", ""mange"", ""swell"", ""swoon"", ""catch"", ""mower"", ""bonny"", ""finds"", ""yards"", ""pleas"", ""filed"", ""smelt"", ""drams"", ""vivid"", ""smirk"", ""whigs"", ""loafs"", ""opens"", ""meter"", ""hakes"", ""berms"", ""whack"", ""donny"", ""faint"", ""peace"", ""libby"", ""yates"", ""purer"", ""wants"", ""brace"", ""razed"", ""emend"", ""bards"", ""karyn"", ""japed"", ""fated"", ""missy"", ""punks"", ""humps"", ""steak"", ""depth"", ""brunt"", ""hauls"", ""craws"", ""blast"", ""broom"", ""tones"", ""ousts"", ""wires"", ""peeks"", ""ruffs"", ""crack"", ""monte"", ""worth"", ""spans"", ""tonic"", ""runny"", ""erick"", ""singe"", ""maine"", ""casts"", ""jello"", ""realm"", ""haste"", ""utter"", ""bleat"", ""kasey"", ""palms"", ""solos"", ""hoagy"", ""sweep"", ""loner"", ""naves"", ""rhine"", ""acmes"", ""cadet"", ""dices"", ""saris"", ""mauro"", ""fifty"", ""prows"", ""karat"", ""dowel"", ""frays"", ""shorn"", ""sails"", ""ticks"", ""train"", ""stars"", ""stork"", ""halts"", ""basal"", ""glops"", ""beset"", ""rifer"", ""layla"", ""lathe"", ""daffy"", ""jinns"", ""snide"", ""groin"", ""kelly"", ""zincs"", ""fryer"", ""quilt"", ""drama"", ""shook"", ""swami"", ""hulls"", ""swazi"", ""danes"", ""axons"", ""those"", ""lorry"", ""plath"", ""prime"", ""faces"", ""crock"", ""shake"", ""borer"", ""droop"", ""derek"", ""shirk"", ""styed"", ""frown"", ""jells"", ""slows"", ""lifts"", ""jeers"", ""helms"", ""turds"", ""dross"", ""tired"", ""rimes"", ""beats"", ""dingo"", ""crews"", ""bides"", ""loins"", ""furry"", ""shana"", ""wises"", ""logos"", ""aural"", ""light"", ""pings"", ""belch"", ""campy"", ""swish"", ""sangs"", ""nerds"", ""boggy"", ""skies"", ""weals"", ""snags"", ""joyed"", ""mamet"", ""miser"", ""leaks"", ""ramos"", ""tract"", ""rends"", ""marks"", ""taunt"", ""sissy"", ""lipid"", ""beach"", ""coves"", ""fates"", ""grate"", ""gloss"", ""heros"", ""sniff"", ""verve"", ""tells"", ""bulge"", ""grids"", ""skein"", ""clout"", ""leaps"", ""males"", ""surfs"", ""slips"", ""grave"", ""boats"", ""tamed"", ""muled"", ""meier"", ""lower"", ""leafy"", ""stool"", ""reich"", ""rider"", ""iring"", ""ginny"", ""flaks"", ""chirp"", ""tonga"", ""chest"", ""ollie"", ""foxes"", ""links"", ""alton"", ""darth"", ""drier"", ""sated"", ""rails"", ""gyros"", ""green"", ""jenna"", ""cures"", ""veals"", ""sense"", ""sworn"", ""roses"", ""aides"", ""loses"", ""rival"", ""david"", ""worms"", ""stand"", ""track"", ""dales"", ""noyes"", ""fraud"", ""shock"", ""sward"", ""pluto"", ""biked"", ""roans"", ""whiny"", ""halve"", ""bunts"", ""spilt"", ""gamey"", ""deeds"", ""oozed"", ""ruder"", ""drano"", ""sages"", ""fewer"", ""maize"", ""aimed"", ""bails"", ""poole"", ""hunts"", ""shari"", ""champ"", ""shuns"", ""jonah"", ""faced"", ""spook"", ""harry"", ""lagos"", ""peale"", ""nacho"", ""saint"", ""power"", ""chaff"", ""shard"", ""cocky"", ""irate"", ""tummy"", ""withe"", ""forks"", ""bates"", ""stuns"", ""turfs"", ""coped"", ""coups"", ""vince"", ""helps"", ""facet"", ""fezes"", ""outer"", ""cheek"", ""tried"", ""sumps"", ""fakes"", ""fonds"", ""yearn"", ""brays"", ""flute"", ""fetid"", ""beyer"", ""mamma"", ""topic"", ""bouts"", ""trend"", ""gorey"", ""hills"", ""swaps"", ""sexes"", ""cindy"", ""ruler"", ""kited"", ""gaits"", ""shank"", ""cloys"", ""stuck"", ""purus"", ""musks"", ""gouge"", ""brake"", ""biker"", ""layer"", ""lilly"", ""bills"", ""seven"", ""flyer"", ""phase"", ""wowed"", ""beaus"", ""cokes"", ""chimp"", ""spats"", ""mooch"", ""dried"", ""hulks"", ""shift"", ""galen"", ""wiped"", ""clops"", ""decal"", ""nopes"", ""huffs"", ""lades"", ""sunny"", ""foyer"", ""gusty"", ""wormy"", ""chips"", ""focus"", ""pails"", ""solid"", ""ariel"", ""gamed"", ""diver"", ""vying"", ""sacks"", ""spout"", ""sides"", ""agave"", ""bandy"", ""scant"", ""coils"", ""marci"", ""marne"", ""swank"", ""basil"", ""shine"", ""nines"", ""clues"", ""fuzes"", ""jacks"", ""robin"", ""pyxes"", ""later"", ""silas"", ""napes"", ""homes"", ""baled"", ""dames"", ""abuse"", ""piker"", ""coots"", ""tiles"", ""bents"", ""pearl"", ""booty"", ""hells"", ""dusky"", ""glare"", ""scale"", ""pales"", ""leary"", ""scull"", ""bimbo"", ""mossy"", ""apron"", ""manet"", ""opted"", ""kusch"", ""shiny"", ""argos"", ""hoped"", ""towns"", ""bilbo"", ""slums"", ""skull"", ""shale"", ""mandy"", ""scows"", ""speed"", ""eager"", ""lards"", ""crows"", ""merry"", ""anted"", ""faxed"", ""leave"", ""fargo"", ""creek"", ""comas"", ""golda"", ""baize"", ""easts"", ""plied"", ""rared"", ""ashed"", ""doted"", ""bunin"", ""bonds"", ""yarns"", ""latin"", ""right"", ""worst"", ""sixes"", ""gabby"", ""begun"", ""upend"", ""giant"", ""tykes"", ""creak"", ""manor"", ""bosom"", ""riced"", ""dimly"", ""holes"", ""stunt"", ""parsi"", ""peers"", ""snell"", ""mates"", ""jules"", ""rusty"", ""myles"", ""yules"", ""sades"", ""hobbs"", ""booth"", ""clean"", ""liven"", ""gamer"", ""howdy"", ""stray"", ""riser"", ""wisps"", ""lubes"", ""tubes"", ""rodeo"", ""bigot"", ""tromp"", ""pimps"", ""reeve"", ""pumps"", ""dined"", ""still"", ""terms"", ""hines"", ""purrs"", ""roast"", ""dooms"", ""lints"", ""sells"", ""swims"", ""happy"", ""spank"", ""inset"", ""meany"", ""bobby"", ""works"", ""place"", ""brook"", ""haded"", ""chide"", ""slime"", ""clair"", ""zeros"", ""britt"", ""screw"", ""ducal"", ""wroth"", ""edger"", ""basie"", ""benin"", ""unset"", ""shade"", ""doers"", ""plank"", ""betsy"", ""bryce"", ""cross"", ""roped"", ""weans"", ""bliss"", ""moist"", ""corps"", ""clara"", ""notch"", ""sheep"", ""weepy"", ""bract"", ""diced"", ""carla"", ""locks"", ""sawed"", ""covey"", ""jocks"", ""large"", ""pasts"", ""bumps"", ""stile"", ""stole"", ""slung"", ""mooed"", ""souls"", ""dupes"", ""fairs"", ""lined"", ""tunis"", ""spelt"", ""joked"", ""wacky"", ""moira"", ""strut"", ""soled"", ""pints"", ""axing"", ""drank"", ""weary"", ""coifs"", ""wills"", ""gibes"", ""ceded"", ""gerry"", ""tires"", ""crazy"", ""tying"", ""sites"", ""trust"", ""dover"", ""bolds"", ""tools"", ""latex"", ""capet"", ""lanky"", ""grins"", ""brood"", ""hitch"", ""perts"", ""dozes"", ""keels"", ""vault"", ""laius"", ""chung"", ""deres"", ""glove"", ""corms"", ""wafer"", ""coons"", ""ponce"", ""tumid"", ""spinx"", ""verge"", ""soggy"", ""fleas"", ""middy"", ""saiph"", ""payer"", ""nukes"", ""click"", ""limps"", ""oared"", ""white"", ""chart"", ""nasty"", ""perth"", ""paddy"", ""elisa"", ""owing"", ""gifts"", ""manna"", ""ofter"", ""paley"", ""fores"", ""sough"", ""wanda"", ""doggy"", ""antic"", ""ester"", ""swath"", ""spoon"", ""lamas"", ""meuse"", ""hotel"", ""weedy"", ""quads"", ""paled"", ""blond"", ""flume"", ""pried"", ""rates"", ""petal"", ""rover"", ""marsh"", ""grief"", ""downy"", ""pools"", ""buffs"", ""dunne"", ""cruel"", ""finny"", ""cosby"", ""patch"", ""polly"", ""jerks"", ""linen"", ""cider"", ""visas"", ""beard"", ""mewed"", ""spill"", ""trots"", ""tares"", ""pured"", ""prior"", ""build"", ""throe"", ""wends"", ""baned"", ""mario"", ""misty"", ""golds"", ""lacey"", ""slags"", ""jived"", ""finis"", ""inner"", ""money"", ""skews"", ""sunks"", ""fined"", ""bauds"", ""lapel"", ""class"", ""berne"", ""rabin"", ""roils"", ""hyped"", ""styes"", ""evans"", ""towed"", ""hawed"", ""allow"", ""modal"", ""ports"", ""erich"", ""rills"", ""humid"", ""hooks"", ""sedge"", ""shirt"", ""nippy"", ""fundy"", ""runes"", ""smile"", ""dolly"", ""tisha"", ""byers"", ""goths"", ""sousa"", ""mimed"", ""welts"", ""hoots"", ""shown"", ""winds"", ""drays"", ""slams"", ""susan"", ""frogs"", ""peach"", ""goody"", ""boned"", ""chewy"", ""eliza"", ""peary"", ""pyxed"", ""tiled"", ""homer"", ""tokes"", ""verdi"", ""mabel"", ""rolls"", ""laden"", ""loxed"", ""phony"", ""woods"", ""brine"", ""rooks"", ""moods"", ""hired"", ""sises"", ""close"", ""slops"", ""tined"", ""creel"", ""hindu"", ""gongs"", ""wanes"", ""drips"", ""belly"", ""leger"", ""demon"", ""sills"", ""chevy"", ""brads"", ""drawn"", ""donna"", ""glean"", ""dying"", ""sassy"", ""gives"", ""hazes"", ""cores"", ""kayla"", ""hurst"", ""wheat"", ""wiled"", ""vibes"", ""kerry"", ""spiny"", ""wears"", ""rants"", ""sizer"", ""asses"", ""duked"", ""spews"", ""aired"", ""merak"", ""lousy"", ""spurt"", ""reeds"", ""dared"", ""paged"", ""prong"", ""deere"", ""clogs"", ""brier"", ""becks"", ""taken"", ""boxes"", ""wanna"", ""corny"", ""races"", ""spuds"", ""jowls"", ""mucks"", ""milch"", ""weest"", ""slick"", ""nouns"", ""alley"", ""bight"", ""paper"", ""lamps"", ""trace"", ""types"", ""sloop"", ""devon"", ""pedal"", ""glint"", ""gawky"", ""eaves"", ""herbs"", ""felts"", ""fills"", ""naval"", ""icing"", ""eking"", ""lauds"", ""stats"", ""kills"", ""vends"", ""capes"", ""chary"", ""belle"", ""moats"", ""fonts"", ""teems"", ""wards"", ""bated"", ""fleet"", ""renal"", ""sleds"", ""gases"", ""loony"", ""paced"", ""holst"", ""seeds"", ""curie"", ""joist"", ""swill"", ""seats"", ""lynda"", ""tasks"", ""colts"", ""shops"", ""toted"", ""nuder"", ""sachs"", ""warts"", ""pupal"", ""scalp"", ""heirs"", ""wilma"", ""pansy"", ""berra"", ""keeps"", ""menus"", ""grams"", ""loots"", ""heels"", ""caste"", ""hypes"", ""start"", ""snout"", ""nixes"", ""nests"", ""grand"", ""tines"", ""vista"", ""copes"", ""ellis"", ""narks"", ""feint"", ""lajos"", ""brady"", ""barry"", ""trips"", ""forth"", ""sales"", ""bests"", ""hears"", ""twain"", ""plaid"", ""hated"", ""kraft"", ""fared"", ""cubit"", ""jayne"", ""heats"", ""chums"", ""pangs"", ""glows"", ""lopez"", ""vesta"", ""garbo"", ""ethel"", ""blood"", ""roams"", ""mealy"", ""clunk"", ""rowed"", ""hacks"", ""davit"", ""plane"", ""fuses"", ""clung"", ""fitch"", ""serer"", ""wives"", ""lully"", ""clans"", ""kinks"", ""spots"", ""nooks"", ""plate"", ""knits"", ""greet"", ""loads"", ""manic"", ""scone"", ""darin"", ""pills"", ""earth"", ""gored"", ""socks"", ""fauna"", ""ditch"", ""wakes"", ""savvy"", ""quiet"", ""nulls"", ""sizes"", ""diana"", ""mayan"", ""velds"", ""dines"", ""punch"", ""bales"", ""sykes"", ""spiky"", ""hover"", ""teats"", ""lusts"", ""ricky"", ""think"", ""culls"", ""bribe"", ""pairs"", ""month"", ""cored"", ""packs"", ""lobes"", ""older"", ""hefts"", ""faxes"", ""cased"", ""swain"", ""bawdy"", ""troop"", ""woven"", ""stomp"", ""swags"", ""beads"", ""check"", ""shill"", ""broad"", ""souse"", ""pouch"", ""lived"", ""iambs"", ""teaks"", ""clams"", ""outed"", ""maxed"", ""plain"", ""sappy"", ""cabal"", ""penal"", ""shame"", ""budge"", ""offed"", ""kooks"", ""gybed"", ""basin"", ""thoth"", ""arced"", ""hypos"", ""flows"", ""fetch"", ""needs"", ""davis"", ""jared"", ""bongo"", ""added"", ""sames"", ""randy"", ""tunes"", ""jamar"", ""smash"", ""blows"", ""grows"", ""palmy"", ""miler"", ""chins"", ""viola"", ""tower"", ""cream"", ""molls"", ""cello"", ""sucks"", ""fears"", ""stone"", ""leans"", ""zions"", ""nutty"", ""tasha"", ""ratty"", ""tenet"", ""raven"", ""coast"", ""roods"", ""mixes"", ""kmart"", ""looms"", ""scram"", ""chapt"", ""lites"", ""trent"", ""baron"", ""rasps"", ""ringo"", ""fazed"", ""thank"", ""masts"", ""trawl"", ""softy"", ""toils"", ""romes"", ""norma"", ""teens"", ""blank"", ""chili"", ""anise"", ""truss"", ""cheat"", ""tithe"", ""lawns"", ""reese"", ""slash"", ""prate"", ""comet"", ""runts"", ""shall"", ""hosed"", ""harpy"", ""dikes"", ""knock"", ""strip"", ""boded"", ""tough"", ""spend"", ""coats"", ""husky"", ""tyree"", ""menes"", ""liver"", ""coins"", ""axles"", ""macho"", ""jawed"", ""weeps"", ""goods"", ""pryor"", ""carts"", ""dumps"", ""posts"", ""donor"", ""daunt"", ""limbo"", ""books"", ""bowls"", ""welds"", ""leper"", ""benny"", ""couch"", ""spell"", ""burst"", ""elvin"", ""limbs"", ""regal"", ""loyal"", ""gaily"", ""blade"", ""wheal"", ""zests"", ""seine"", ""hubby"", ""sheen"", ""tapes"", ""slugs"", ""bench"", ""lungs"", ""pipes"", ""bride"", ""selma"", ""berry"", ""burns"", ""skins"", ""bowen"", ""gills"", ""conan"", ""yucky"", ""gauls"", ""voled"", ""crust"", ""jerky"", ""moans"", ""plump"", ""sided"", ""disks"", ""gleam"", ""larry"", ""billy"", ""aloud"", ""match"", ""udder"", ""rises"", ""wryer"", ""deter"", ""cling"", ""brisk"", ""lever"", ""chaps"", ""tansy"", ""gland"", ""rocky"", ""lists"", ""joins"", ""tubed"", ""react"", ""farsi"", ""dopes"", ""chats"", ""olsen"", ""stern"", ""gully"", ""youth"", ""wiles"", ""slink"", ""cooke"", ""arise"", ""bores"", ""maims"", ""danny"", ""rives"", ""rusts"", ""plots"", ""loxes"", ""troys"", ""cleat"", ""waxes"", ""booze"", ""haven"", ""dilly"", ""shaun"", ""gasps"", ""rains"", ""panda"", ""quips"", ""kings"", ""frets"", ""backs"", ""arabs"", ""rhino"", ""beets"", ""fiber"", ""duffy"", ""parry"", ""sever"", ""hunks"", ""cheap"", ""beeps"", ""fifes"", ""deers"", ""purls"", ""hello"", ""wolfs"", ""stays"", ""lands"", ""hawks"", ""feels"", ""swiss"", ""tyros"", ""nerve"", ""stirs"", ""mixed"", ""tombs"", ""saves"", ""cater"", ""studs"", ""dorky"", ""cinch"", ""spice"", ""shady"", ""elder"", ""plato"", ""hairs"", ""newts"", ""slump"", ""boots"", ""lives"", ""walls"", ""spunk"", ""bucks"", ""mined"", ""parch"", ""disco"", ""newel"", ""doris"", ""glues"", ""brawn"", ""abner"", ""piked"", ""laxes"", ""bulky"", ""moran"", ""cozen"", ""tinge"", ""dowry"", ""snare"", ""sagan"", ""harms"", ""burch"", ""plows"", ""sunni"", ""fades"", ""coach"", ""girls"", ""typed"", ""slush"", ""saver"", ""bulls"", ""grass"", ""holed"", ""coven"", ""dukes"", ""ocher"", ""texan"", ""cakes"", ""gilts"", ""jenny"", ""salon"", ""divas"", ""maris"", ""costs"", ""sulla"", ""lends"", ""gushy"", ""pears"", ""teddy"", ""huffy"", ""sited"", ""rhone"", ""euler"", ""solve"", ""grace"", ""snarl"", ""taste"", ""sally"", ""allay"", ""suers"", ""bogey"", ""pooch"", ""songs"", ""cameo"", ""molts"", ""snipe"", ""cargo"", ""forge"", ""reins"", ""hoses"", ""crams"", ""fines"", ""tings"", ""wings"", ""spoor"", ""twice"", ""waxed"", ""mixer"", ""bongs"", ""stung"", ""gages"", ""yelps"", ""croci"", ""corks"", ""bolls"", ""madge"", ""honer"", ""riled"", ""camus"", ""trick"", ""bowed"", ""overt"", ""steed"", ""ripes"", ""stave"", ""crick"", ""great"", ""scott"", ""scald"", ""point"", ""finch"", ""bulks"", ""chant"", ""kiddo"", ""cover"", ""drunk"", ""sered"", ""dicky"", ""wider"", ""saith"", ""mutts"", ""blind"", ""lyres"", ""sized"", ""darby"", ""rebel"", ""zones"", ""title"", ""yawns"", ""laths"", ""sting"", ""taine"", ""paris"", ""route"", ""livia"", ""roots"", ""belay"", ""daubs"", ""spoof"", ""camel"", ""colds"", ""foist"", ""saned"", ""doles"", ""slays"", ""woody"", ""leads"", ""stout"", ""caper"", ""erika"", ""lance"", ""earns"", ""vines"", ""mercy"", ""antis"", ""terri"", ""messy"", ""lords"", ""shims"", ""serfs"", ""jinni"", ""caged"", ""threw"", ""rainy"", ""bumpy"", ""arias"", ""wails"", ""romeo"", ""gorge"", ""dolls"", ""risks"", ""skyed"", ""fumes"", ""payed"", ""mites"", ""choir"", ""piles"", ""scene"", ""flake"", ""solon"", ""brahe"", ""bikes"", ""dawes"", ""goofs"", ""payne"", ""cried"", ""slavs"", ""hives"", ""snack"", ""cribs"", ""aways"", ""fired"", ""swarm"", ""pumas"", ""paved"", ""smith"", ""gooey"", ""liefs"", ""safer"", ""banes"", ""slake"", ""doled"", ""dummy"", ""gazed"", ""heaps"", ""loped"", ""scoff"", ""crash"", ""balmy"", ""hexed"", ""lunch"", ""guide"", ""loges"", ""alien"", ""rated"", ""stabs"", ""whets"", ""blest"", ""poops"", ""cowls"", ""canes"", ""story"", ""cunts"", ""tusks"", ""pinto"", ""scats"", ""flier"", ""chose"", ""brute"", ""laked"", ""swabs"", ""preps"", ""loose"", ""merle"", ""farms"", ""gapes"", ""lindy"", ""share"", ""floes"", ""scary"", ""bungs"", ""smart"", ""craps"", ""curbs"", ""vices"", ""tally"", ""beret"", ""lenny"", ""waked"", ""brats"", ""carpi"", ""night"", ""junes"", ""signs"", ""karla"", ""dowdy"", ""devil"", ""toned"", ""araby"", ""trait"", ""puffy"", ""dimer"", ""honor"", ""moose"", ""synch"", ""murks"", ""doric"", ""muted"", ""quite"", ""sedan"", ""snort"", ""rumps"", ""teary"", ""heard"", ""slice"", ""alter"", ""barer"", ""whole"", ""steep"", ""catty"", ""bidet"", ""bayes"", ""suits"", ""dunes"", ""jades"", ""colin"", ""ferry"", ""blown"", ""bryon"", ""sways"", ""bayed"", ""fairy"", ""bevel"", ""pined"", ""stoop"", ""smear"", ""mitty"", ""sanes"", ""riggs"", ""order"", ""palsy"", ""reels"", ""talon"", ""cools"", ""retch"", ""olive"", ""dotty"", ""nanny"", ""surat"", ""gross"", ""rafts"", ""broth"", ""mewls"", ""craze"", ""nerdy"", ""barfs"", ""johns"", ""brims"", ""surer"", ""carve"", ""beers"", ""baker"", ""deena"", ""shows"", ""fumed"", ""horde"", ""kicky"", ""wrapt"", ""waits"", ""shane"", ""buffy"", ""lurks"", ""treat"", ""savor"", ""wiper"", ""bided"", ""funny"", ""dairy"", ""wispy"", ""flees"", ""midge"", ""hooch"", ""sired"", ""brett"", ""putty"", ""caked"", ""witch"", ""rearm"", ""stubs"", ""putts"", ""chase"", ""jesus"", ""posed"", ""dates"", ""dosed"", ""yawed"", ""wombs"", ""idles"", ""hmong"", ""sofas"", ""capek"", ""goner"", ""musts"", ""tangy"", ""cheer"", ""sinks"", ""fatal"", ""rubin"", ""wrest"", ""crank"", ""bared"", ""zilch"", ""bunny"", ""islet"", ""spies"", ""spent"", ""filth"", ""docks"", ""notes"", ""gripe"", ""flair"", ""quire"", ""snuck"", ""foray"", ""cooks"", ""godly"", ""dorms"", ""silos"", ""camps"", ""mumps"", ""spins"", ""cites"", ""sulky"", ""stink"", ""strap"", ""fists"", ""tends"", ""adobe"", ""vivas"", ""sulks"", ""hasps"", ""poser"", ""bethe"", ""sudan"", ""faust"", ""bused"", ""plume"", ""yoked"", ""silly"", ""wades"", ""relay"", ""brent"", ""cower"", ""sasha"", ""staci"", ""haves"", ""dumbs"", ""based"", ""loser"", ""genes"", ""grape"", ""lilia"", ""acted"", ""steel"", ""award"", ""mares"", ""crabs"", ""rocks"", ""lines"", ""margo"", ""blahs"", ""honda"", ""rides"", ""spine"", ""taxed"", ""salty"", ""eater"", ""bland"", ""sweat"", ""sores"", ""ovens"", ""stash"", ""token"", ""drink"", ""swans"", ""heine"", ""gents"", ""reads"", ""piers"", ""yowls"", ""risky"", ""tided"", ""blips"", ""myths"", ""cline"", ""tiers"", ""racer"", ""limed"", ""poled"", ""sluts"", ""chump"", ""greek"", ""wines"", ""mangy"", ""fools"", ""bands"", ""smock"", ""prowl"", ""china"", ""prove"", ""oases"", ""gilda"", ""brews"", ""sandy"", ""leers"", ""watch"", ""tango"", ""keven"", ""banns"", ""wefts"", ""crass"", ""cloud"", ""hunch"", ""cluck"", ""reams"", ""comic"", ""spool"", ""becky"", ""grown"", ""spike"", ""lingo"", ""tease"", ""fixed"", ""linda"", ""bleep"", ""funky"", ""fanny"", ""curve"", ""josie"", ""minds"", ""musty"", ""toxin"", ""drags"", ""coors"", ""dears"", ""beams"", ""wooer"", ""dells"", ""brave"", ""drake"", ""merge"", ""hippo"", ""lodge"", ""taper"", ""roles"", ""plums"", ""dandy"", ""harps"", ""lutes"", ""fails"", ""navel"", ""lyons"", ""magic"", ""walks"", ""sonic"", ""voles"", ""raped"", ""stamp"", ""minus"", ""hazel"", ""clods"", ""tiffs"", ""hayed"", ""rajah"", ""pared"", ""hates"", ""makes"", ""hinds"", ""splay"", ""flags"", ""tempe"", ""waifs"", ""roved"", ""dills"", ""jonas"", ""avers"", ""balds"", ""balks"", ""perms"", ""dully"", ""lithe"", ""aisha"", ""witty"", ""ellie"", ""dived"", ""range"", ""lefty"", ""wined"", ""booby"", ""decor"", ""jaded"", ""knobs"", ""roded"", ""moots"", ""whens"", ""valet"", ""talks"", ""blare"", ""heeds"", ""cuing"", ""needy"", ""knees"", ""broke"", ""bored"", ""henna"", ""rages"", ""vises"", ""perch"", ""laded"", ""emily"", ""spark"", ""tracy"", ""tevet"", ""faith"", ""sweet"", ""grays"", ""teams"", ""adder"", ""miffs"", ""tubae"", ""marin"", ""folds"", ""basis"", ""drugs"", ""prick"", ""tucks"", ""fifth"", ""treks"", ""taney"", ""romps"", ""jerry"", ""bulgy"", ""anton"", ""codes"", ""bones"", ""quota"", ""turns"", ""melts"", ""croat"", ""woken"", ""wried"", ""leash"", ""spacy"", ""bless"", ""lager"", ""rakes"", ""pukes"", ""cushy"", ""silks"", ""auden"", ""dotes"", ""hinge"", ""noisy"", ""coked"", ""hiked"", ""garth"", ""natty"", ""novel"", ""peeve"", ""macaw"", ""sloth"", ""warns"", ""soles"", ""lobed"", ""aimee"", ""toads"", ""plugs"", ""chasm"", ""pries"", ""douse"", ""ruled"", ""venus"", ""robes"", ""aglow"", ""waves"", ""swore"", ""strum"", ""stael"", ""seeps"", ""snots"", ""freed"", ""truck"", ""hilly"", ""fixer"", ""rarer"", ""rhyme"", ""smugs"", ""demos"", ""ships"", ""piped"", ""jumpy"", ""grant"", ""dirty"", ""climb"", ""quell"", ""pulps"", ""puers"", ""comte"", ""kirks"", ""waver"", ""fever"", ""swear"", ""straw"", ""serum"", ""cowed"", ""blent"", ""yuppy"", ""ropes"", ""conks"", ""boozy"", ""feeds"", ""japes"", ""auger"", ""noons"", ""wench"", ""tasty"", ""honed"", ""balms"", ""trams"", ""pasha"", ""mummy"", ""tides"", ""shove"", ""shyer"", ""trope"", ""clash"", ""promo"", ""harem"", ""never"", ""humus"", ""burks"", ""plans"", ""tempi"", ""crude"", ""vocal"", ""lames"", ""guppy"", ""crime"", ""cough"", ""rural"", ""break"", ""codex"", ""baggy"", ""camry"", ""muses"", ""exile"", ""harte"", ""evens"", ""uriel"", ""bombs"", ""wrens"", ""goren"", ""clark"", ""groom"", ""tinny"", ""alias"", ""irwin"", ""ruddy"", ""twins"", ""rears"", ""ogden"", ""joker"", ""shaky"", ""sodas"", ""larch"", ""lelia"", ""longs"", ""leeds"", ""store"", ""scars"", ""plush"", ""speck"", ""lamar"", ""baser"", ""geeky"", ""wilda"", ""sonny"", ""gummy"", ""porch"", ""grain"", ""testy"", ""wreck"", ""spurs"", ""belie"", ""ached"", ""vapid"", ""chaos"", ""brice"", ""finks"", ""lamed"", ""prize"", ""tsars"", ""drubs"", ""direr"", ""shelf"", ""ceres"", ""swops"", ""weirs"", ""vader"", ""benet"", ""gurus"", ""boors"", ""mucky"", ""gilds"", ""pride"", ""angus"", ""hutch"", ""vance"", ""candy"", ""pesky"", ""favor"", ""glenn"", ""denim"", ""mines"", ""frump"", ""surge"", ""burro"", ""gated"", ""badge"", ""snore"", ""fires"", ""omens"", ""sicks"", ""built"", ""baits"", ""crate"", ""nifty"", ""laser"", ""fords"", ""kneel"", ""louse"", ""earls"", ""greed"", ""miked"", ""tunic"", ""takes"", ""align"", ""robed"", ""acres"", ""least"", ""sleek"", ""motes"", ""hales"", ""idled"", ""faked"", ""bunks"", ""biped"", ""sowed"", ""lucky"", ""grunt"", ""clear"", ""flops"", ""grill"", ""pinch"", ""bodes"", ""delta"", ""lopes"", ""booms"", ""lifer"", ""stunk"", ""avery"", ""wight"", ""flaps"", ""yokel"", ""burgs"", ""racks"", ""claus"", ""haled"", ""nears"", ""finns"", ""chore"", ""stove"", ""dunce"", ""boles"", ""askew"", ""timid"", ""panic"", ""words"", ""soupy"", ""perks"", ""bilge"", ""elias"", ""crush"", ""pagan"", ""silts"", ""clive"", ""shuck"", ""fulls"", ""boner"", ""claws"", ""panza"", ""blurb"", ""soaks"", ""skips"", ""shape"", ""yells"", ""raved"", ""poppy"", ""lease"", ""trued"", ""minks"", ""estes"", ""aisle"", ""penes"", ""kathy"", ""combo"", ""viper"", ""chops"", ""blend"", ""jolly"", ""gimpy"", ""burma"", ""cohan"", ""gazer"", ""drums"", ""gnaws"", ""clone"", ""drain"", ""morns"", ""wages"", ""moths"", ""slues"", ""slobs"", ""warps"", ""brand"", ""popes"", ""triad"", ""ounce"", ""stilt"", ""shins"", ""greer"", ""hodge"", ""minos"", ""tweed"", ""sexed"", ""alger"", ""floss"", ""timer"", ""steve"", ""birch"", ""known"", ""aryan"", ""hedge"", ""fully"", ""jumps"", ""bites"", ""shots"", ""curer"", ""board"", ""lenin"", ""corns"", ""dough"", ""named"", ""kinda"", ""truce"", ""games"", ""lanes"", ""suave"", ""leann"", ""pesos"", ""masks"", ""ghats"", ""stows"", ""mules"", ""hexes"", ""chuck"", ""alden"", ""aping"", ""dives"", ""thurs"", ""nancy"", ""kicks"", ""gibed"", ""burly"", ""sager"", ""filly"", ""onset"", ""anons"", ""yokes"", ""tryst"", ""rangy"", ""pours"", ""rotes"", ""hided"", ""touch"", ""shads"", ""tonya"", ""finer"", ""moors"", ""texas"", ""shoot"", ""tears"", ""elope"", ""tills"" ];21
"
"Sum Root To Leaf Numbers"	"Time : O(); Space: O()
 
 Given a binary tree containing digits from 0-9 only,                       
 each root-to-leaf path could represent a number.                            
 An example is the root-to-leaf path 1->2->3 which represents the number 123.
 Find the total sum of all root-to-leaf numbers.                             
 
{@link https://leetcode.com/problems/sum-root-to-leaf-numbers/ }
 1. construct StringBuilder using integer."	"sumNumbers"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public int sumNumbers(BinaryTreeNode<Integer> root) {
        if (root == null) {
            return 0;
        }
        List<StringBuilder> numStrs = sumNumbersList(root);
        int result = 0;
        for (StringBuilder numStr : numStrs) {
            result += Integer.parseInt(numStr.toString());
        }
        return result;
    }

    List<StringBuilder> sumNumbersList (BinaryTreeNode<Integer> root) {
        List<StringBuilder> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        if (root.left == null && root.right == null) {
            // reaching leaf node
            result.add(new StringBuilder("""" + root.data));
            return result;
        }
        result.addAll(sumNumbersList(root.left));
        result.addAll(sumNumbersList(root.right));
        String digit = """" + root.data;
        for (StringBuilder strBuilder : result) {
            strBuilder.insert(0, digit);
        }
        return result;
    }
}
```"	"binary_tree(int)[root];int
[1, 2, 3];25
[1, 2, null, 3];123
[1, null, 2, null, 3];123
[1, 2, 7, null, 4, null, 3, 5, 6];2664
[1, null];1
"
"Surrounded Regions"	"Time : O(); Space: O()
 
 Given a 2D board containing 'X' and 'O', capture all regions         
 surrounded by 'X'.                                                   
 A region is captured by flipping all 'O's into 'X's in               
 that surrounded region.                                              
 
{@link https://leetcode.com/problems/surrounded-regions/ }"	"solve"	"### Java
```java
public class Solution {

    /**
     * Label those ""0""s that are qualified for ""X"",  and then flip qualified 
     * ""0""s to ""X""s.
     * BFS from each ""0"" in boundary, and label all reachable ""0"" as ""B"".
     * These ""B""s will not be changed to ""X"" because they are not within 
     * regions ""completely"" surrounded by ""X"".
     * Then visit each cell in board and flip ""0"" to ""X"", flip ""B"" back to ""0"".
     */
    public String[][] solve(String[][] board) {
        if (board.length == 0 || board[0].length == 0) {
            return board;
        }
        int rows = board.length;
        int cols = board[0].length;
        // label reachable ""0""s from ""0"" in boundary
        for (int col = 0; col < cols; col++) {
            // 1st row
            bfs(board, 0, col, rows, cols);
            // last row
            bfs(board, rows - 1, col, rows, cols);
        }
        for (int row = 0; row < rows; row++) {
            // 1st column
            bfs(board, row, 0, rows, cols);
            // last column
            bfs(board, row, cols - 1, rows, cols);
        }

        // flip remaining ""0""s to ""X"" and ""B"" back to ""0""
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j].equals(""0"")) {
                    board[i][j] = ""X"";
                } else if (board[i][j].equals(""B"")) {
                    board[i][j] = ""0"";
                }
            }
        }
        return board;
    }

    private void bfs(String[][] board, int row, int col, int rows, int cols) {
        if (!board[row][col].equals(""0"")) {
            return;
        }
        // find all reachable ""0""s from board[row][col]
        Queue<Integer> reach = new LinkedList<>();
        reach.add(row * cols + col);
        while (!reach.isEmpty()) {
            int index = reach.poll();
            int r = index / cols;
            int c = index % cols;
            if (r >= 0 && r < rows
                    && c >= 0 && c < cols
                    && board[r][c].equals(""0"")) {
                board[r][c] = ""B"";
                reach.add(r * cols + c); 
                reach.add((r + 1) * cols + c);
                reach.add((r - 1) * cols + c);
                reach.add(r * cols + (c - 1));
                reach.add(r * cols + (c + 1));
            }
        }
    }
}
```"	"array(array(string))[board];array(array(string))
[];[]
[[""X"", ""X"", ""X"", ""X""], [""X"", ""0"", ""0"", ""X""], [""X"", ""X"", ""0"", ""X""], [""X"", ""0"", ""X"", ""X""]];[[""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""0"", ""X"", ""X""]]
[[""X"", ""X"", ""X"", ""X""], [""X"", ""0"", ""0"", ""X""], [""X"", ""0"", ""0"", ""X""], [""X"", ""X"", ""X"", ""X""]];[[""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""]]
[[""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""]];[[""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0""]]
[[""X"", ""X"", ""X"", ""X""], [""X"", ""0"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""0"", ""X""]];[[""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""0"", ""X""]]
[[""X"", ""X"", ""0"", ""0""], [""0"", ""X"", ""X"", ""X""], [""X"", ""0"", ""X"", ""X""], [""X"", ""0"", ""0"", ""X""]];[[""X"", ""X"", ""0"", ""0""], [""0"", ""X"", ""X"", ""X""], [""X"", ""0"", ""X"", ""X""], [""X"", ""0"", ""0"", ""X""]]
[[""X"", ""X"", ""X""], [""X"", ""0"", ""X""], [""X"", ""X"", ""X""]];[[""X"", ""X"", ""X""], [""X"", ""X"", ""X""], [""X"", ""X"", ""X""]]
"
"Palindrome Partitioning"	"Time : O(2^n); Space: O(2^n)
 
Description:
 Given a string s, partition s such that every substring of the 
 partition is a palindrome. 
 Return all possible palindrome partitioning of s. 
 
 For example, given s = ""aab"", 
 Return 
     [ 
         [""aa"",""b""], 
         [""a"",""a"",""b""] 
     ]
     
 
{@link https://leetcode.com/problems/palindrome-partitioning/ }"	"partition"	"### Java
```java
public class Solution {
    
    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        int index = 0;
        List<String> path = new ArrayList<>();
        partition(s, index, path, result);
        return  result;
    }

    // backtracking
    private void partition(String s, int index, List<String> path,
            List<List<String>> result) {
        // base case
        if (index == s.length()) {
            result.add(path);
            return;
        }
        // recursive case
        for (int i = index; i < s.length(); i++) {
            String sub = s.substring(index, i + 1);
            if (isPalindrome(sub)) {
                List<String> newPath = new ArrayList<String>(path);
                newPath.add(sub);
                // go on searching
                partition(s, i + 1, newPath, result);
            }
        }
    }
    
    private Map<String, Boolean> memo = new HashMap<>();

    private boolean isPalindrome(String sub) {
        if (memo.containsKey(sub)) {
            return memo.get(sub);
        }
        boolean ispalin = true;
        for (int i = 0, j = sub.length() - 1; i < j; i++, j--) {
            if (sub.charAt(i) != sub.charAt(j)) {
                ispalin = false;
                break;
            }
        }
        memo.put(sub, ispalin);
        return ispalin;
    }
}
```"	"string[s];list(list(string))
""aab"";[[""aa"",""b""],[""a"",""a"",""b""]]
""a"";[[""a""]]
""abbab"";[[""a"",""b"",""b"",""a"",""b""],[""a"",""b"",""bab""],[""a"",""bb"",""a"",""b""],[""abba"",""b""]]
"
"Single Number"	"Time : O(N) ; Space: O(1)
 
Description:
Given an array of integers, every element appears twice except for one. 
Find that single one. 
Note: 
Your algorithm should have a linear runtime complexity. Could you 
implement it without using extra memory?
 
{@link https://leetcode.com/problems/single-number/ }"	"singleNumber"	"### Java
```java
public class Solution {

    public int singleNumber(int[] nums) {
        if (nums.length <= 0) {
            return 0;
        }
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            // xor operation: using the trick
            // same number ^ same number = 0
            result ^= nums[i];
        }
        return result;
    }
}
```"	"array(int)[nums];int
[];0
[ 1 ];1
[ 1, 2, 2 ];1
[ 2, 1, 2 ];1
"
"Word Break"	"Time : O(n^2); Space: O(1)
 
Description:
Given a string s and a dictionary of words dict, determine if s can be 
segmented into a space-separated sequence of one or more dictionary words. 
For example, given s = ""leetcode"", dict = [""leet"", ""code""]. 
Return true because ""leetcode"" can be segmented as ""leet code"".
 
{@link: https://leetcode.com/problems/word-break/ }"	"wordBreak"	"### Java
```java
public class Solution {

    /**
     * Check the whole string is breakable first.
     * If not breakable, then all other operations are a waste of time.
     */
    public List<String> wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        // check whether whole string can be broken
        if (!wordBreakOk(s, wordDict)) {
            return new ArrayList<>();
        }

        // initialize
        List<List<String>> dp = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            dp.add(new ArrayList<>());
        }
        dp.get(n).add("""");

        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j <= n; j++) {
                String word = s.substring(i, j);
                if (wordDict.contains(word)) {
                    for (String sentence : dp.get(j)) {
                        StringBuilder sb = new StringBuilder(word);
                        if (!sentence.isEmpty()) {
                            // append white space between words
                            sb.append("" "").append(sentence);
                        }
                        dp.get(i).add(sb.toString());
                    }
                }
            }
        }
        return dp.get(0);
    }

    // solution from word break I
    private boolean wordBreakOk(String s, List<String> wordDict) {
        int len = s.length();
        // whether s[i : end] can be successfully broken
        boolean[] dp = new boolean[len + 1];
        dp[len] = true;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j <= len; j++) {
                if (wordDict.contains(s.substring(i, j)) && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[0];
    }
}
```"	"string[s];list(string)[wordDict];list(string)
""catsanddog"";[""cat"",""cats"",""and"",""sand"",""dog""];[""cats and dog"",""cat sand dog""]
""haha"";[""cat"",""cats"",""and"",""sand"",""dog""];[]
""catscatanddog"";[""cat"",""cats"",""and"",""sand"",""dog""];[""cats cat and dog""]
""dogcat"";[""cat"",""dog"",""dogcat""];[""dogcat"",""dog cat""]
""baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"";[""a"", ""aa"", ""aaa"", ""aaaa"", ""aaaaa"", ""aaaaaa"", ""aaaaaaa"", ""aaaaaaaa"", ""aaaaaaaaa"", ""aaaaaaaaaa""];[]
""baab"";[""a"", ""aa"", ""ab"", ""b"", ""ba""];[""b a a b"", ""b a ab"", ""b aa b"", ""ba a b"", ""ba ab""]
"
"Linked List Cycle"	"Time : O(N); Space: O(1)
{@link https://leetcode.com/problems/linked-list-cycle/ }"	"hasCycle"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    public boolean hasCycle(ListNode<Integer> head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode<Integer> fast = head.next;
        ListNode<Integer> slow = head;
        while (fast != null && fast.next != null) {
            if (fast == slow || fast.next == slow) {
                return true;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return false;
    }
}
```"	"linked_list(int)[head];bool
[1,1,2,2,3,3,4];false
[1,1,2,2,3,3,4,0];true
[1,1,2,2,3,3,4,1];true
[1,1,2,2,3,3,4,3];true
[1];false
[1,0];true
"
"Linked List Cycle I I"	"Time : O(N); Space : O(N)
 
Description: 
Given a linked list, return the node where the cycle begins. 
If there is no cycle, return null. 
Follow up: 
Can you solve it without using extra space?
 
{@link https://leetcode.com/problems/linked-list-cycle-ii/ }"	"detectCycle"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {
    
    public ListNode<Integer> detectCycle(ListNode<Integer> head) {
        if (head == null) {
            return head;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow.next) {
                break;
            }
        }
        // no cycle
        if (fast == null || fast.next == null) {
            return null;
        }
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}
```"	"linked_list(int)[head];linked_list(int)
[3,1,4,2,0,3,-2,1];[4,0,-2]
[3];[]
[3];[3]
[1,1,2,2,3,2];[3]
[1,1,2,2,3];[]
"
"Reorder List"	"Time : O(N) ; Space: O(1)
 
Description:
Given a singly linked list L: L0→L1→…→Ln-1→Ln, 
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… 
You must do this in-place without altering the nodes' values. 
For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.
 
{@link https://leetcode.com/problems/reorder-list/ }"	"reorderList"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {
    public ListNode<Integer> reorderList(ListNode<Integer> head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode<Integer> dummy = new ListNode<>();
        ListNode<Integer> fast = head;
        ListNode<Integer> slow = head;
        // let slow stops at the middle node
        while (fast != null && fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // reverse from slow.next to end
        ListNode<Integer> preMiddle = slow;
        ListNode<Integer> preCurrent = slow.next;
        while (preCurrent.next != null) {
            ListNode current = preCurrent.next;
            preCurrent.next = current.next;
            current.next = preMiddle.next;
            preMiddle.next = current;
        }

        ListNode<Integer> l2 = preMiddle.next;
        slow.next = null;

        // merge two lists (l2 might be one node less than l1)
        ListNode<Integer> l1 = head;
        ListNode<Integer> node = dummy;
        while (l2 != null) {
            node.next = l1;
            l1 = l1.next;
            node = node.next;
            node.next = l2;
            l2 = l2.next;
            node = node.next;
        }
        // last node in list1
        node.next = l1;

        return head;
    }
}
```"	"linked_list(int)[head];linked_list(int)
[1,1,2,2,3,3,4];[ 1, 4, 2, 3 ]
[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8];[ 1, 8, 2, 7, 3, 6, 4, 5 ]
[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9];[ 1, 9, 2, 8, 3, 7, 4, 6, 5 ]
[1];[ 1 ]
"
"Binary Tree Preorder Traversal"	"Time : O(); Space: O()
 
Description: 
Given a binary tree, return the preorder traversal of its nodes' values.
 
{@link https://leetcode.com/problems/binary-tree-preorder-traversal/ }"	"preorderTraversal"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

// iterative version
public class Solution {

    // Solution1: push right child before pushing left child
    public List<Integer> preorderTraversal(BinaryTreeNode<Integer> root) {
        List<Integer> result = new ArrayList<>();
        Stack<BinaryTreeNode<Integer>> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            BinaryTreeNode<Integer> node = stack.pop();
            if (node != null) {
                result.add(node.data);
                // push right child before pushing left child
                stack.add(node.right);
                stack.add(node.left);
            }
        }
        return result;
    }
}
```"	"binary_tree(int)[root];list(int)
null;[]
[1, null, 2, 3];[1, 2, 3]
[1, 2, 3, 4, 5, 6, 7];[1, 2, 3, 4, 5, 6, 7]
[1, null];[1]
[1, 2, null, 3];[1, 2, 3]
[1, null, 2, null, 3];[1, 2, 3]
[5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1];[5, 4, 11, 7, 2, 8, 13, 4, 5, 1]
[10, 5, 12, 4, 7];[10, 5, 4, 7, 12]
"
"Insertion Sort List"	"Time : O(N); Space: O(1)
 
Description: 
Sort a linked list using insertion sort.
 
 
{@link https://leetcode.com/problems/insertion-sort-list/ }"	"insertionSortList"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

    // insert node from the list into the newly constructed list.
    public ListNode<Integer> insertionSortList(ListNode<Integer> head) {
        ListNode<Integer> dummy = new ListNode<>();
        ListNode<Integer> listHead = head;
        ListNode<Integer> node = dummy;
        // insert each node from head list
        while (listHead != null) {
            node = dummy;
            while (node.next != null && node.next.data < listHead.data) {
                node = node.next;
            }
            // l1:       insert(listHead) --------> listHead.next
            // l2:  node  --------->  node.next
            // keep the head of l1 and move its head to its next node
            // then insert the original head between 'node' and 'node.next'
            ListNode insert = listHead;
            listHead = listHead.next;
            insert.next = node.next;
            node.next = insert;
        }
        return dummy.next;
    }
}
```"	"linked_list(int)[head];linked_list(int)
[1,1,2,2,3,3,4,4,5];[1,2,3,4,5]
[1,1,5,2,3,3,2,4,4];[1,2,3,4,5]
[5,1,4,2,3,3,2,4,1];[1,2,3,4,5]
[5];[5]
"
"Sort List"	"Time : O(nlgn) ; Space: O(1)
 
Description:
 
Sort a linked list in O(n log n) time using constant space complexity.
 
{@link https://leetcode.com/problems/sort-list/ }"	"sortList"	"### Java
```java
class ListNode<T> {
    T data;
    ListNode<T> next;

    public ListNode() { }

    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

public class Solution {

     // simulating merge sort on linked list
    public ListNode<Integer> sortList(ListNode<Integer> head) {
        // base case
        if (head == null || head.next == null) {
            return head;
        }

        // find the middle node
        ListNode<Integer> fast = head.next;
        ListNode<Integer> slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        // cut list into two halves
        ListNode<Integer> second = slow.next;
        slow.next = null;

        // merge sort two parts
        ListNode<Integer> head1 = sortList(head);
        ListNode<Integer> head2 = sortList(second);
        ListNode<Integer> dummy = new ListNode();
        dummy.data = -1;
        ListNode<Integer> node = dummy;
        while (head1 != null && head2 != null) {
            if (head1.data < head2.data) {
                node.next = head1;
                head1 = head1.next;
            } else {
                node.next = head2;
                head2 = head2.next;
            }
            node = node.next;
        }
        // merge the remaining part
        node.next = head1 != null ? head1 : head2;
        return dummy.next;
    }
}
```"	"linked_list(int)[head];linked_list(int)
[];[]
[2];[2]
[1,1,2,2,3,3,4,4,5,5,6];[1,2,3,4,5,6]
[5,1,4,2,3,3,2,4,1];[1,2,3,4,5]
[4,1,6,2,2,3,7,4,91,5,1,6,10,7,23,8,5,9,5];[1,2,4,5,5,6,7,10,23,91]
[5,1,1,2,3,3,4,4,2];[1,2,3,4,5]
"
"Evaluate Reverse Polish Notation"	"Time : O(N); Space: O(N)
 
Description: 
Evaluate the value of an arithmetic expression in Reverse Polish Notation. 
Valid operators are +, -, , /. Each operand may be an integer or another expression. 
Some examples: 
 [""2"", ""1"", ""+"", ""3"", """"] -> ((2 + 1)3) -> 9 
 [""4"", ""13"", ""5"", ""/"", ""+""] -> (4 + (13 / 5)) -> 6
 
{@link https://leetcode.com/problems/evaluate-reverse-polish-notation/ }
-----------------------------------------------------------------------
1. use interface as work-around for lambda expression in Java
2. two-brace initialization for hash map"	"eval"	"### Java
```java
public class Solution {

    /** use interface as work-around for lambda expression */
    public interface Operator {
        int eval(int x, int y);
    }

    /**
     * global map for operator and its corresponding operation
     */
    public static final Map<String, Operator> OperatorMap = new HashMap<String, Solution.Operator>() {
        {
            put(""+"", new Operator() {
                public int eval(int x, int y) {
                    return x + y;
                }
            });
            put(""-"", new Operator() {
                public int eval(int x, int y) {
                    return x - y;
                }
            });
            put(""*"", new Operator() {
                public int eval(int x, int y) {
                    return x * y;
                }
            });
            put(""/"", new Operator() {
                public int eval(int x, int y) {
                    return x / y;
                }
            });
        }
    };

    /**
     * For operands (numbers), push them into stack for later use;
     * For operators (+,-,*,/), retrieve the latest two operands in stack
     * , evaluate the result and then push the result back to stack 
     */
    public int eval(String[] tokens) {
        Stack<Integer> operands = new Stack<Integer>();
        for (String token : tokens) {
            if (OperatorMap.containsKey(token)) {
                // for operator: calculate operation and then push to stack
                int op2 = operands.pop();
                int op1 = operands.pop();
                operands.push(OperatorMap.get(token).eval(op1, op2));
            } else {
                // for operand: push to stack
                operands.push(Integer.parseInt(token));
            }
        }
        return operands.pop();
    }
}
```"	"array(string)[tokens];int
[""2"", ""1"", ""+"", ""3"", ""*""];9
[""4"", ""13"", ""5"", ""/"", ""+""];6
[""4"", ""13"", ""+""];17
[""8"", ""4"", ""/""];2
[""8"", ""4"", ""-""];4
[""8"", ""4"", ""-"", ""3"", ""+"", ""2"", ""*""];14
"
"Reverse Words In A String"	"Time : O(N); Space : O(N)
 
Description: 
Given an input string, reverse the string word by word. 
For example, 
 Given s = ""the sky is blue"", 
 return ""blue is sky the"".
 
Note: 1) removing all leading and trailing spaces 
      2) there might be multiple spaces between words
      
 
{@link https://leetcode.com/problems/reverse-words-in-a-string/ }"	"reverseWords"	"### Java
```java
/**
 * 1. what is ""word""?
 * 2. how to deal with leading and trailing spaces?
 * 3. how to deal with multiple space between words? 
 */
public class Solution {

    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        int end = s.length();
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == ' ') {
                // jump blank space
                end = i;
            } else if (i == 0 || s.charAt(i - 1) == ' ') {
                // at the beginning index of a word
                if (sb.length() != 0) {
                    sb.append(' ');
                }
                sb.append(s.substring(i, end));
            }
        }
        return sb.toString();
    }
}
```"	"string[s];string
""the sky is blue"";""blue is sky the""
""fwbpudnbrozzifml osdt ulc jsx kxorifrhubk ouhsuhf sswz qfho dqmy sn myq igjgip iwfcqq"";""iwfcqq igjgip myq sn dqmy qfho sswz ouhsuhf kxorifrhubk jsx ulc osdt fwbpudnbrozzifml""
"" "";""""
""abc "";""abc""
"" ab cd ef "";""ef cd ab""
"
"Maximum Product Subarray"	"Time : O(N); Space: O(1)
 
Description: 
Find the contiguous subarray within an array (containing at least one 
number) which has the largest product. 
For example, given the array [2,3,-2,4], 
the contiguous subarray [2,3] has the largest product = 6.
 
 
{@link https://leetcode.com/problems/maximum-product-subarray/ }"	"maxProduct"	"### Java
```java
public class Solution {

    public int maxProduct(int[] nums) {
        int n = nums.length;
        if (n <= 0) {
            return 0;
        }
        // initialize
        int res = nums[0];
        int max = nums[0];  // max product that ending at current index
        int min = nums[0];  // min product that ending at current index

        for (int i = 1; i < n; i++) {
            int num = nums[i];
            int lmax = max * num;
            int lmin = min * num;
            max = Math.max(num, Math.max(lmax, lmin));
            min = Math.min(num, Math.min(lmax, lmin));
            res = Math.max(res, max);
        }
        return res;
    }
}
```"	"array(int)[nums];int
[ 2, 3, -2, 4 ];6
[ 2, 3, 2, 4 ];48
[ -2, -3, -2, -4 ];48
[ 2, -3, 2, 1 ];2
[ 2, -3, 2, -1 ];12
"
"Find Minimum In Rotated Sorted Array"	"Time : O(lgN) ; Space: O(1)
 
Description:
 
Suppose a sorted array is rotated at some pivot unknown to you beforehand. 
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). 
Find the minimum element. You may assume no duplicate exists in the array.
 
{@link https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ }"	"findMin"	"### Java
```java
public class Solution {

    public int findMin(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                // nums[mid] <= nums[right], so mid might be the result
                right = mid;
            }
        }
        return nums[left];
    }
}
```"	"array(int)[nums];int
[ 2 ];2
[ 0, 1, 2, 3 ];0
[ 3, 4, 2 ];2
[ 3, 1, 2 ];1
[ 0, 1, 2, 3, 4, 5 ];0
[ 4, 0, 1, 2, 3 ];0
[ 2, 3, 4, 0, 1 ];0
"
"Longest Substring With At Most Two Distinct Characters"	"Time : O(N) ; Space: O(N)
 
Description:
Given a string, find the length of the longest substring T that contains 
at most 2 distinct characters. 
For example, Given s = “eceba”, T is ""ece"" which its length is 3.
 
{@link https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/ }"	"lengthOfLongestSubstringTwoDistinct"	"### Java
```java
public class Solution {
    
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int res = 0;
        // char, first appearance after the other char in current window
        Map<Character, Integer> map = new HashMap<>();
        int start = 0;
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (map.size() < 2) {
                // less than two characters in current window
                if (!map.containsKey(ch)) {
                    map.put(ch, i);
                }
            } else if (map.containsKey(ch)) {
                // duplicates appears, update index
                if (s.charAt(i - 1)  != ch) {
                    map.put(ch, i);
                }
            } else {
                // 3rd character appears
                start = map.get(s.charAt(i - 1));
                map = new HashMap<>();
                map.put(s.charAt(i - 1), start);
                map.put(ch, i);
            }
            // update global result
            if (i - start + 1 > res) {
                res = i - start + 1;
            }
        }
        return res;
    }
}
```"	"string[s];int
""eceba"";3
""aaaa"";4
""bbaabb"";6
""bbaabbc"";6
""bbacabbc"";3
"
"One Edit Distance"	"Time : O(N) ; Space: O(1)
 
Description:
 
Given two strings S and T, determine if they are both one edit distance apart.
 
{@link https://leetcode.com/problems/one-edit-distance/ }"	"isOneEditDistance"	"### Java
```java
public class Solution {
    
    // one edit distance:
    // 1) equal length: only one substitution
    // 2) lengths diff by 1: skip one on longer string, then rest should be the same 
    public boolean isOneEditDistance(String s, String t) {
        if (s.length() > t.length()) {
            return isOneEditDistance(t, s);
        }
        if (s.length() + 1 < t.length()) {
            return false;
        }
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != t.charAt(i)) {
                if (s.length() == t.length()) {
                    return s.substring(i + 1).equals(t.substring(i + 1));
                } else {
                    return s.substring(i).equals(t.substring(i + 1));
                }
            }
        }
        // no different characters found so far then they must have different length
        return s.length() < t.length();
    }

    public boolean isOneEditDistance_Verbose(String s, String t) {
        if (s.length() > t.length()) {
            return isOneEditDistance(t, s);
        }
        if (t.length() - s.length() > 1) {
            return false;
        }
        int i = 0;
        int j = 0;
        boolean diff = false;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) != t.charAt(j)) {
                if (diff) {
                    return false;
                } else {
                    diff = true;
                    if (s.length() == t.length()) {
                        // substitute
                    } else {
                        // jump one in longer string
                        i--;
                    }
                }
            }
            i++;
            j++;
        }
        return diff || s.length() + 1 == t.length();
    }
}
```"	"string[s];string[s];bool
""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxGzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"";""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstUvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"";false
""aa"";""ab"";true
""aa"";""a"";true
""aa"";""aaa"";true
""aa"";""cb"";false
""adafjaa"";""cbadf"";false
""cb"";""ab"";true
""teacher"";""tache"";false
"
"Find Peak Element"	"Time : O(lgN) ; Space: O(1)
 
Description:
A peak element is an element that is greater than its neighbors. 
Given an input array where num[i] ≠ num[i+1], find a peak element and 
return its index. 
The array may contain multiple peaks, in that case return the index to 
any one of the peaks is fine. 
You may imagine that num[-1] = num[n] = -∞. 
For example, in array [1, 2, 3, 1], 3 is a peak element and your 
function should return the index number 2.
 
{@link https://leetcode.com/problems/find-peak-element/ }"	"findPeakElement"	"### Java
```java
public class Solution {

    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```"	"array(int)[nums];int
[ 1, 2, 0 ];1
[ 1, 2, 3, 1 ];2
[ 1, 2, 3, 4, 10, 9, 5, 9, 5, 9, 5, 10, 9, 8, 7, 5 ];4
[ 1, 2, 1, 3, 4, 5, 7, 6 ];6
[ 1, 10, 9, 8, 7, 6, 5, 4 ];1
[ 1 ];0
[ 1, 2 ];1
[ 2, 1 ];0
"
"Missing Ranges"	"Time : O(N) ; Space: O()
 
Description:
Given a sorted integer array where the range of elements are [lower, upper] 
inclusive, return its missing ranges. 
For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, 
return [""2"", ""4->49"", ""51->74"", ""76->99""].
 
{@link https://leetcode.com/problems/missing-ranges/ }"	"findMissingRanges"	"### Java
```java
public class Solution {

    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> res = new ArrayList<>();
        int exp = lower;
        int i = 0;
        // don't forget the last possible missing range
        while (i <= nums.length && exp <= upper) {
            int num = i == nums.length ? upper + 1 : nums[i];
            if (num > upper) {
                num = upper + 1;
            }
            if(num != exp) {
                StringBuilder sb = new StringBuilder("""" + exp);
                if (num != exp + 1) {
                    sb.append(""->"").append(num - 1);
                } 
                res.add(sb.toString());
            }
            exp = num + 1;
            i++;
        }
        return res;
    }
}
```"	"array(int)[nums];int[lower];int[upper];list(string)
[ 0, 1, 3, 50, 75 ];0;99;[""2"", ""4->49"", ""51->74"", ""76->99""]
[ 0, 1, 2, 3 ];0;3;[]
[ 1, 3, 5 ];0;5;[""0"",""2"",""4""]
[ 3, 6 ];0;5;[""0->2"",""4->5""]
"
"Fraction To Recurring Decimal"	"Time : O() ; Space: O()
 
Description:
Given two integers representing the numerator and denominator of a fraction, 
return the fraction in string format. 
If the fractional part is repeating, enclose the repeating part in parentheses. 
For example, 
 Given numerator = 1, denominator = 2, return ""0.5"". 
 Given numerator = 2, denominator = 1, return ""2"". 
 Given numerator = 2, denominator = 3, return ""0.(6)"".
 
{@link https://leetcode.com/problems/fraction-to-recurring-decimal/ }
1. big integer : stack overflow issue"	"fractionToDecimal"	"### Java
```java
public class Solution {

    public String fractionToDecimal(int numerator, int denominator) {
        if (denominator == 0) {
            return """";
        }
        if (numerator == 0) {
            return ""0"";
        }
        StringBuilder sb = new StringBuilder();
        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {
            sb.append(""-"");
        }
        long num = Math.abs((long) numerator);
        long den = Math.abs((long) denominator);

        // integral part
        sb.append(num / den);
        if (num % den == 0) {
            return sb.toString();
        }
        sb.append(""."");

        // decimal part
        num = num % den * 10;
        Map<Long, Integer> index = new HashMap<>();
        int recur = -1;
        while (num != 0) {
            if (index.containsKey(num)) {
                recur = index.get(num);
                break;
            }
            index.put(num, sb.length());
            sb.append(num / den);
            num = num % den * 10;
        }
        if (recur != -1) {
            sb.insert(recur, ""("");
            sb.append("")"");
        }
        return sb.toString();
    }
}
```"	"int[numerator];int[denominator];string
1;2;""0.5""
2;1;""2""
2;3;""0.(6)""
1;3;""0.(3)""
1;4;""0.25""
1;999;""0.(001)""
199;99;""2.(01)""
4000;4;""1000""
240;4;""60""
1001;10;""100.1""
-1;10;""-0.1""
-1;-2147483648;""0.0000000004656612873077392578125""
-2147483648;-1;""2147483648""

"
"Binary Search Tree Iterator"	"Time : O() ; Space: O()
 
Description:
Implement an iterator over a binary search tree (BST). Your iterator will 
be initialized with the root node of a BST. 
Calling next() will return the next smallest number in the BST. 
Note: next() and hasNext() should run in average O(1) time and uses O(h) 
memory, where h is the height of the tree.
 
{@link https://leetcode.com/problems/binary-search-tree-iterator/ }"	"trailingZeroes"	"### Java
```java
public class Solution {
    public int trailingZeroes(int n) {
        int numberOf5 = 0;
        while (n != 0) {
            int count = n / 5;
            numberOf5 += count;
            n = count;
        }
        return numberOf5;
    }
}
```"	"int[n];int
4617;1151
26;6
1;0
-1;0
100;24
25;6
"
"Largest Number"	"Time : O(N^2); Space : O(N)
 
Description: 
Given a list of non negative integers, arrange them such that they form 
the largest number. 
For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. 
Note: The result may be very large, so you need to return a string instead of an integer.
 
{@link https://leetcode.com/problems/largest-number/  }"	"largestNumber"	"### Java
```java
public class Solution {
    public String largestNumber(int[] nums) {
        List<String> list = new ArrayList<>();
        for (int number : nums) {
            list.add("""" + number);
        }
        
        // sort list by combination of two numbers
        Collections.sort(list, new Comparator<String>(){
            @Override
            public int compare(String num1, String num2) {
                String s1 = num1 + num2;
                String s2 = num2 + num1;
                // not num1.compareTo(num2);
                return s2.compareTo(s1); 
            }
        });
        
        StringBuilder strBuilder = new StringBuilder();
        boolean allZeros = true;
        for (String str: list) {
            if (allZeros && !str.equals(""0"")) {
                allZeros = false;
            }
            strBuilder.append(str);
        }
        // for corner case all 0s
        return allZeros ? ""0"" : strBuilder.toString();
    }
}
```"	"array(int)[nums];string
[ 3, 30, 34, 5, 9];""9534330""
[ 0, 0, 0];""0""
[ 0, 1, 0 ];""100""
[ 1, 1, 1, 1, 1, 1, 1, 1, 1 ];""111111111""
[12, 121];""12121""
[12, 13];""1312""
[12, 123];""12312""
[12, 1201];""121201""
"
"Reverse Words In A String I I"	"Time : O(N) ; Space: O(1)
 
Description: 
Given an input string, reverse the string word by word. 
For example, 
 Given s = ""the sky is blue"", 
 return ""blue is sky the"".
 
Note: 1) no leading and trailing spaces 
      2) only one space between words
      3) do it in-place
 
{@link }"	"reverseWords"	"### Java
```java
public class Solution {
    
    public String reverseWords(String s) {
        // reverse the whole sentence
        char[] c = s.toCharArray();
        reverse(c, 0, c.length);
        // trick: how to include the last position
        for (int i = 0, j = 0; j <= c.length; j++) {
            if (j == c.length || c[j] == ' ') {
                reverse(c, i, j);
                i = j + 1;
            }
        }

        return String.valueOf(c);
    }

    private void reverse(char[] s, int start, int end) {
        int mid = (end - start) / 2;
        for (int i = 0; i < mid; i++) {
            char temp = s[start + i];
            s[start + i] = s[end - i - 1];
            s[end - i - 1] = temp;
        }
    }
}
```"	"string[s];string
""the sky is blue"";""blue is sky the""
""sky"";""sky""
""the sky"";""sky the""
"
"Binary Tree Right Side View"	"Time : O(N); Space : O(N)
 
Description: 
Given a binary tree, imagine yourself standing on the right side of it, 
return the values of the nodes you can see ordered from top to bottom. 
For example: 
Given the following binary tree,
     1       <--- 
   /   \ 
  2     3     <--- 
   \     \ 
    5     4     <--- 
You should return [1, 3, 4].
 
{@link https://leetcode.com/problems/binary-tree-right-side-view/ }"	"rightSideView"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

/**
 * Summary:
 * 1. two-queue classic BFS, one for current level, one for next level (see solution below)
 *
 * 2. one-queue classic BFS, count size of queue before iterating current level see {@link _199_BinaryTreeRightSideView.SolutionOneQueue }
 *
 * 3. use (DFS + level) to achieve level reversal traversal, once a deeper level appears, add that element
 *
 * 4. DFS, combine result from right subtree and uncovered elements from left subtree (see {@link _199_BinaryTreeRightSideView.SolutionRecursive }
 */
public class Solution {

    /**
     * Traverse level by level and only keep the last element in each level and
     * can be improved by using only one queue
     * {@link _199_BinaryTreeRightSideView.SolutionOneQueue }
     */
    public List<Integer> rightSideView(BinaryTreeNode<Integer> root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Queue<BinaryTreeNode<Integer>> cur = new LinkedList<>();
        cur.add(root);

        while (!cur.isEmpty()) {
            Queue<BinaryTreeNode<Integer>> next = new LinkedList<>();
            while (!cur.isEmpty()) {
                BinaryTreeNode<Integer> node = cur.poll();
                // if this is the last node in this level
                if (cur.isEmpty()) {
                    result.add(node.data);
                }
                if (node.left != null) {
                    next.add(node.left);
                }
                if (node.right != null) {
                    next.add(node.right);
                }
            }
            // go to next level
            cur = next;
        }

        return result;
    }
}
```"	"binary_tree(int)[root];list(int)
null;[]
[1, 2, 3, null, 5, null, 4];[1, 3, 4]
[1, null, 2, null, 3];[1, 2, 3]
[1, 2, null, 3];[1, 2, 3]
[1, 2, 3];[1, 3]
[5, 4, 8, 11, null, 13, 4, 7, 2, 5, 1];[5, 8, 4, 1]
[10, 5, 12, 4, 7];[10, 12, 7]
[1, null, 2, 3];[1, 2, 3]
[5, 4, 8, null, null, 13, 14, null, null, 5, 1];[5, 8, 14, 1]
"
"Number Of Islands"	"Time : O(N); Space : O(1)
 
Description: 
Given a 2d grid map of '1's (land) and '0's (water), count the number of 
islands. An island is surrounded by water and is formed by connecting 
adjacent lands horizontally or vertically. You may assume all four edges 
of the grid are all surrounded by water. 
Example 1: 
     11110 
     11010 
     11000 
     00000 
Answer: 1 
Example 2: 
     11000 
     11000 
     00100 
     00011 
Answer: 3
 
{@link https://leetcode.com/problems/number-of-islands/ }
1. how to calculate index of 2d array (icols + j)"	"numIslands"	"### Java
```java
public class Solution {

    // DFS version
    public int numIslands(String[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length;
        int cols = grid[0].length;
        int result = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // label each reachable land from current position
                if (grid[i][j].equals(""1"")) {
                    labelReachableLand(i, j, rows, cols, grid);
                    result++;
                }
            }
        }
        // recover grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j].equals(""+"")) {
                    grid[i][j] = ""1"";
                }
            }
        }
        return result;
    }

    // DFS to label reachable land
    private void labelReachableLand(int i, int j, int rows, int cols, String[][] grid) {
        // base case
        if (i < 0 || i >= rows || j < 0 || j >= cols || !grid[i][j].equals(""1"")) {
            return;
        }
        // recursive case
        grid[i][j] = ""I"";   // label as visited
        labelReachableLand(i + 1, j, rows, cols, grid);
        labelReachableLand(i - 1, j, rows, cols, grid);
        labelReachableLand(i, j - 1, rows, cols, grid);
        labelReachableLand(i, j + 1, rows, cols, grid);
    }
}
```"	"array(array(string))[grid];int
[[ ""1"", ""1"", ""1"", ""1"", ""0"" ], [ ""1"", ""1"", ""0"", ""1"", ""0"" ], [ ""1"", ""1"", ""0"", ""0"", ""0"" ], [ ""0"", ""0"", ""0"", ""0"", ""0"" ]];1
[[ ""1"", ""1"", ""0"", ""0"", ""0"" ], [ ""1"", ""1"", ""0"", ""0"", ""0"" ], [ ""0"", ""0"", ""1"", ""0"", ""0"" ], [ ""0"", ""0"", ""0"", ""1"", ""1"" ]];3
[[ ""1"" ]];1
[[ ""0"" ]];0
[[ ""1"" ], [ ""1"" ], [ ""1"" ], [ ""1"" ], [ ""1"" ]];1
[[ ""1"" ], [ ""0"" ], [ ""1"" ], [ ""0"" ], [ ""0"" ]];2
[[ ""1"", ""1"", ""0"", ""1"" ]];2
"
"Course Schedule"	"Time : O(); Space : O()
 
Description: 
There are a total of n courses you have to take, labeled from 0 to n - 1. 
Some courses may have prerequisites, for example to take course 0 you have to
first take course 1, which is expressed as a pair: [0,1] 
Given the total number of courses and a list of prerequisite pairs, 
is it possible for you to finish all courses? 
For example: 
     2, [[1,0]] 
There are a total of 2 courses to take. To take course 1 you should have 
finished course 0. So it is possible. 
     2, [[1,0],[0,1]] 
There are a total of 2 courses to take. To take course 1 you should have 
finished course 0, and to take course 0 you should also have finished 
course 1. So it is impossible.
 
{@link https://leetcode.com/problems/course-schedule/ }"	"canFinish"	"### Java
```java
public class Solution {

    /*
     * 1. construct topological graph 2. count in-degrees for each node 3. for
     * zero in-degree nodes, put them to queue 4. BFS search if all nodes become
     * zero in-degree
     */
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // initialize graph
        List<Set<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new HashSet<>());
        }
        // construct graph and count in-degrees for each node
        int[] indegrees = new int[numCourses];
        for (int[] is : prerequisites) {
            if (graph.get(is[0]).add(is[1])) {
                // !avoid duplicates. Alternatively, make graph
                // List<List<Integer>>
                indegrees[is[1]]++;
            }
        }
        // push all 0 in-degree nodes into queue
        Queue<Integer> zeros = new LinkedList<>();
        for (int i = 0; i < indegrees.length; i++) {
            if (indegrees[i] == 0) {
                zeros.add(i);
            }
        }

        // BFS
        int count = 0;
        while (!zeros.isEmpty()) {
            int course = zeros.poll();
            count++;
            for (int request : graph.get(course)) {
                // count down in-degree for this prerequisite by one
                // and then if it is zero
                indegrees[request]--;
                if (indegrees[request] == 0) {
                    zeros.add(request);
                }
            }
        }
        return count == numCourses;
    }
}
```"	"int[numCourses];array(array(int))[prerequisites];bool
2;[ [ 1, 0 ] ];true
2;[ [ 1, 0 ], [ 0, 1 ] ];false
3;[ [ 1, 0 ], [ 2, 1 ], [ 0, 2 ]];false
3;[ [ 1, 0 ], [ 2, 1 ]];true
3;[ [ 1, 0 ], [ 2, 0 ], [ 2, 1 ]];true
4;[ [ 0, 1 ], [ 3, 1 ], [ 1, 3 ], [ 3, 2 ] ];false
"
"Minimum Size Subarray Sum"	"Time : O(N); Space : O(1)
 
Description: 
Given an array of n positive integers and a positive integer s, find 
the minimal length of a subarray of which the sum ≥ s. If there isn't 
one, return 0 instead. 
For example, given the array [2,3,1,2,4,3] and s = 7, 
the subarray [4,3] has the minimal length under the problem constraint. 
If you have figured out the O(n) solution, try coding another solution 
of which the time complexity is O(n log n).
 
{@link https://leetcode.com/problems/minimum-size-subarray-sum/ }"	"minSubArrayLen"	"### Java
```java
public class Solution {

    /* keep a sliding window using two pointers */
    public int minSubArrayLen(int[] nums, int s) {
        int res = Integer.MAX_VALUE;
        int cursum = 0;
        int start = 0;
        for (int end = 0; end < nums.length; end++) {
            int num = nums[end];
            cursum += num;
            while (start <= end && cursum >= s) {
                res = Math.min(res, end - start + 1);
                cursum -= nums[start++];
            }
        }
        return res < Integer.MAX_VALUE ? res : 0;
    }
}
```"	"array(int)[nums];int[s];int
[2, 3, 1, 2, 4, 3];7;2
[2, 3, 1, 2, 4, 3];18;0
[2, 3, 1, 2, 4, 3];15;6
[];0;0
[5];6;0
[6];6;1
[9];6;1
[5334, 6299, 4199, 9663, 8945, 3566, 9509, 3124, 6026, 6250, 7475, 5420, 9201, 9501, 38, 5897, 4411, 6638, 9845, 161, 9563, 8854, 3731, 5564, 5331, 4294, 3275, 1972, 1521, 2377, 3701, 6462, 6778, 187, 9778, 758, 550, 7510, 6225, 8691, 3666, 4622, 9722, 8011, 7247, 575, 5431, 4777, 4032, 8682, 5888, 8047, 3562, 9462, 6501, 7855, 505, 4675, 6973, 493, 1374, 3227, 1244, 7364, 2298, 3244, 8627, 5102, 6375, 8653, 1820, 3857, 7195, 7830, 4461, 7821, 5037, 2918, 4279, 2791, 1500, 9858, 6915, 5156, 970, 1471, 5296, 1688, 578, 7266, 4182, 1430, 4985, 5730, 7941, 3880, 607, 8776, 1348, 2974, 1094, 6733, 5177, 4975, 5421, 8190, 8255, 9112, 8651, 2797, 335, 8677, 3754, 893, 1818, 8479, 5875, 1695, 8295, 7993, 7037, 8546, 7906, 4102, 7279, 1407, 2462, 4425, 2148, 2925, 3903, 5447, 5893, 3534, 3663, 8307, 8679, 8474, 1202, 3474, 2961, 1149, 7451, 4279, 7875, 5692, 6186, 8109, 7763, 7798, 2250, 2969, 7974, 9781, 7741, 4914, 5446, 1861, 8914, 2544, 5683, 8952, 6745, 4870, 1848, 7887, 6448, 7873, 128, 3281, 794, 1965, 7036, 8094, 1211, 9450, 6981, 4244, 2418, 8610, 8681, 2402, 2904, 7712, 3252, 5029, 3004, 5526, 6965, 8866, 2764, 600, 631, 9075, 2631, 3411, 2737, 2328, 652, 494, 6556, 9391, 4517, 8934, 8892, 4561, 9331, 1386, 4636, 9627, 5435, 9272, 110, 413, 9706, 5470, 5008, 1706, 7045, 9648, 7505, 6968, 7509, 3120, 7869, 6776, 6434, 7994, 5441, 288, 492, 1617, 3274, 7019, 5575, 6664, 6056, 7069, 1996, 9581, 3103, 9266, 2554, 7471, 4251, 4320, 4749, 649, 2617, 3018, 4332, 415, 2243, 1924, 69, 5902, 3602, 2925, 6542, 345, 4657, 9034, 8977, 6799, 8397, 1187, 3678, 4921, 6518, 851, 6941, 6920, 259, 4503, 2637, 7438, 3893, 5042, 8552, 6661, 5043, 9555, 9095, 4123, 142, 1446, 8047, 6234, 1199, 8848, 5656, 1910, 3430, 2843, 8043, 9156, 7838, 2332, 9634, 2410, 2958, 3431, 4270, 1420, 4227, 7712, 6648, 1607, 1575, 3741, 1493, 7770, 3018, 5398, 6215, 8601, 6244, 7551, 2587, 2254, 3607, 1147, 5184, 9173, 8680, 8610, 1597, 1763, 7914, 3441, 7006, 1318, 7044, 7267, 8206, 9684, 4814, 9748, 4497, 2239];697439;132
"
"Course Schedule I I"	"Time : O() ; Space: O()
 
Description:
There are a total of n courses you have to take, labeled from 0 to n - 1. 
Some courses may have prerequisites, for example to take course 0 you have 
to first take course 1, which is expressed as a pair: [0,1] 
Given the total number of courses and a list of prerequisite pairs, return 
the ordering of courses you should take to finish all courses. 
There may be multiple correct orders, you just need to return one of them. 
If it is impossible to finish all courses, return an empty array.
 
For example: 2, [[1,0]] 
There are a total of 2 courses to take. To take course 1 you should have 
finished course 0. So the correct course order is [0,1] 
4, [[1,0],[2,0],[3,1],[3,2]] 
There are a total of 4 courses to take. To take course 3 you should have 
finished both courses 1 and 2. Both courses 1 and 2 should be taken after 
you finished course 0. So one correct course order is [0,1,2,3]. 
Another correct ordering is[0,2,1,3]. 
Note: The input prerequisites is a graph represented by a list of edges, 
not adjacency matrices. Read more about how a graph is represented.
 
{@link https://leetcode.com/problems/course-schedule-ii/ }"	"findOrder"	"### Java
```java
public class Solution {
    
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // for each course in the map nextVertex, the corresponding set contains prerequisite courses for this course 
        Map<Integer, Set<Integer>> nextVertex = new HashMap<>();
        // preVertex[i] indicates the number of courses that depend on course i
        int[] preVertex = new int[numCourses];

        // set up nextVertex and preVertex
        for (int i = 0; i < prerequisites.length; i++) {
            if (!nextVertex.containsKey(prerequisites[i][0])) {
                nextVertex.put(prerequisites[i][0], new HashSet<>());
            }

            if (nextVertex.get(prerequisites[i][0]).add(prerequisites[i][1])) {
                preVertex[prerequisites[i][1]]++;
            }
        }

        // queue for BFS, which will only hold courses currently upon which no other courses depend
        Deque<Integer> queue = new LinkedList<>();

        for (int i = 0; i < preVertex.length; i++) {
            // start from courses upon which no other courses depend. These courses should come last in the order list
            if (preVertex[i] == 0) {
                queue.offerLast(i);
            }
        }

        // array for the result, which will be filled up from the end by index
        int[] res = new int[numCourses];
        int index = res.length - 1;

        while (!queue.isEmpty()) {
            int key = queue.pollFirst(); // this is a course that no other courses will depend upon
            res[index--] = key;          // so we put it at the end of the order list

            // since we are done with course ""key"", for any other course that course ""key"" is dependent on, we can decrease
            // the corrresponding preVertex by one and check if it is qualified to be added to the queue.
            if (nextVertex.containsKey(key)) {
                for (int i : nextVertex.get(key)) {
                    if (--preVertex[i] == 0) {
                        queue.offerLast(i);
                    }
                }
            }

            --numCourses; // we are done with course ""key"", so reduce the remaining number of courses by 1
        }

        // if the remaining number of courses is not zero, then we cannot complete all the courses; otherwise return the result
        return numCourses == 0 ? res : new int[0];
    }
}
```"	"int[numCourses];array(array(int))[prerequisites];array(int)
2;[ [ 1, 0 ] ];[0,1]
2;[ [ 1, 0 ] ];[0,1]
4;[ [ 1, 0 ], [ 2, 0 ], [ 3, 1 ], [3, 2]];[0, 1, 2, 3]
3;[ [ 1, 0 ], [ 2, 1 ], [ 0, 2 ]];[]
"
"House Robber I I"	"Time : O(); Space : O()
 
Description: 
After robbing those houses on that street, the thief has found himself 
a new place for his thievery so that he will not get too much attention. 
This time, all houses at this place are arranged in a circle. That means 
the first house is the neighbor of the last one.  Each house has a certain 
amount of money stashed, the only constraint stopping you from robbing 
each of them is that adjacent houses have security system connected and 
it will automatically contact the police if two adjacent houses were 
broken into on the same night.
Given a list of non-negative integers representing the amount of money
of each house, determine the maximum amount of money you can rob 
tonight without alerting the police.
 
{@link https://leetcode.com/problems/house-robber-ii/  }"	"rob"	"### Java
```java
/** how to break circle down to original house robber problem */
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return nums[0];
        } else if (len == 2) {
            return Math.max(nums[0], nums[1]);
        } else {
            return Math.max(rob(nums, 0, len - 2), rob(nums, 1, len - 1));
        }
    }

    // when you might be able to steal both start and end
    private int rob(int[] nums, int start, int end) {
        if (start > end) {
            return 0;
        } else if (start == end) {
            return nums[start];
        } else {
            int[] dp = new int[end - start + 2];
            dp[dp.length - 1] = 0;
            for (int i = end - start; i >= 0; i--) {
                if (i == end - start) {
                    dp[i] = nums[end];
                } else {
                    dp[i] = Math.max(dp[i + 1], nums[start + i] + dp[i + 2]);
                }
            }
            return dp[0];
        }
    }
}
```"	"array(int)[nums];int
[1];1
[1, 2, 3];3
[1, 3, 4, 3];6
[1, 2, 3, 4, 5, 6, 7, 8];20
[1, 2, 3, 4, 5, 6, 7];15
"
"Kth Largest Element In An Array"	"Time : O(N) ~ O(N^2); Space : O(1)
 
Description: 
Find the kth largest element in an unsorted array. Note that it is the 
kth largest element in the sorted order, not the kth distinct element. 
For example, Given [3,2,1,5,6,4] and k = 2, return 5. 
Note: You may assume k is always valid, 1 ≤ k ≤ array's length.
 
{@link https://leetcode.com/problems/kth-largest-element-in-an-array/  }"	"findKthLargest"	"### Java
```java
public class Solution {
    
    // partition until we find k
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        while (left <= right) {
            int index = randomPartition(nums, left, right);
            if (index == len - k) {
                return nums[index];
            } else if (index < len - k) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
        return -1;
    }

    private int randomPartition(int[] nums, int left, int right) {
        // choose a random index as pivot's position
        int index = left + new Random().nextInt(right - left + 1);
        swap(nums, index, right);
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (nums[j] < nums[right]) {
                swap(nums, ++i, j);
            }
        }
        swap(nums, ++i, right);
        return i;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```"	"array(int)[nums];int[k];int
[60, 94, 63, 3, 86, 40, 93, 36, 56, 48, 17, 10, 23, 43, 77, 1, 1, 93, 79, 4, 10, 47, 1, 99, 91, 53, 99, 18, 52, 61, 84, 10, 13, 52, 3, 9, 78, 16, 7, 6];18;52
[2, 1, 4, 3, 2];3;2
[2, 1];1;2
"
"Combination Sum I I I"	"Time : O() ; Space: O()
 
Description:
Find all possible combinations of k numbers that add up to a number n, given 
that only numbers from 1 to 9 can be used and each combination should be a 
unique set of numbers. 
Ensure that numbers within the set are sorted in ascending order.
Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] 
Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]
 
{@link https://leetcode.com/problems/combination-sum-iii/ }"	"combinationSum3"	"### Java
```java
public class Solution {

    private int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> sub = new ArrayList<>();
        int index = 0;
        int cur = 0;
        combine(k, index, n, cur, sub, res);
        return res;
    }

    private void combine(final int k, int index, int target, int cursum,
            List<Integer> sub, List<List<Integer>> res) {
        // base case
        if (sub.size() == k && cursum == target) {
            res.add(sub);
            return;
        }
        // recursive case
        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            // pruning siblings
            if (cursum + num > target || sub.size() >= k) {
                break;
            }
            List<Integer> copy = new ArrayList<>(sub);
            copy.add(num);
            combine(k, i + 1, target, cursum + num, copy, res);
        }
    }
}
```"	"int[k];int[n];list(list(int))
3;7;[[1, 2, 4]]
3;9;[[1, 2, 6], [1, 3, 5], [2, 3, 4]]
"
"Contains Duplicate I I I"	"Time : O(NlgK); Space : O()
 
Description: 
Given an array of integers, find out whether there are two distinct 
indices i and j in the array such that the difference between nums[i] 
and nums[j] is at most t and the difference between i and j is at most k.
 
{@link https://leetcode.com/problems/contains-duplicate-iii/ }"	"containsNearbyAlmostDuplicate"	"### Java
```java
public class Solution {

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        TreeSet<Long> values = new TreeSet<>();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            // remove values that are out of current window
            int num = nums[i];
            // in case of integer overflow
            Long floor = values.floor((long) num);
            Long ceiling = values.ceiling((long) num);
            if ((floor != null && num - floor <= t) || (ceiling != null && ceiling - num <= t)) {
                return true;
            }
            values.add((long) num);
            if (i >= k) {
                values.remove((long)nums[i - k]);
            }
        }
        return false;

    }
}
```"	"array(int)[nums];int[k];int[t];bool
[-1, -1];1;0;true
[-1, 2147483647];1;2147483647;false
"
"Maximal Square"	"Time : O(mn) ; Space: O(mn)
 
Description:
Given a 2D binary matrix filled with 0's and 1's, find the largest square 
containing all 1's and return its area. 
For example, given the following matrix: 
 1 0 1 0 0 
 1 0 1 1 1 
 1 1 1 1 1 
 1 0 0 1 0 
 
Return 4.
 
{@link https://leetcode.com/problems/maximal-square/ }"	"maximalSquare"	"### Java
```java
public class Solution {

    public int maximalSquare(String[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int res = 0;
        int rows = matrix.length;
        int cols = matrix[0].length;
        // f[i][j] = min(number of continuous 1s along x-direction from (i,k),
        // number of continuous 1s along y-direction)
        int[][] f = new int[rows + 1][cols + 1];
        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 0; j--) {
                if (matrix[i][j].equals(""1"")) {
                    f[i][j] = 1 + Math.min(f[i + 1][j + 1], Math.min(f[i][j + 1], f[i + 1][j]));
                    res = Math.max(res, f[i][j]);
                }
            }
        }
        return res * res;
    }

    public int maximalSquare2(String[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int res = 0;
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] x = new int[rows + 1][cols + 1]; // how many continuous 1s along
                                                 // row i from column j
        int[][] y = new int[rows + 1][cols + 1]; // how many continuous 1s from
                                                 // (i,j) along direction to
                                                 // bottom
        int[][] f = new int[rows + 1][cols + 1];
        for (int i = rows; i >= 0; i--) {
            for (int j = cols; j >= 0; j--) {
                int area = 0;
                if (i == rows && j == cols) {
                    area = 0;
                } else if (i == rows) {
                    area = 0;
                } else if (j == cols) {
                    area = 0;
                } else {
                    if (matrix[i][j].equals(""1"")) {
                        int len = (int) Math.min(Math.sqrt(f[i + 1][j + 1]),
                                Math.min(x[i][j + 1], y[i + 1][j]));
                        area = (len + 1) * (len + 1);
                        x[i][j] = 1 + x[i][j + 1];
                        y[i][j] = 1 + y[i + 1][j];
                    }
                }
                res = Math.max(res, area);
                f[i][j] = area;
            }
        }
        return res;
    }
}
```"	"array(array(string))[matrix];int
[[ ""1"" ]];1
[[ ""0"" ]];0
[[ ""1"", ""1"" ], [ ""1"", ""1"" ]];4
[[ ""1"", ""0"", ""1"", ""0"", ""0""], [ ""1"", ""0"", ""1"", ""1"", ""1""], [ ""1"", ""1"", ""1"", ""1"", ""1""], [ ""1"", ""0"", ""0"", ""1"", ""0""]];4
[[ ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""1"" ], [ ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""0"" ], [ ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""1"", ""0"" ], [ ""1"", ""1"", ""1"", ""1"", ""1"", ""0"", ""0"", ""0"" ], [ ""0"", ""1"", ""1"", ""1"", ""0"", ""0"", ""0"", ""0"" ]];16
"
"Basic Calculator"	"Time : O(); Space : O()
 
Description: 
Implement a basic calculator to evaluate a simple expression string. 
The expression string may contain open ( and closing parentheses ), 
the plus + or minus sign -, non-negative integers and empty spaces . 
You may assume that the given expression is always valid. 
Some examples: 
 ""1 + 1"" = 2 
 "" 2-1 + 2 "" = 3 
 ""(1+(4+5+2)-3)+(6+8)"" = 23 
 
Note: Do not use the eval built-in library function.
 
{@link https://leetcode.com/problems/basic-calculator/ }"	"calculate"	"### Java
```java
public class Solution {

    // define functional type
    public interface Operation {
        public int eval(int op1, int op2);
    }

    private Map<String, Operation> OperatorMap = new HashMap<>();

    private Set<Character> splitors = new HashSet<>();

    public int calculate(String s) {
        if (s.length() == 0) {
            return 0;
        }
        learnOperators();
        List<String> strs = parseStr(s);
        Stack<String> ops = new Stack<>();
        for (String token : strs) {
            if (token.equals("")"")) {
                // calculate result from the inner most bracket
                int op = eval(ops);
                ops.push("""" + op);
            } else {
                ops.push(token);
            }
        }
        int result = eval(ops);
        return result;
    }

    private void learnOperators() {
        OperatorMap.put(""+"", new Operation() {
            @Override
            public int eval(int op1, int op2) {
                return op1 + op2;
            }
        });

        OperatorMap.put(""-"", new Operation() {
            @Override
            public int eval(int op1, int op2) {
                return op1 - op2;
            }
        });

        splitors.add(' ');
        splitors.add('+');
        splitors.add('-');
        splitors.add('(');
        splitors.add(')');
    }

    private List<String> parseStr(String s) {
        List<String> strings = new ArrayList<>();
        String numStr = """";
        for (char ch : s.toCharArray()) {
            if (splitors.contains(ch)) {
                // if accumulating number, then stop
                if (!numStr.isEmpty()) {
                    strings.add(numStr);
                    numStr = """";
                }
                if (ch != ' ') {
                    strings.add("""" + ch);
                }
            } else {
                numStr += ch;
            }
        }
        // don't forget the last one
        if (!numStr.isEmpty()) {
            strings.add(numStr);
        }
        return strings;
    }

    private int eval(Stack<String> ops) {
        // calculate until we met ""("" or stack is empty
        Stack<String> stack = new Stack<>();
        while (!ops.isEmpty()) {
            String op = ops.pop();
            if (op.equals(""("")) {
                break;
            }
            stack.push(op);
        }
        while (!stack.isEmpty()) {
            if (stack.size() == 1) {
                return Integer.parseInt(stack.pop());
            } else {
                int op1 = Integer.parseInt(stack.pop());
                String op = stack.pop();
                int op2 = Integer.parseInt(stack.pop());
                stack.push("""" + OperatorMap.get(op).eval(op1, op2));
            }
        }
        return 0;
    }
}
```"	"string[s];int
""1 + 1 "";2
"" 2-1 + 2 "";3
""(1+(4+5+2)-3)+(6+8)"";23
"" 1 - ( 2 + 3)"";-4
"" 1 - ( 2 + 3) + 4"";0
"
"Majority Element I I"	"Time : O(); Space : O()
 
Description: 
Given an integer array of size n, find all elements that appear more 
than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.
 
{@link https://leetcode.com/problems/majority-element-ii/ }"	"majorityElement"	"### Java
```java
public class Solution {

    public List<Integer> majorityElement(int[] nums) {
        int cand1 = 0;
        int cand2 = 1;
        int count1 = 0;
        int count2 = 0;
        for (int num : nums) {
            if (num == cand1) {
                count1++;
            } else if (num == cand2) {
                count2++;
            } else if (count1 == 0) {
                cand1 = num;
                count1 = 1;
            } else if (count2 == 0) {
                cand2 = num;
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }
        
        // find answers
        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (num == cand1) {
                count1++;
            } else if(num == cand2) {
                count2++;
            }
        }
        List<Integer> result = new ArrayList<>();
        if (count1 > nums.length / 3) {
            result.add(cand1);
        }
        if (count2 > nums.length / 3) {
            result.add(cand2);
        }
        return result;
    }
}
```"	"array(int)[nums];list(int)
[ 1, 2, 3, 1, 1 ];[1]
[];[]
[ 3 ];[3]
[ 1, 1, 1, 2, 3, 5, 7 ];[1]
[ 1000545, 1000038, 1000647, 1000038, 1000562, 1000038, 1000586, 1000487, 1000951, 1000226, 1000038, 1000145, 1000038, 1000761, 1000196, 1000038, 1000821, 1000829, 1000038, 1000570, 1000846, 1000038, 1000178, 1001000, 1000038, 1000568, 1000278, 1000734, 1000048, 1000038, 1000002, 1000271, 1000388, 1000315, 1000816, 1000038, 1000038, 1000846, 1000305, 1000853, 1000383, 1000116, 1000797, 1000279, 1000038, 1000038, 1000049, 1000108, 1000789, 1000240, 1000201, 1000506, 1000429, 1000857, 1000649, 1000898, 1000211, 1000000, 1000178, 1000038, 1000569, 1000695, 1000451, 1000159, 1000038, 1000038, 1000038, 1000129, 1000038, 1000038, 1000904, 1000038, 1000038, 1000902, 1000525, 1000038, 1000166, 1000038, 1000765, 1000038, 1000561, 1000417, 1000523, 1000668, 1000296, 1000038, 1000038, 1000038, 1000461, 1000654, 1000924, 1000985, 1000038, 1000426, 1000038, 1000038, 1000038, 1000904, 1000775, 1000148, 1000961, 1000038, 1000038, 1000038, 1000833, 1000332, 1000038, 1000038, 1000512, 1000322, 1000592, 1000524, 1000788, 1000057, 1000497, 1000625, 1000599, 1000484, 1000038, 1000747, 1000457, 1000111, 1000038, 1000038, 1000493, 1000287, 1000007, 1000695, 1000344, 1000098, 1000038, 1000191, 1000038, 1000576, 1000481, 1000488, 1000199, 1000038, 1000663, 1000176, 1000038, 1000521, 1000721, 1000728, 1000247, 1000038, 1000038, 1000460, 1000644, 1000038, 1000497, 1000966, 1000431, 1000038, 1000975, 1000063, 1000580, 1000669, 1000038, 1000038, 1000492, 1000038, 1000038, 1000529, 1000553, 1000333, 1000038, 1000341, 1000569, 1000862, 1000017, 1000532, 1000571, 1000508, 1000402, 1000285, 1000611, 1000210, 1000646, 1000110, 1000038, 1000553, 1000273, 1000729, 1000038, 1000038, 1000720, 1000400, 1000038, 1000983, 1000038, 1000766, 1000038, 1000180, 1000494, 1000765, 1000136, 1000038, 1000029, 1000246, 1000991, 1000038, 1000759, 1000038, 1000038, 1000045, 1000038, 1000648, 1000038, 1000038, 1000694, 1000914, 1000990, 1000038, 1000038, 1000758, 1000435, 1000038, 1000554, 1000038, 1000452, 1000156, 1000038, 1000322, 1000828, 1000868, 1000038, 1000973, 1000991, 1000464, 1000294, 1000633, 1000038, 1000582, 1000229, 1000285, 1000038, 1000038, 1000086, 1000038, 1000989, 1000038, 1000038, 1000157, 1000307, 1000369, 1000300, 1000038, 1000038, 1000038, 1000244, 1000038, 1000038, 1000222, 1000458, 1000038, 1000523, 1000434, 1000316, 1000038, 1000256, 1000038, 1000695, 1000038, 1000469 ];[]
[ 1, 1, 1, 2, 2, 2, 3, 3 ];[1,2]
"
"Kth Smallest Element In A B S T"	"Time : O(); Space : O()
 
Description: 
Given a binary search tree, write a function kthSmallest to find the 
kth smallest element in it. 
Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements. 
Follow up: 
What if the BST is modified (insert/delete operations) often and you 
need to find the kth smallest frequently? How would you optimize the 
kthSmallest routine?
 
{@link https://leetcode.com/problems/kth-smallest-element-in-a-bst/ }"	"kthSmallest"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public int kthSmallest(BinaryTreeNode<Integer> root, int k) {
        List<Integer> list = convertBSTToList(root, k);
        if (1 <= k && k <= list.size()) {
            return list.get(k - 1);
        } else {
            return 0;
        }
    }

    private List<Integer> convertBSTToList(BinaryTreeNode<Integer> root, int k) {
        List<Integer> list = new ArrayList<>();
        // base case
        if (root == null) {
            return list;
        }
        // recursive case: in-order traversal
        list.addAll(convertBSTToList(root.left, k));
        list.add(root.data);
        if (list.size() >= k) {
            // we don't need to check right subtree
            return list;
        } else {
            list.addAll(convertBSTToList(root.right, k));
        }
        return list;
    }
}
```"	"binary_tree(int)[root];int[k];int
[1, null];1;1
[1, null, 2, null, 3];1;1
[1, null, 2, null, 3];2;2
[1, null, 2, null, 3];3;3
[10, 5, 12, 4, 7];1;4
[10, 5, 12, 4, 7];5;12
[10, 5, 12, 4, 7];3;7
[5, 4, null, 3, null, 2, null, 1];1;1
[5, 4, null, 3, null, 2, null, 1];5;5
[5, 4, null, 3, null, 2, null, 1];3;3
"
"Lowest Common Ancestor Of A Binary Tree"	"Time : O(N) ; Space: O(1)
 
Description:
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes 
in the tree. 
According to the definition of LCA on Wikipedia: “The lowest common ancestor 
is defined between two nodes v and w as the lowest node in T that has 
both v and w as descendants (where we allow a node to be a descendant of itself).” 
     _______3______ 
    /              \
 ___5__          ___1__
/      \        /      \
6      _2       0       8
       /  \
      7    4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another 
example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of 
itself according to the LCA definition.
 
{@link https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ }"	"lowestCommonAncestor"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    public BinaryTreeNode<Integer> lowestCommonAncestor(BinaryTreeNode<Integer> root, BinaryTreeNode<Integer> p, BinaryTreeNode<Integer> q) {
        // base case
        if (root == null || root.data == p.data || root.data == q.data) {
            return root;
        }
        // recursive case: divide and conquer
        BinaryTreeNode<Integer> left = lowestCommonAncestor(root.left, p, q);
        BinaryTreeNode<Integer> right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else {
            return right;
        }
    }
}
```"	"binary_tree(int)[root];binary_tree(int)[p];binary_tree(int)[q];binary_tree(int)
[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5];[2, 0, 4, null, null, 3, 5];[4, 3, 5];[2, 0, 4, null, null, 3, 5]
[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5];[2, 0, 4, null, null, 3, 5];[8, 7, 9];[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]
[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5];[4, 3, 5];[9, null];[6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]
"
"Product Of Array Except Self"	"Time : O(N) ; Space: O(1)
 
Description:
 
Given an array of n integers where n > 1, nums, return an array output 
such that output[i] is equal to the product of all the elements of nums 
except nums[i]. 
Solve it without division and in O(n). 
For example, given [1,2,3,4], return [24,12,8,6]. 
Follow up: 
Could you solve it with constant space complexity? (Note: The output array
does not count as extra space for the purpose of space complexity analysis.)
 
{@link https://leetcode.com/problems/product-of-array-except-self/ }"	"productExceptSelf"	"### Java
```java
public class Solution {

    // res[i] = A[i - 1] * B[i + 1]
    // where A[i - 1] = nums[0] * nums[1] * .. * nums[i - 1]
    //       B[i + 1] = nums[i + 1] * nums[i + 2] * .. nums[len - 1]
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        int left = 1;
        for (int i = 0; i < n; i++) {
            res[i] = left; 
            left *= nums[i];
        }
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] *= right;
            right *= nums[i];
        }
        return res;
    }
}
```"	"array(int)[nums];array(int)
[ 1, 2, 3, 4 ];[ 24, 12, 8, 6 ]
[ 1, 2 ];[ 2, 1 ]
[ 6 ];[ 1 ]
"
"Search A2 D Matrix I I"	"Time : O(m + n) ; Space: O(1)
 
Description:
 
Write an efficient algorithm that searches for a value in an m x n matrix. 
This matrix has the following properties: 
Integers in each row are sorted in ascending from left to right. 
Integers in each column are sorted in ascending from top to bottom. 
For example, Consider the following matrix: 
[ [1,   4,  7, 11, 15], 
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30] ]
Given target = 5, return true. 
Given target = 20, return false.
 
{@link https://leetcode.com/problems/search-a-2d-matrix-ii/ }"	"searchMatrix"	"### Java
```java
public class Solution {

    // start from top right corner
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int rows = matrix.length;
        int cols = matrix[0].length;
        int i = 0;
        int j = cols - 1;
        while (i < rows && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
```"	"array(array(int))[matrix];int[target];bool
[ [  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];3;true
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];100;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];15;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];30;true
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];0;false
[[  1,  3,  5,  7 ], [ 10, 11, 16, 20 ], [ 23, 30, 34, 50 ] ];10;true
[ [  1,  3,  5,  7 ] ];10;false
[ [  1,  3,  5,  7 ] ];7;true
[ [  1,  3,  5,  7 ] ];1;true
[ [  1,  3,  5,  7 ] ];4;false
[ [  1,  3,  5,  7 ] ];5;true
[[ 1 ], [ 5 ], [ 9 ] ];1;true
[[ 1 ], [ 5 ], [ 9 ] ];18;false
[[ 1 ], [ 5 ], [ 9 ] ];0;false
[[ 1 ], [ 5 ], [ 9 ] ];3;false
[[ 1 ], [ 5 ], [ 9 ] ];7;false
"
"Flatten2 D Vector"	"Time : O() ; Space: O()
 
Description:
Implement an iterator to flatten a 2d vector. 
For example, 
Given 2d vector = 
[ [1,2],
  [3], 
  [4,5,6] 
] 
By calling next repeatedly until hasNext returns false, the order of 
elements returned by next should be: [1,2,3,4,5,6].
 
 
{@link https://leetcode.com/problems/flatten-2d-vector/ }"	"isStrobogrammatic"	"### Java
```java
public class Solution {

    private static final Map<Character, Character> map = new HashMap<Character, Character>() {
        {
            put('6', '9');
            put('9', '6');
            put('0', '0');
            put('1', '1');
            put('8', '8');
        }
    };

    public boolean isStrobogrammatic(String num) {
        for (int i = 0, j = num.length() - 1; i <= j ; i++, j--) {
            char ch = num.charAt(i);
            if (!map.containsKey(ch) || map.get(ch) != num.charAt(j)) {
                return false;
            }
        }
        return true;
    }
    
}
```"	"string[num];bool
69;true
88;true
818;true
66;false
8998;false
2;false
"
"Meeting Rooms I I"	"Time : O() ; Space: O()
 
Description:
Given an array of meeting time intervals consisting of start and end 
times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference 
rooms required. 
For example, 
Given [[0, 30],[5, 10],[15, 20]], return 2.
 
{@link https://leetcode.com/problems/meeting-rooms-ii/ }"	"minMeetingRooms"	"### Java
```java
class Interval {
    int start;
    int end;
}

public class Solution {
    
    private static final int START = 1;

    private static final int END = 0;
    
    private class Event {
        int time;
        int type; // end event is 0; start event is 1

        public Event(int time, int type) {
            this.time = time;
            this.type = type;
        }
    }
    
    public int minMeetingRooms(Interval[] intervals) {
        int rooms = 0; // occupied meeting rooms
        int res = 0;

        // initialize an event queue based on event's happening time
        Queue<Event> events = new PriorityQueue<>(new Comparator<Event>() {
            @Override
            public int compare(Event e1, Event e2) {
                // for same time, let END event happens first to save rooms
                return e1.time != e2.time ? e1.time - e2.time : e1.type - e2.type;
            }
        });

        // create event and push into event queue
        for (Interval interval : intervals) {
            events.offer(new Event(interval.start, START));
            events.offer(new Event(interval.end, END));
        }
        
        // process events
        while (!events.isEmpty()) {
            Event event = events.poll();
            if (event.type == START) {
                rooms++;
                res = Math.max(res, rooms);
            } else {
                rooms--; 
            }
        }
        
        return res;
    }
}
```"	"array(object(int[start],int[end])<Interval>)[intervals];int
[[0, 30], [ 5, 10], [15, 20]];2
[[ 0, 3], [ 5, 10], [15, 20]];1
[[ 0, 30], [ 5, 10], [ 6, 20]];3
[[ 2, 11], [ 6, 16], [11, 16]];2
"
"Paint House"	"Time : O() ; Space: O()
 
Description:
There are a row of n houses, each house can be painted with one of the 
three colors: red, blue or green. The cost of painting each house with 
a certain color is different. You have to paint all the houses such that 
no two adjacent houses have the same color. 
The cost of painting each house with a certain color is represented by a 
n x 3 cost matrix. For example, costs[0][0] is the cost of painting 
house 0 with color red; costs[1][2] is the cost of painting house 1 with 
color green, and so on... Find the minimum cost to paint all houses.
Note: All costs are positive integers.
 
{@link https://leetcode.com/problems/paint-house/ }"	"minCost"	"### Java
```java
public class Solution {

    public int minCost(int[][] costs) {
        int n = costs.length;
        if (n == 0) {
            return 0;
        }
        // f[i][c] = min cost for paint[i : end] if we paint house i with color c
        int f[][] = new int[n + 1][costs[0].length];
        for (int i = n - 1; i >= 0; i--) {
            for (int c = 2; c >= 0; c--) {
                int mincost = Integer.MAX_VALUE;
                for (int color = 0; color <= 2; color++) {
                    if (color != c) {
                        mincost = Math.min(mincost, f[i + 1][color]);
                    }
                }
                f[i][c] = mincost + costs[i][c];
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < f[0].length; i++) {
            res = Math.min(res, f[0][i]);
        }
        return res;
    }
}
```"	"array(array(int))[costs];int
[[ 10, 30, 20 ]];10
[[ 1, 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ]];3
[[ 1, 2, 3 ], [ 3, 2, 1 ], [ 2, 2, 2 ], [ 3, 1, 2 ]];5
[[17,  2, 17 ], [16, 16,  5 ], [14,  3, 19 ]];10
[[ 12,  1, 19 ], [ 15,  1, 10 ], [  3, 11, 10 ], [  9,  3, 10 ], [  4,  8,  7 ], [  4, 18,  2 ], [ 16,  6,  6 ], [  3,  3,  6 ], [ 10, 18, 16 ], [  5,  4,  8 ], [  5,  3, 16 ], [ 11,  8, 19 ], [ 18, 15, 18 ], [ 16,  4, 15 ], [ 10,  7, 13 ], [ 11, 10, 14 ], [  3,  9,  8 ], [  5,  2,  2 ], [  3,  2,  5 ], [  2, 19, 14 ], [ 17,  3,  6 ], [  6,  4, 17 ], [  5, 15, 19 ], [  2, 14, 14 ], [ 19,  4, 16 ]];143
"
"Graph Valid Tree"	"Time : O() ; Space: O()
 
Description:
Given n nodes labeled from 0 to n - 1 and a list of undirected edges 
(each edge is a pair of nodes), write a function to check whether these 
edges make up a valid tree. 
For example: 
Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true. 
Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
Note: you can assume that no duplicate edges will appear in edges. 
Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will 
not appear together in edges.
 
{@link https://leetcode.com/problems/graph-valid-tree/ }"	"validTree"	"### Java
```java
public class Solution {

    private int[] id;

    public boolean validTree(int n, int[][] edges) {
        id = new int[n];
        Arrays.fill(id, -1);

        // union-find
        for (int[] edge : edges) {
            int parent = edge[0];
            int child = edge[1];
            if (isConnected(parent, child)) {
                return false;
            }
            // union
            id[child] = parent;
        }

        // because no duplicated edges exist
        return edges.length == n - 1;
    }

    private boolean isConnected(int parent, int child) {
        return root(parent) == root(child);
    }

    private int root(int node) {
        if (id[node] == -1) {
            return node;
        }
        return root(id[node]);
    }
}
```"	"int[n];array(array(int))[edges];bool
5;[[ 0, 1 ], [ 0, 2 ], [ 0, 3 ], [ 1, 4 ]];true
5;[[ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 1, 3 ], [ 1, 4 ]];false
4;[[ 0, 1 ], [ 2, 3 ]];false
3;[[ 1, 0 ], [ 2, 0 ]];true
5;[[ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 3, 4 ]];false
3;[[ 2, 0 ], [ 2, 1 ]];true
"
"Missing Number"	"Time : O(N) ; Space: O(1)
 
Description:
 
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, 
find the one that is missing from the array. 
For example, Given nums = [0, 1, 3] return 2.
 
{@link https://leetcode.com/problems/missing-number/ }"	"missingNumber"	"### Java
```java
public class Solution {
    
    // non-missing numbers will have two numbers for xor
    public int missingNumber(int[] nums) {
        int xor = 0;
        int n = nums.length;
        for (int i = 0; i < nums.length; i++) {
            xor = xor ^ nums[i];
            xor = xor ^ n--;
        }
        return xor;
    }
}
```"	"array(int)[nums];int
[ 0, 1, 3 ];2
[ 2, 3, 1 ];0
[ 0, 2, 3, 1 ];4
[ 2, 0 ];1
"
"Integer To English Words"	"Time : O() ; Space: O()
 
Description:
Convert a non-negative integer to its english words representation. 
Given input is guaranteed to be less than 231 - 1. 
For example, 
123 -> ""One Hundred Twenty Three"" 
12345 -> ""Twelve Thousand Three Hundred Forty Five"" 
 
{@link https://leetcode.com/problems/integer-to-english-words/ }"	"numberToWords"	"### Java
```java
public class Solution {
    
    private static final String[] DELIM = { """", "" Thousand"", "" Million"", "" Billion"" };
    
    private static final Map<Integer, String> WORDS = new HashMap<Integer, String>() {{
        put(1, ""One"");
        put(2, ""Two"");
        put(3, ""Three"");
        put(4, ""Four"");
        put(5, ""Five"");
        put(6, ""Six"");
        put(7, ""Seven"");
        put(8, ""Eight"");
        put(9, ""Nine"");
        put(10, ""Ten"");
        put(11, ""Eleven"");
        put(12, ""Twelve"");
        put(13, ""Thirteen"");
        put(14, ""Fourteen"");
        put(15, ""Fifteen"");
        put(16, ""Sixteen"");
        put(17, ""Seventeen"");
        put(18, ""Eighteen"");
        put(19, ""Nineteen"");
        put(20, ""Twenty"");
        put(30, ""Thirty"");
        put(40, ""Forty"");
        put(50, ""Fifty"");
        put(60, ""Sixty"");
        put(70, ""Seventy"");
        put(80, ""Eighty"");
        put(90, ""Ninety"");
        put(100, ""Hundred"");
    }};
    
    public String numberToWords(int num) {
        if (num == 0) {
            return ""Zero"";
        }
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (num != 0) {
            int partial = num % 1000;
            StringBuilder psb = convert(partial);
            if (psb.length() == 0) {
                i++;
            } else if (sb.length() == 0) {
                sb = psb.append(DELIM[i++]);
            } else {
                sb = psb.append(DELIM[i++]).append("" "").append(sb);
            }
            num = num / 1000;
        }
        return sb.toString();
    }
    
    // convert a number less than 1000
    private StringBuilder convert(int num) {
        if (num == 0) {
            return new StringBuilder();
        } else if (num < 20) {
            return new StringBuilder(WORDS.get(num));
        } else if (num % 100 == 0) {
            return new StringBuilder(WORDS.get(num / 100) + "" Hundred"");
        } else if (num > 100) {
            return new StringBuilder(WORDS.get(num / 100)  + "" Hundred "").append(convert(num % 100));
        } else if (num % 10 == 0) {
            return new StringBuilder(WORDS.get(num));
        } else if (num > 10) {
            return new StringBuilder(WORDS.get(num / 10 * 10) + "" "" + WORDS.get(num % 10));
        } else {
            return new StringBuilder(); 
        }
    }
}
```"	"int[num];string
0;""Zero""
123;""One Hundred Twenty Three""
12345;""Twelve Thousand Three Hundred Forty Five""
1234567;""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven""
200;""Two Hundred""
1234567891;""One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One""
19;""Nineteen""
20;""Twenty""
110;""One Hundred Ten""
1000;""One Thousand""
100;""One Hundred""
1001;""One Thousand One""
1000000;""One Million""
"
"H Index"	"Time : O(N) ; Space: O(N)
 
Description:
Given an array of citations (each citation is a non-negative integer) of 
a researcher, write a function to compute the researcher's h-index. 
According to the definition of h-index on Wikipedia: ""A scientist has 
index h if h of his/her N papers have at least h citations each, and the 
other N − h papers have no more than h citations each."" 
For example, given citations = [3, 0, 6, 1, 5], which means the researcher 
has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations 
respectively. Since the researcher has 3 papers with at least 3 citations 
each and the remaining two with no more than 3 citations each, his h-index is 3. 
Note: If there are several possible values for h, the maximum one is taken as the h-index. 
 
{@link https://leetcode.com/problems/h-index/ }"	"hIndex"	"### Java
```java
public class Solution {
    
    public int hIndex(int[] nums) {
        int n = nums.length;
        int[] counts = new int[n + 1];
        // count for each citations
        for (int num : nums) {
            if (num >= n) {
                counts[n]++;
            } else {
                counts[num]++;
            }
        }
        int sum = 0;
        for (int i = n; i >= 0; i--) {
            if (counts[i] + sum >= i) {
                return i;
            } else {
                sum += counts[i];
            }
        }
        return 0;
    }
}
```"	"array(int)[nums];int
[ 0 ];0
[ 3, 1, 0, 6, 5 ];3
"
"H Index I I"	"Time : O(lgN) ; Space: O(1)
 
Description:
Follow up for H-Index: What if the citations array is sorted in ascending 
order? Could you optimize your algorithm? 
Hint: Expected runtime complexity is in O(log n) and the input is sorted.
 
{@link https://leetcode.com/problems/h-index-ii/ }"	"hIndex"	"### Java
```java
public class Solution {
    
    // find first i where nums[i] >= n - i
    public int hIndex(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int left = 0;
        int right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int target = n - mid;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return n - right - 1;
    }
}
```"	"array(int)[nums];int
[ ];0
[ 0 ];0
[ 5, 5, 5, 5, 7 ];5
[ 0, 5, 5, 6, 8 ];4
[ 0, 0, 0, 0, 0 ];0
[ 1, 2, 3, 4, 5 ];3
[ 2, 5 ];2
[ 1, 8 ];1
[ 0, 1 ];1
[ 0, 0 ];0
[ 11, 15 ];2
[ 100 ];1
[ 1 ];1
[ 0 ];0
[ 1, 1, 2, 3, 4, 5, 7 ];3
[ 0, 0, 1 ];1
"
"Paint Fence"	"Time : O() ; Space: O()
 
Description:
There is a fence with n posts, each post can be painted with one of the 
k colors. 
You have to paint all the posts such that no more than two adjacent 
fence posts have the same color. 
Return the total number of ways you can paint the fence. 
Note: n and k are non-negative integers.
 
{@link https://leetcode.com/problems/paint-fence/ }"	"numWays"	"### Java
```java
public class Solution {

    public int numWays(int n, int k) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return k;
        }
        int diffColorCounts = k * (k - 1);
        int sameColorCounts = k;
        for (int i = 2; i < n; i++) {
            int temp = diffColorCounts;
            diffColorCounts = (diffColorCounts + sameColorCounts) * (k - 1);
            sameColorCounts = temp;
        }
        return diffColorCounts + sameColorCounts;
    }
}
```"	"int[n];int[k];int
1;1;1
1;5;5
2;3;9
3;4;60
2;1;1
"
"Peeking Iterator"	"Time : O() ; Space: O()
 
Description:
Given an Iterator class interface with methods: next() and hasNext(), 
design and implement a PeekingIterator that support the peek() operation 
-- it essentially peek() at the element that will be returned by the next 
call to next().
 
{@link https://leetcode.com/problems/peeking-iterator/ }"	"moveZeroes"	"### Java
```java
public class Solution {

    public int[] moveZeroes(int[] nums) {
        int count = 0;  // count of nonzero numbers
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[count++] = nums[i];
            }
        }
        while (count < nums.length) {
            nums[count++] = 0;
        }
        return nums;
    }
}
```"	"array(int)[nums];array(int)
[ 0, 1, 0, 3, 12 ];[ 1, 3, 12, 0, 0 ]
[ 4, 3, 2, 0, 0, 0 ];[ 4, 3, 2, 0, 0, 0 ]
[ 0, 0, 0, 4, 2, 1 ];[ 4, 2, 1, 0, 0, 0 ]
[ 3, 1, 2 ];[ 3, 1, 2 ]
[ 0, 0 ];[ 0, 0 ]
[ 0];[ 0]
[ 1];[ 1]
"
"Inorder Successor In B S T"	"Time : O() ; Space: O()
 
Description:
Given a binary search tree and a node in it, find the in-order successor
of that node in the BST. 
Note: If the given node has no in-order successor in the tree, return null.
 
{@link https://leetcode.com/problems/inorder-successor-in-bst/ }"	"inorderSuccessor"	"### Java
```java
class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode() { }

    public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    // iterative version
    public BinaryTreeNode<Integer> inorderSuccessor(BinaryTreeNode<Integer> root, BinaryTreeNode<Integer> node) {
        if (root == null || node == null) {
            return null;
        } else if (node.right != null) {
            // find successor in right subtree, the leftmost child
            node = node.right;
            while (node.left != null) {
                node = node.left;
            }
            return node;
        } else {
            // find successor from root down to this node
            BinaryTreeNode<Integer> successor = null;
            while (root != null && root != node) {
                if (node.data < root.data) {
                    // go to left subtree
                    successor = root;
                    root = root.left;
                } else {
                    root = root.right;
                }
            }
            return successor;
        }
    }
}
```"	"binary_tree(int)[root];binary_tree(int)[node];binary_tree(int)
[1, null];[1, null];[null]
null;null;[null]
[1, null, 2, null, 3];null;[null]
[1, null, 2, null, 3];[1, null, 2, null, 3];[2, null, 3]
[3, 2, null, 1];[2, 1];[3, 2, null, 1]
[10, 5, 12, 4, 7];[7, null];[10, 5, 12, 4, 7]
[8, 6, 18, 3, 7, 10, 20, null, 5, null, null, null, null, null, null, 4];[10, null];[18, 10, 20]
[8, 6, 18, 3, 7, 10, 20, null, 5, null, null, null, null, null, null, 4];[4, null];[5, 4]
"
"Walls And Gates"	"Time : O(mn) ; Space: O(mn)
 
Description:
You are given a m x n 2D grid initialized with these three possible values. 
1. -1 - A wall or an obstacle. 
2. 0 - A gate. 
3. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 
to represent INF as you may assume that the distance to a gate is less than 2147483647.
Fill each empty room with the distance to its nearest gate. If it is 
impossible to reach a gate, it should be filled with INF. 
For example, given the 2D grid: 
INF  -1  0  INF 
INF INF INF  -1 
INF  -1 INF  -1 
0  -1 INF INF 
After running your function, the 2D grid should be: 
3  -1   0   1 
2   2   1  -1 
1  -1   2  -1 
0  -1   3   4
 
{@link https://leetcode.com/problems/walls-and-gates/ }"	"wallsAndGates"	"### Java
```java
public class Solution {

    private static final int[] X = { -1, 1, 0, 0 };
    private static final int[] Y = { 0, 0, -1, 1 };
    private static final int INF = Integer.MAX_VALUE;

    /** First find all `0`s, and then fill empty cells with distance */
    public int[][] wallsAndGates(int[][] rooms) {
        if (rooms.length == 0 || rooms[0].length == 0) {
            return rooms;
        }
        int rows = rooms.length;
        int cols = rooms[0].length;
        Queue<Integer> queue = new LinkedList<>();
        // find all `0`s
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (rooms[i][j] == 0) {
                    queue.add(i * cols + j);
                }
            }
        }
        // fill each empty cell
        while (!queue.isEmpty()) {
            int index = queue.poll();
            int x = index / cols;
            int y = index % cols;
            for (int i = 0; i < X.length; i++) {
                int xx = x + X[i];
                int yy = y + Y[i];
                if (xx >= 0 && xx < rows && yy >= 0 && yy < cols && rooms[xx][yy] == INF) {
                    rooms[xx][yy] = rooms[x][y] + 1;
                    queue.add(xx * cols + yy);
                }
            }
        }

        return rooms;
    }
}
```"	"array(array(int))[rooms];array(array(int))
[[ 2147483647,  -1,   0, 2147483647 ], [ 2147483647, 2147483647, 2147483647, -1  ], [ 2147483647,  -1, 2147483647, -1  ], [   0,  -1, 2147483647, 2147483647 ]];[[ 3, -1, 0,  1 ], [ 2,  2, 1, -1 ], [ 1, -1, 2, -1 ], [ 0, -1, 3,  4 ]]
[[ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ]];[[ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ]]
[[ 2147483647, 2147483647, 2147483647 ], [ 2147483647, 2147483647, 2147483647 ], [ 2147483647, 2147483647, 2147483647 ]];[[ 2147483647, 2147483647, 2147483647 ], [ 2147483647, 2147483647, 2147483647 ], [ 2147483647, 2147483647, 2147483647 ]]
[[ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ]];[[ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ]]
[[ 0,   0,  0 ], [ 0, 2147483647,  0 ], [ 0,   0,  0 ]];[[ 0, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 0 ]]
"
